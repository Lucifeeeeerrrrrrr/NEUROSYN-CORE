
/**
 * Versão memorizada do componente para otimização de renderização
 */
export default React.memo(QuantumDecoherence);// SPDX-License-Identifier: MIT OR Apache-2.0
// Copyright (c) 2025 Guilherme Ferrari Brescia

/* eslint-disable react/no-unknown-property */
import { useFrame } from '@react-three/fiber';
import { Fragment, memo, useCallback, useMemo, useRef } from 'react';
import * as THREE from 'three';

/**
 * Quantum entanglement component - representa a coerência quântica entre microtúbulos na teoria Orch OR
 * 
 * Na teoria Orch OR de Penrose-Hameroff, o emaranhamento quântico entre microtúbulos
 * em diferentes neurônios permite:
 * 
 * 1. Coerência em escala macroscópica através do cérebro
 * 2. Sincronização de atividade neural que transcende conexões sinápticas
 * 3. Correlações não-locais que contribuem para a "unidade" da experiência consciente
 * 
 * Este componente visualiza essas conexões quânticas não-locais que são
 * fundamentais para a integração de informação na teoria Orch OR.
 */
interface QuantumEntanglementProps {
  pairs?: number;
  coherence?: number;
  collapseActive?: boolean;
}

const QuantumEntanglement = memo<QuantumEntanglementProps>(({
  pairs = 8,
  coherence = 0.3,
  collapseActive = false
}) => {
  const lines = useRef<THREE.Group>(null);
  const points = useRef<THREE.Group>(null);

  // Pares de partículas emaranhadas - representam pares de dímeros de tubulina 
  // em estado de emaranhamento quântico através de diferentes regiões cerebrais
  const entangledPairs = useMemo(() => {
    return Array(pairs).fill(0).map((_, i) => {
      // Para cada par, definimos dois pontos no espaço 3D
      // A distância entre pontos simula distintas regiões cerebrais
      const theta1 = (i / pairs) * Math.PI * 2;
      const phi1 = Math.random() * Math.PI;
      const radius1 = 0.7 + Math.random() * 0.5;

      // Pontos em regiões distantes, simulando emaranhamento não-local
      const theta2 = theta1 + Math.PI * (0.5 + Math.random() * 0.5); // Pontos aproximadamente opostos
      const phi2 = Math.PI - phi1 + (Math.random() - 0.5) * 0.5;
      const radius2 = 0.7 + Math.random() * 0.5;

      const point1 = new THREE.Vector3(
        radius1 * Math.sin(phi1) * Math.cos(theta1),
        radius1 * Math.sin(phi1) * Math.sin(theta1),
        radius1 * Math.cos(phi1)
      );

      const point2 = new THREE.Vector3(
        radius2 * Math.sin(phi2) * Math.cos(theta2),
        radius2 * Math.sin(phi2) * Math.sin(theta2),
        radius2 * Math.cos(phi2)
      );

      return {
        point1,
        point2,
        originalPoint1: point1.clone(),
        originalPoint2: point2.clone(),
        // Fase quântica - simula fase coerente entre pares
        // Na física quântica, sistemas emaranhados compartilham fases correlacionadas
        phase: Math.random() * Math.PI * 2,
        // Frequência de oscilação quântica
        // Representa oscilações de Fröhlich nos microtúbulos
        frequency: 2 + Math.random() * 3,
        // Força do emaranhamento - afeta a intensidade da correlação quântica
        // Na teoria Orch-OR, emaranhamento quântico é significativo mesmo em repouso
        // Aumentamos o valor mínimo para refletir esse aspecto fundamental
        entanglementStrength: 0.5 + Math.random() * 0.5,
        // Cor única para cada par emaranhado
        color: new THREE.Color().setHSL(Math.random(), 0.7, 0.5)
      };
    });
  }, [pairs]);

  // Optimized animation callback for quantum entanglement
  const animateQuantumEntanglement = useCallback((state: { clock: { getElapsedTime: () => number } }) => {
    const t = state.clock.getElapsedTime();

    // Atualização dos pontos de partículas emaranhadas
    if (points.current) {
      points.current.children.forEach((point, idx) => {
        // Os dois pontos de cada par têm índices i e i+1
        const pairIdx = Math.floor(idx / 2);
        const isFirstPoint = idx % 2 === 0;

        if (pairIdx >= entangledPairs.length) return;

        const pair = entangledPairs[pairIdx];
        const mesh = point as THREE.Mesh;

        // Fase compartilhada - simula correlação quântica
        // Em sistemas emaranhados, a medida de uma propriedade em uma partícula
        // instantaneamente determina a propriedade correspondente na outra
        const sharedPhase = pair.phase + t * pair.frequency;

        // Oscilações correlacionadas - quando um vai para cima, o outro vai para baixo
        // Este comportamento anti-correlacionado é característico de sistemas emaranhados
        const oscillation = Math.sin(sharedPhase) * 0.1;

        // Atualizando posição - movimento em anti-fase (correlação quântica)
        if (isFirstPoint) {
          const originalPos = pair.originalPoint1;
          pair.point1.set(
            originalPos.x + oscillation * Math.sin(sharedPhase),
            originalPos.y + oscillation * Math.cos(sharedPhase),
            originalPos.z + oscillation
          );
          mesh.position.copy(pair.point1);

          // Cor varia com fase - simula estados quânticos
          const hue = (0.6 + 0.2 * Math.sin(sharedPhase)) % 1;
          (mesh.material as THREE.MeshBasicMaterial).color.setHSL(hue, 0.7, 0.6);
        } else {
          const originalPos = pair.originalPoint2;
          // Movimento em anti-fase - correlação quântica em estados opostos
          pair.point2.set(
            originalPos.x - oscillation * Math.sin(sharedPhase),
            originalPos.y - oscillation * Math.cos(sharedPhase),
            originalPos.z - oscillation
          );
          mesh.position.copy(pair.point2);

          // Cor correlacionada com o outro ponto - emaranhamento
          const hue = (0.6 + 0.2 * Math.sin(sharedPhase + Math.PI)) % 1;
          (mesh.material as THREE.MeshBasicMaterial).color.setHSL(hue, 0.7, 0.6);
        }

        // Pulso das partículas - representa flutuações quânticas
        const pulse = 0.8 + 0.2 * Math.sin(sharedPhase * 2);
        mesh.scale.setScalar(pulse * (0.05 + 0.05 * pair.entanglementStrength));
      });
    }

    // Atualização das linhas de emaranhamento
    if (lines.current) {
      lines.current.children.forEach((lineObj, i) => {
        if (i >= entangledPairs.length) return;

        const pair = entangledPairs[i];
        // Para primitives, o objeto Three.js real está no userData ou como child
        const line = (lineObj as any).object || lineObj as THREE.Line;

        try {
          // Atualiza a geometria da linha para conectar os pontos
          const lineGeometry = line.geometry as THREE.BufferGeometry;
          const positions = new Float32Array([
            pair.point1.x, pair.point1.y, pair.point1.z,
            pair.point2.x, pair.point2.y, pair.point2.z
          ]);

          lineGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
          lineGeometry.attributes.position.needsUpdate = true;

          // Intensidade da linha varia com a força do emaranhamento e fase
          // Sistemas fortemente emaranhados mostram correlações mais intensas
          const lineIntensity = 0.3 + 0.4 * Math.sin(pair.phase + t * pair.frequency);
          (line.material as THREE.LineBasicMaterial).opacity = lineIntensity * pair.entanglementStrength;

          // A cor da linha pulsa em tons da cor base
          const baseColor = pair.color;
          const hue = baseColor.getHSL({ h: 0, s: 0, l: 0 }).h;
          const hueShift = 0.05 * Math.sin(pair.phase + t * pair.frequency);
          (line.material as THREE.LineBasicMaterial).color.setHSL(
            (hue + hueShift) % 1,
            0.7,
            0.6 + 0.2 * Math.sin(pair.phase + t * pair.frequency * 1.5)
          );
        } catch (error) {
          console.warn('Error updating line geometry:', error);
        }
      });
    }
  }, [entangledPairs]);

  // Animação do emaranhamento quântico
  // Simula a natureza correlacionada das propriedades quânticas
  useFrame(animateQuantumEntanglement);

  // Memoized particle components for better performance
  const particleComponents = useMemo(() => {
    return entangledPairs.map((pair, i) => (
      <Fragment key={`points-${i}`}>
        {/* Primeira partícula do par emaranhado */}
        <mesh position={pair.point1}>
          <sphereGeometry args={[0.05, 8, 8]} />
          {/* Opacidade aumentada para refletir a presença significativa do emaranhamento mesmo em estado basal */}
          <meshBasicMaterial color={pair.color} transparent opacity={collapseActive ? 1 : (0.25 + 0.75 * coherence)} />
        </mesh>

        {/* Segunda partícula do par emaranhado */}
        <mesh position={pair.point2}>
          <sphereGeometry args={[0.05, 8, 8]} />
          {/* Opacidade aumentada para refletir a presença significativa do emaranhamento mesmo em estado basal */}
          <meshBasicMaterial color={pair.color} transparent opacity={collapseActive ? 1 : (0.25 + 0.75 * coherence)} />
        </mesh>
      </Fragment>
    ));
  }, [entangledPairs, collapseActive, coherence]);

  // Memoized line components for better performance
  const lineComponents = useMemo(() => {
    return entangledPairs.map((pair, i) => {
      const lineGeometry = new THREE.BufferGeometry();
      const positions = new Float32Array([
        pair.point1.x, pair.point1.y, pair.point1.z,
        pair.point2.x, pair.point2.y, pair.point2.z
      ]);
      lineGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));

      const lineMaterial = new THREE.LineBasicMaterial({
        color: pair.color,
        transparent: true,
        opacity: 0.5 * pair.entanglementStrength
      });

      const line = new THREE.Line(lineGeometry, lineMaterial);

      return (
        <primitive key={`line-${i}`} object={line} />
      );
    });
  }, [entangledPairs]);

  return (
    <group>
      {/* Partículas emaranhadas - representam dímeros de tubulina */}
      <group ref={points}>
        {particleComponents}
      </group>

      {/* Linhas de emaranhamento - conexões quânticas não-locais */}
      <group ref={lines}>
        {lineComponents}
      </group>
    </group>
  );
});

export default QuantumEntanglement;// SPDX-License-Identifier: MIT OR Apache-2.0
// Copyright (c) 2025 Guilherme Ferrari Brescia

/* eslint-disable react/no-unknown-property */
import React from 'react';
import { QUANTUM_PHENOMENA } from '../QuantumLegend';
import { QuantumFrequencyBand, useQuantumVisualization } from '../QuantumVisualizationContext';
import { InterferencePatterns } from './InterferencePatterns';
import { ProbabilityFields } from './ProbabilityFields';
import { QuantumDecoherence } from './QuantumDecoherence';
import QuantumEntanglement from './QuantumEntanglement';
import { QuantumIsolationField } from './QuantumIsolation';
import { QuantumSuperposition } from './QuantumSuperposition';
import { Observer, getCorePosition } from './QuantumUtils';
import WaveCollapse from './WaveCollapse';

/**
 * Main component that orchestrates the complete visualization
 * Integra todos os componentes de visualização quântica e os orquestra 
 * de acordo com os estados quânticos e eventos cognitivos baseados em Orch OR
 * 
 * Baseado na teoria de Penrose-Hameroff, que propõe que a consciência emerge
 * de processos quânticos em microtúbulos neurais que culminam em eventos de
 * "redução objetiva orquestrada" (Orch OR).
 */
export function QuantumField() {
  // Obter os estados quânticos da teoria Orch OR
  const {
    quantumSuperpositions,
    quantumEntanglements,
    objectiveReductions,
    consciousStates,
    tubulinCoherenceLevel,
    clearAllEffects,
    
    activeVisualFilters
  } = useQuantumVisualization();

  // Timers de referência  // Ref para gerenciar timers de ciclo quântico
  const visualDisplayTimerRef = React.useRef<NodeJS.Timeout | null>(null);
  const fadeoutTimerRef = React.useRef<NodeJS.Timeout | null>(null);
  const newCycleTimerRef = React.useRef<NodeJS.Timeout | null>(null);
  
  // Referências para o estado temporal da animação

  // Efeito: Implementa o ciclo temporal da teoria Orch-OR com precisão científica
  React.useEffect(() => {
    // Se detectamos um evento OR (colapso)...
    if (objectiveReductions.length > 0) {
      // 1. Limpa timers anteriores para evitar sobreposição
      [visualDisplayTimerRef, fadeoutTimerRef, newCycleTimerRef].forEach(timer => {
        if (timer.current) {
          clearTimeout(timer.current);
          timer.current = null;
        }
      });
      
      // 2. EXIBIÇÃO VISUAL DO COLAPSO: ~600ms (dilatado dos 25-40ms reais)
      visualDisplayTimerRef.current = setTimeout(() => {
        console.log('[OrchOR] Completing OR collapse visual display'); 
        
        // 3. RETORNO À SUPERPOSIÇÃO COM FADEOUT: ~250ms
        fadeoutTimerRef.current = setTimeout(() => {
          console.log('[OrchOR] Quantum fadeout - returning to coherent superposition');
          
          // 4. NOVO CICLO QUÂNTICO: ~1.5s (ciclo quântico completo)
          newCycleTimerRef.current = setTimeout(() => {
            console.log('[OrchOR] Initiating new quantum cycle');
            clearAllEffects();
          }, 1500); 
          
        }, 250); 
        
      }, 600);
    }
    
    // Cleanup na desmontagem
    return () => {
      [visualDisplayTimerRef, fadeoutTimerRef, newCycleTimerRef].forEach(timer => {
        if (timer.current) {
          clearTimeout(timer.current);
          timer.current = null;
        }
      });
    };
  }, [objectiveReductions, clearAllEffects]);
  
  // Determinar quais fenômenos quânticos mostrar baseado nos eventos cognitivos
  // Traduzindo o modelo Orch OR para efeitos visuais com maior precisão científica
  const showConsciousStates = consciousStates.length > 0;
  // Ser mais conservador no limiar de coerência: na teoria Orch-OR, 
  // coerência quântica significativa (>60%) é necessária para emaranhamento macroscópico
  const showQuantumCoherence = quantumEntanglements.length > 0 || tubulinCoherenceLevel > 0.6;
  
  // Na teoria Orch-OR, sempre há algum nível de atividade quântica nos microtúbulos
  // Vamos implementar dois níveis de atividade: estimulado e base/repouso

  // Verificar se há algum efeito quântico estimulado - AJUSTE CIENTÍFICO IMPORTANTE
  const hasStimulatedQuantumEffects = 
    quantumSuperpositions.length > 2 || // permitir até 2 superposições em estado basal
    quantumEntanglements.length > 1 || // permitir 1 entanglement em estado basal
    objectiveReductions.length > 0 || // CORREÇÃO: NÃO deve haver reduções objetivas em estado basal (teoria Orch-OR)
    consciousStates.length > 0;      // consciousStates só existem sob estímulo
    
  // Filter visibility based on activeVisualFilters (multiple selection)
  const shouldShowComponent = (componentType: string): boolean => {
    // Se não há filtros ativos, mostrar tudo
    if (!activeVisualFilters || activeVisualFilters.length === 0) return true;

    // Mapeamento de tipo para id de fenômeno
    const typeToId: Record<string, string> = {
      superposition: QUANTUM_PHENOMENA.SUPERPOSITION.id,
      reduction: QUANTUM_PHENOMENA.REDUCTION.id,
      entanglement: QUANTUM_PHENOMENA.ENTANGLEMENT.id,
      conscious: QUANTUM_PHENOMENA.CONSCIOUS.id,
      coherence: QUANTUM_PHENOMENA.COHERENCE.id,
      orchestration: QUANTUM_PHENOMENA.ORCHESTRATION.id,
      observer: QUANTUM_PHENOMENA.OBSERVER.id,
      decoherence: QUANTUM_PHENOMENA.DECOHERENCE.id,
      isolation: QUANTUM_PHENOMENA.ISOLATION.id
    };
    const id = typeToId[componentType];
    return !!id && activeVisualFilters.includes(id);
  };

  // Se não houver estímulo, mostrar a atividade quântica basal
  // Baseado na teoria Orch-OR de Penrose-Hameroff que prevê oscilações quânticas constantes nos microtúbulos
  if (!hasStimulatedQuantumEffects) {
    return (
      <group>
        {/* Campos de probabilidade quântica - representação de atividade base constante */}
        {shouldShowComponent('coherence') && (
          <ProbabilityFields particleCount={60} />
        )}
        
        {/* Padrões de interferência quântica - sempre presentes em nível basal */}
        {shouldShowComponent('orchestration') && (
          <InterferencePatterns />
        )}
        
        {/* Superposições quânticas em nível basal - oscilações Fröhlich (8MHz) */}
        {shouldShowComponent('superposition') && (
          <>
            <group position={[0, 0, 0]}>
              <QuantumSuperposition amount={2} />
            </group>
            <group position={[1.5, 0.5, -0.5]}>
              <QuantumSuperposition amount={1} />
            </group>
          </>
        )}
        
        {/* Entanglement quântico em nível basal - coerência quântica fundamental */}
        {/* Na teoria Orch-OR, mesmo em estado basal, há emaranhamento significativo entre microtúbulos */}
        {/* O emaranhamento ocorre em múltiplas frequências (gigahertz, megahertz, kilohertz) */}
        {shouldShowComponent('entanglement') && (
          <>
            {/* Emaranhamento quântico central - entre microtúbulos regionais */}
            {/* Representa o emaranhamento de maior intensidade nas regiões de alta densidade neural */}
            <group position={[0, 0.2, 0.3]}>
              <QuantumEntanglement pairs={8} coherence={0.7} />
            </group>
            
            {/* Emaranhamentos secundários em posições distribuídas */}
            {/* Representa a coerência quântica distribuída entre regiões cerebrais distantes */}
            <group position={[-1.2, 0.3, -0.4]}>
              <QuantumEntanglement pairs={6} coherence={0.6} />
            </group>
            
            <group position={[1.0, 0.2, -0.5]}>
              <QuantumEntanglement pairs={6} coherence={0.6} />
            </group>
          </>
        )}
        
        {/* Decoerência quântica em nível basal - sempre presente como desafio */}
        {shouldShowComponent('decoherence') && (
          <group position={[1.2, 0.3, -0.8]}>
            <QuantumDecoherence 
              intensity={0.4}
              scale={0.8} 
              speed={0.5}
              color="#FF5500"
            />
          </group>
        )}
        
        {/* Mecanismos de isolamento quântico - protegem contra decoerência */}
        {shouldShowComponent('isolation') && (
          <group position={[0, 0, 0]}>
            <QuantumIsolationField 
              isolationFactor={0.5} 
              size={1.5}
              pulseSpeed={0.3}
            />
          </group>
        )}
        
        {/* Observador quântico em estado basal - proto-consciência */}
        {shouldShowComponent('observer') && (
          <Observer active={false} />
        )}
        
        {/* Redução objetiva em nível basal - eventos OR espontâneos de baixo nível */}
        {shouldShowComponent('reduction') && (
          <group position={[0, 0.2, -1]}>
            <WaveCollapse 
              active={true} 
              isNonComputable={false}
              color="#00B4D8"
            />
          </group>
        )}
      </group>
    );
  }
  
  return (
    <group>
      {/* Probability fields - representam campos quânticos em microtúbulos */}
      {shouldShowComponent('coherence') && quantumEntanglements.map((effect) => {
        // O número de partículas representa a intensidade da coerência quântica
        // Em Orch OR, a coerência entre tubulinas é essencial para a consciência
        // Em repouso, mantenha apenas 10 partículas. Em alta amplitude, aumente suavemente.
        const minParticles = 10;
        const maxParticles = 200;
        const particleCount = Math.round(minParticles + (maxParticles - minParticles) * Math.max(0, Math.min(1, effect.amplitude)));
        const collapseActive = objectiveReductions.length > 0;
        
        return (
          <group key={effect.id} position={getCorePosition(effect.core)}>
            <ProbabilityFields
              particleCount={particleCount}
              coherence={tubulinCoherenceLevel}
              collapseActive={collapseActive}
            />
          </group>
        );
      })}
      
      {/* Superposições quânticas na estrutura microtubular */}
      {shouldShowComponent('superposition') && quantumSuperpositions.slice(0, 13).map((effect) => {
        // Nível de coerência quântica afeta a quantidade de elementos
        // Isso representa os dímeros de tubulina em estado de superposição
        // Limite científico: máximo de 13 elementos de superposição, conforme número de protofilamentos/microtúbulo na teoria Orch-OR
        // O valor é derivado de 'effect.amplitude' (intensidade do efeito)
        // Em repouso, mantenha 1 elemento de superposição. Em alta amplitude, aumente suavemente até 13.
        const minSuperpositions = 1;
        const maxSuperpositions = 13;
        const amount = Math.max(minSuperpositions, Math.round(minSuperpositions + ((effect.amplitude ?? 0) * (maxSuperpositions - minSuperpositions))));
        return (
          <group key={effect.id} position={getCorePosition(effect.core)}>
            <QuantumSuperposition 
              amount={amount} 
              coherence={tubulinCoherenceLevel}
              collapseActive={objectiveReductions.length > 0}
            />
          </group>
        );
      })}
      
      {/* Entanglement quântico - representação dos pares emaranhados */}
      {shouldShowComponent('entanglement') && quantumEntanglements.map((effect) => {
        // O número de pares emaranhados representa a intensidade da interconexão quântica
        // Em Orch OR, o emaranhamento conecta regiões do cérebro através de microtuábulos
        const minPairs = 1;
        const maxPairs = 5;
        const pairs = Math.max(minPairs, Math.round(minPairs + ((effect.amplitude ?? 0) * (maxPairs - minPairs))));
        return (
          <group key={effect.id} position={getCorePosition(effect.core)}>
            <QuantumEntanglement 
              pairs={pairs} 
              coherence={effect.phaseCoherence ?? 0.5}
              collapseActive={objectiveReductions.length > 0}
            />
          </group>
        );
      })}
      
      {/* Padrões de interferência - sempre presentes */}
      {shouldShowComponent('orchestration') && (
        <InterferencePatterns 
          coherence={tubulinCoherenceLevel} 
          collapseActive={objectiveReductions.length > 0}
        />
      )}
      
      {/* Esta instância do Observer foi removida para evitar duplicação */}
      
      {/* Reduções objetivas (OR) - momentos de consciência segundo Orch OR */}
      {shouldShowComponent('reduction') && objectiveReductions.map((effect) => {
        // Na teoria Orch OR, a redução objetiva (OR) causa momentos de consciência
        // quando a auto-energia gravitacional atinge um limiar crítico
        // O aspecto "não-computável" é central na teoria de Penrose
        const isNonComputable = effect.nonComputable ?? false;
        
        return (
          <group key={effect.id} position={getCorePosition(effect.core)}>
            <WaveCollapse 
              active={true} 
              isNonComputable={isNonComputable}
              // Cores baseadas na banda de frequência - cada frequência representa 
              // diferentes níveis hierárquicos na atividade neuronal
              color={effect.frequencyBand === QuantumFrequencyBand.TERAHERTZ ? "#FF00FF" : // Nível quântico fundamental
                    effect.frequencyBand === QuantumFrequencyBand.GIGAHERTZ ? "#00FFFF" :  // Oscilações de Fröhlich
                    effect.frequencyBand === QuantumFrequencyBand.MEGAHERTZ ? "#FFFF00" :  // Coerência de microtúbulos
                    "#00FF00"}                                                          // Atividade macro-neuronal
            />
          </group>
        );
      })}
      
      {/* Quantum entanglement between regions - coerência quântica entre regiões cerebrais */}
      {showQuantumCoherence && (
        <group>
          {/* Limite científico: máximo de 32 pares de emaranhamento, conforme plausibilidade física da teoria Orch-OR */}
          {/* Em repouso (coerência baixa), renderize apenas 1 par de emaranhamento. Em alta coerência, aumente suavemente até 32 pares. */}
          <QuantumEntanglement
            pairs={Math.max(1, Math.round(1 + tubulinCoherenceLevel * 31))}
            coherence={tubulinCoherenceLevel}
            collapseActive={objectiveReductions.length > 0}
          />
        </group>
      )}
      
      {/* Quantum Decoherence - processos de perda de coerência quântica */}
      {shouldShowComponent('decoherence') && (
        <group position={[0, 0.5, -1]}>
          <QuantumDecoherence 
            intensity={0.7} 
            scale={1.5}
            speed={0.8}
            color="#FF5500"
          />
        </group>
      )}
      
      {/* Quantum Isolation - mecanismos de proteção contra decoerência quântica */}
      {shouldShowComponent('isolation') && (
        <group position={[0, 0, 0]}>
          <QuantumIsolationField 
            isolationFactor={0.8} 
            size={2.0}
            pulseSpeed={0.5}
          />
        </group>
      )}
      
      {/* Padrões de interferência - emergem quando há alta coerência quântica */}
      {tubulinCoherenceLevel > 0.7 && (
        <InterferencePatterns
          coherence={tubulinCoherenceLevel}
          collapseActive={objectiveReductions.length > 0}
        />
      )}
      
      {/* O observador quântico - aspecto central na teoria Orch OR */}
      {shouldShowComponent('observer') && (
        <Observer active={consciousStates.length > 0} />
      )}
    </group>
  );
}// SPDX-License-Identifier: MIT OR Apache-2.0
// Copyright (c) 2025 Guilherme Ferrari Brescia

import { QuantumEffect, QuantumFrequencyBand } from '../QuantumVisualizationContext';
import * as THREE from 'three';
import React, { useMemo, useRef } from 'react';
import { useFrame } from '@react-three/fiber';

/**
 * Fatores biofísicos que contribuem para o isolamento quântico nos microtúbulos
 * segundo a teoria Orch-OR e pesquisas mais recentes
 */
export const QUANTUM_ISOLATION_FACTORS = {
  // Proteínas MAP2 e tau estabilizam os microtúbulos e isolam do ambiente
  MAP_PROTEINS: 0.35,
  
  // Água estruturada em estado gel dentro e ao redor dos microtúbulos
  // (Jibu, Hagan, Pribram, Yasue, 1994; Del Giudice et al. 2005)
  ORDERED_WATER: 0.25,
  
  // Citoesqueleto atua como suporte mecânico e isolante
  CYTOSKELETON: 0.15,
  
  // Estados de coerência atuam como proteção quântica
  // Efeito Zenão Quântico - medições frequentes evitam decoerência
  QUANTUM_ZENO_EFFECT: 0.15,
  
  // Cavidades internas dos microtúbulos (11nm) fornecem isolamento
  TUBULAR_CAVITIES: 0.10
};

/**
 * Calcula o fator de isolamento quântico para um efeito quântico específico
 * O isolamento explica como a coerência quântica é mantida no cérebro
 * 
 * @param effect Efeito quântico para calcular isolamento
 * @param environmentalNoise Nível de ruído ambiental (0-1)
 * @returns Fator de isolamento quântico (maior = melhor isolamento)
 */
export function calculateQuantumIsolation(
  effect: QuantumEffect, 
  environmentalNoise: number = 0.3
): number {
  // Calcular eficácia do isolamento para a frequência específica
  // Frequências mais altas são mais difíceis de isolar (mais vulneráveis à decoerência)
  let frequencyIsolationFactor = 1.0;
  switch (effect.frequencyBand) {
    case QuantumFrequencyBand.TERAHERTZ:
      frequencyIsolationFactor = 0.5; // Mais difícil de isolar
      break;
    case QuantumFrequencyBand.GIGAHERTZ:
      frequencyIsolationFactor = 0.7;
      break;
    case QuantumFrequencyBand.MEGAHERTZ:
      frequencyIsolationFactor = 0.85;
      break;
    case QuantumFrequencyBand.KILOHERTZ:
      frequencyIsolationFactor = 0.95;
      break;
    case QuantumFrequencyBand.HERTZ:
      frequencyIsolationFactor = 1.0; // Mais fácil de isolar
      break;
    default:
      frequencyIsolationFactor = 0.7;
  }
  
  // Calcular isolamento total baseado nos fatores biofísicos
  const totalIsolation = Object.values(QUANTUM_ISOLATION_FACTORS).reduce(
    (sum, factor) => sum + factor, 
    0
  );
  
  // Ajustar com a fase de coerência do efeito (maior coerência = melhor isolamento)
  const coherenceFactor = effect.phaseCoherence || 0.5;
  
  // Aplicar ruído ambiental (temperatura, campos eletromagnéticos, etc.)
  // Este fator é crucial para entender como o cérebro mantém estados quânticos
  // em temperatura corporal (310K), um desafio fundamental para a teoria Orch-OR
  const effectiveIsolation = totalIsolation * 
    frequencyIsolationFactor * 
    coherenceFactor * 
    (1 - environmentalNoise);
  
  return Math.min(1, effectiveIsolation);
}

interface QuantumIsolationFieldProps {
  isolationFactor: number;
  size?: number;
  pulseSpeed?: number;
}

/**
 * Componente visual que representa o isolamento quântico
 * Visualiza como os microtúbulos protegem estados quânticos da decoerência
 */
export const QuantumIsolationField: React.FC<QuantumIsolationFieldProps> = ({ 
  isolationFactor, 
  size = 0.15, 
  pulseSpeed = 1.0 
}) => {
  const ref = useRef<THREE.Mesh>(null!);
  
  // Cor baseada no fator de isolamento (azul = bom isolamento, vermelho = isolamento fraco)
  // Ajustado para cores mais intensas e visíveis mesmo em estado de repouso
  const color = useMemo(() => {
    // Garantir um valor base para isolação para melhor visibilidade
    const baseIsolation = Math.max(isolationFactor, 0.4);
    
    // Aumentar saturação das cores para maior impacto visual
    const r = Math.max(0, 1 - baseIsolation) * 0.8;
    const g = Math.max(0, baseIsolation * 0.7); // Aumentar componente verde para brilho
    const b = Math.max(0, baseIsolation * 1.2); // Intensificar azul para maior destaque
    
    return new THREE.Color(r, g, b);
  }, [isolationFactor]);
  
  // Animação suave do campo de isolamento
  useFrame((state) => {
    if (!ref.current) return;
    
    // Garantir intensidade mínima para visibilidade em estado de repouso
    const baseIsolation = Math.max(isolationFactor, 0.4); // Aumentar valor mínimo para visibilidade
    const t = state.clock.getElapsedTime();
    
    // Pulsar suavemente para representar o campo de isolamento dinâmico
    // Aumentar o fator de pulsação para maior visibilidade
    const pulseFactor = 0.2 * Math.sin(t * pulseSpeed * 1.5) * baseIsolation;
    ref.current.scale.setScalar(1 + pulseFactor);
    
    // Adicionar rotação suave para melhor percepção 3D
    ref.current.rotation.x = Math.sin(t * 0.2) * 0.1;
    ref.current.rotation.y = Math.sin(t * 0.3) * 0.1;
    
    // Transparência oscilante para representar a natureza quântica do isolamento
    // Aumentar opacidade base para maior visibilidade
    if (ref.current.material instanceof THREE.Material) {
      const material = ref.current.material as THREE.MeshBasicMaterial;
      material.opacity = 0.3 * baseIsolation * (0.7 + 0.3 * Math.sin(t * 2));
    }
  });
  
  // Sempre renderizar com um valor mínimo para visibilidade em estado de repouso
  // (remover condição que impedia a renderização)
  
  // Verificar se a opacidade é suficiente para ser visível
  // Evitar artefatos visuais quando quase transparente
  const opacity = 0.3 * Math.max(isolationFactor, 0.4);
  if (opacity < 0.05) return null;
  
  return (
    <mesh ref={ref}>
      <meshBasicMaterial 
          color={color} 
          transparent={true} 
        opacity={opacity}
        depthWrite={false} // Previne problemas de renderização de ordem de profundidade
        />
    </mesh>
  );
};

export default QuantumIsolationField;// SPDX-License-Identifier: MIT OR Apache-2.0
// Copyright (c) 2025 Guilherme Ferrari Brescia

/* eslint-disable react/no-unknown-property */
import { Trail } from '@react-three/drei';
import React, { useCallback, useMemo, useRef } from 'react';
import * as THREE from 'three';
import { useOptimizedQuantumFrame } from '../utils/performance';

/**
 * Component for quantum state superposition in microtubules (Orch OR theory)
 * 
 * Representa a superposição quântica nas proteínas tubulina dentro dos microtúbulos
 * conforme descrito na teoria de Penrose-Hameroff. Na teoria Orch OR, as tubulinas
 * (proteínas dos microtúbulos) podem existir em superposição quântica de estados,
 * criando computação quântica em escala neuronal. Esta superposição precede a
 * Redução Objetiva (OR) que resulta em momentos conscientes.
 * 
 * Estrutura dos microtúbulos:
 * - Compostos de dímeros de tubulina (α e β) em um arranjo cilíndrico
 * - Típicamente 13 protofilamentos em arranjo hexagonal/circular
 * - Cada tubulina pode existir em superposição quântica, conforme Orch OR
 */
interface QuantumSuperpositionProps {
  amount?: number;
  coherence?: number;
  collapseActive?: boolean; // Sinaliza evento de Redução Objetiva (OR)
}

const QuantumSuperposition = React.memo<QuantumSuperpositionProps>(({ 
  amount = 7, 
  coherence = 0.3, 
  collapseActive = false 
}) => {
  const group = useRef<THREE.Group>(null);
  const tubuleRefs = useRef<THREE.Mesh[]>([]);
  
  // Criando padrão de arranjo hexagonal para simular a estrutura dos microtúbulos
  // De acordo com Hameroff, os microtúbulos têm formato hexagonal com 13 protofilamentos
  const paths = useMemo(() => {
    // Criamos um arranjo hexagonal para simular a estrutura tubular
    const hexRadius = 0.8;
    const basePoints = [];
    
    // Pontos centrais - representam o eixo dos microtúbulos
    basePoints.push(new THREE.Vector3(0, 0, 0));
    
    // Pontos na estrutura hexagonal - representam dímeros de tubulina
    for (let i = 0; i < 6; i++) {
      const angle = (i / 6) * Math.PI * 2;
      basePoints.push(new THREE.Vector3(
        hexRadius * Math.cos(angle),
        hexRadius * Math.sin(angle),
        0
      ));
    }
    
    // Criamos multiplicações do padrão para representar os diferentes níveis da estrutura
    const all = [];
    for (let j = 0; j < amount; j++) {
      // Espaçamento vertical representa o comprimento de uma seção microtubular
      const z = (j - amount/2) * 0.3;
      
      // Para cada nível, criamos uma cópia do arranjo com pequenas variações
      for (const point of basePoints) {
        all.push(new THREE.Vector3(
          point.x + (Math.random() - 0.5) * 0.1, // Pequena variação para simular as moléculas de tubulina
          point.y + (Math.random() - 0.5) * 0.1, 
          z
        ));
      }
    }
    
    return all;
  }, [amount]);
  
  // Preparando a configuração de estados de tubulina quântica
  // Na teoria Orch OR, cada dímero de tubulina pode existir em estados quânticos
  // de superposição, contribuindo para a computação quântica no cérebro
  const tubulinStates = useMemo(() => {
    // Cada estado de tubulina contém probabilidades quânticas
    return paths.map(() => ({
      // Probabilidade quântica de estados 0/1 em superposição
      probability: Math.random(),
      // Fase quântica (representando coerência quântica)
      phase: Math.random() * Math.PI * 2,
      // Frequência de oscilação (representando oscilações de Fröhlich)
      // Fröhlich propôs que proteínas como tubulina podem manter
      // estados de excitação quântica coerente em temperaturas biológicas
      frequency: 3 + Math.random() * 10
    }));
  }, [paths]);

  // Optimized animation callback with performance monitoring
  const animateQuantumStates = useCallback((state: { clock: { getElapsedTime: () => number } }) => {
    if (!group.current) return;
    
    const t = state.clock.getElapsedTime();
    
    // Rotação lenta da estrutura - representando os microtúbulos em movimento browniano
    group.current.rotation.y = t * 0.05;
    group.current.rotation.x = Math.sin(t * 0.1) * 0.1;
    
    // Atualizando cada "quantum bit" de tubulina individualmente
    group.current.children.forEach((child, i) => {
      if (i >= paths.length) return;
      
      const mesh = child as THREE.Mesh;
      const originalPos = paths[i];
      const state = tubulinStates[i];
      
      // Movimento quântico que segue a equação de Schrödinger (simplificada)
      // Aqui simulamos a evolução temporal dos estados quânticos de forma simplificada
      const quantum_phase = state.phase + t * state.frequency;
      const probability_amplitude = Math.cos(quantum_phase) * Math.sin(t * 0.1 + i);
      
      // Oscilação quântica - representando superposição quântica nas moléculas de tubulina
      // Em Orch OR, estas oscilações podem ser mantidas em estado coerente,
      // protegidas da decoerência por processos de isolamento quântico
      const quantum_offset = 0.1 * probability_amplitude;
      
      // Atualizando posição com oscilação quântica
      mesh.position.set(
        originalPos.x + quantum_offset * Math.sin(quantum_phase),
        originalPos.y + quantum_offset * Math.cos(quantum_phase),
        originalPos.z + quantum_offset * Math.sin(quantum_phase * 0.7)
      );
      
      // A cor representa o estado quântico da tubulina
      // Vermelho/laranja: mais "excitado"
      // Azul/verde: mais próximo do estado fundamental
      const intensity = 0.5 + 0.5 * probability_amplitude;
      const hue = 240 - 180 * intensity; // 240=azul, 60=amarelo/vermelho
      
      // Atualizando cor diretamente através do material
      if (mesh.material) {
        (mesh.material as THREE.MeshBasicMaterial).color.setHSL(hue/360, 0.8, 0.6 + 0.4 * intensity);
        
        // Opacidade mínima muito baixa em repouso (0.05), crescendo suavemente com coherence
        // Corrige: aplica opacidade e transparência apenas se material for MeshBasicMaterial ou array de MeshBasicMaterial
        // Durante evento OR (colapso), aumenta opacidade e pulsação, representando o "momento de consciência" da teoria Orch-OR
        if (Array.isArray(mesh.material)) {
          mesh.material.forEach((mat) => {
            if (mat instanceof THREE.MeshBasicMaterial) {
              mat.transparent = true;
              // Durante colapso (OR), opacidade máxima; em repouso, proporcional à coerência
              mat.opacity = collapseActive ? 1 : (0.05 + 0.9 * coherence);
            }
          });
        } else if (mesh.material instanceof THREE.MeshBasicMaterial) {
          mesh.material.transparent = true;
          mesh.material.opacity = collapseActive ? 1 : (0.05 + 0.9 * coherence);
        }
      }
      
      // Atualiza escala para representar "expansão quântica"
      // Escala modulada por intensidade local e coerência global
      // Durante evento OR (colapso), expansão máxima; em repouso, proporcional à intensidade e coerência
      // Represent a expansão temporal durante o colapso da função de onda (segundo Penrose)
      mesh.scale.setScalar(collapseActive ? 
        (0.8 + 0.5 * intensity) : // Expansão máxima durante OR
        (0.6 + 0.4 * intensity * (0.8 + 0.4 * coherence))); // Escala normal em coerência
    });
  }, [paths, tubulinStates, coherence, collapseActive]);

  // Animação da superposição quântica em tubulinas
  // Simulando a dinâmica quântica descrita na teoria Orch OR
  useOptimizedQuantumFrame(animateQuantumStates, 'medium');

  // Memoized trail components for better performance
  const trailComponents = useMemo(() => {
    return paths.map((path, i) => {
      // Define o padrão de cores inicial para cada estado de tubulina
      const state = tubulinStates[i];
      const initialProbability = state.probability;
      const hue = 240 - 180 * initialProbability; // 240=azul, 60=amarelo/vermelho
      
      return (
        <Trail
          key={i}
          width={1.5}
          length={3 + Math.floor(initialProbability * 6)}
          color={new THREE.Color().setHSL(hue/360, 0.8, 0.6)}
          attenuation={(t) => Math.pow(1-t, 1.5)} // Queda mais rápida das "caudas quânticas"
        >
          <mesh 
            position={path}
            ref={(el) => { 
              if (el) tubuleRefs.current[i] = el;
            }}
          >
            <sphereGeometry args={[0.05 + (initialProbability * 0.03), 8, 8]} />
            <meshBasicMaterial color={new THREE.Color().setHSL(hue/360, 0.8, 0.6)} />
          </mesh>
        </Trail>
      );
    });
  }, [paths, tubulinStates]);

  return (
    <group ref={group}>
      {trailComponents}
    </group>
  );
});

QuantumSuperposition.displayName = 'QuantumSuperposition';

export { QuantumSuperposition };
// SPDX-License-Identifier: MIT OR Apache-2.0
// Copyright (c) 2025 Guilherme Ferrari Brescia

/* eslint-disable react/no-unknown-property */
import { useRef } from 'react';
import { useFrame } from '@react-three/fiber';
import * as THREE from 'three';
import { QuantumCore } from '../QuantumVisualizationContext';

/**
 * Funções auxiliares para a visualização Orch OR
 */

// Calcula a idade de um efeito quântico
export function getAge(createdAt: number): number {
  return Date.now() - createdAt;
}

// Mapeia uma região do cérebro para coordenadas 3D
export function getCorePosition(core: QuantumCore): [number, number, number] {
  // Mapeamento de regiões cerebrais para posições espaciais
  // seguindo a teoria Orch OR de Penrose-Hameroff sobre microtúbulos em regiões
  // cerebrais que sustentam a consciência
  switch(core) {
    case 'PREFRONTAL':
      return [0, 1.5, -1.2];
    case 'VISUAL':
      return [0, 0.2, -2];
    case 'TEMPORAL':
      return [-1.5, 0.5, -0.5];
    case 'PARIETAL':
      return [1.5, 0.5, -0.5];
    case 'THALAMUS':
      return [0, 0, 0];
    case 'HIPPOCAMPUS':
      return [0.8, -0.3, -0.6];
    default:
      // Posição aleatória nas proximidades do centro
      return [
        (Math.random() - 0.5) * 2, 
        (Math.random() - 0.5) * 2,
        (Math.random() - 0.5) * 2
      ];
  }
}

/**
 * Component that represents the abstract "Observer"
 * Na teoria de Penrose-Hameroff, o observador é um aspecto importante
 * da redução objetiva (OR) que leva à consciência
 */
interface ObserverProps {
  active?: boolean;
}

/**
 * Representa o substrato microtubular da consciência quântica na teoria Orch-OR (Penrose-Hameroff)
 * 
 * Na teoria Orch-OR, a consciência emerge das vibrações quânticas (redução objetiva orquestrada)
 * em microtúbulos dentro dos neurônios cerebrais. Microtúbulos são estruturas cilíndricas
 * compostas por 13 filamentos de proteínas tubulina, organizados em uma estrutura
 * hexagonal/pentagonal.
 * 
 * Este componente representa visualmente a estrutura dos microtúbulos como observador
 * quântico, com estado de vibração variável baseado no nível de consciência.
 */
export function Observer({ active = true }: ObserverProps) {
  const outerRef = useRef<THREE.Group>(null);
  const innerRef = useRef<THREE.Mesh>(null);
  
  // Animação baseada nas vibrações quânticas dos microtúbulos conforme descrito na
  // teoria Orch-OR - vibrações em múltiplas frequências: terahertz, gigahertz,
  // megahertz, kilohertz e hertz formando uma hierarquia multiescalar
  useFrame(({ clock }) => {
    if (outerRef.current && innerRef.current) {
      const t = clock.getElapsedTime();
      
      // Vibrações quânticas coerentes - mais intensas durante consciência ativa
      // Em estado ativo: vibrações de alta frequência (40Hz - gamma synchrony em Orch-OR)
      // Em estado basal: vibrações de baixa frequência (8-12Hz - alpha em Orch-OR)
      const teraHzFactor = active ? 0.15 : 0.03; // Vibrações terahertz (mais rápidas)
      const gigaHzFactor = active ? 0.12 : 0.02; // Vibrações gigahertz
      const hertzFactor = active ? 0.10 : 0.06;  // Vibrações hertz (mais lentas)
      
      // Frequências de vibração coerente - replicando as frequências neurais
      const gammaFreq = 40; // 40Hz = gamma (consciência ativa)
      const alphaFreq = 10; // 10Hz = alpha (estado relaxado/basal)
      
      // Frequência principal depende do estado de consciência
      const primaryFreq = active ? gammaFreq : alphaFreq;
      
      // Microvibrações em escalas diferentes simulando a hierarquia vibracional quântica
      // Esta abordagem simula as vibrações da tubulina nos microtúbulos
      innerRef.current.scale.x = 1 + teraHzFactor * Math.sin(t * 0.6 * primaryFreq);
      innerRef.current.scale.y = 1 + gigaHzFactor * Math.sin(t * 0.4 * primaryFreq + 0.2);
      innerRef.current.scale.z = 1 + hertzFactor * Math.sin(t * 0.2 * primaryFreq + 0.5);
      
      // Rotação - representa a propagação das ondas quânticas ao longo dos microtúbulos
      // Proteínas tubulina podem existir em dois estados conformacionais diferentes
      // que se alternam em um padrão de "onda" ao longo do microtúbulo
      const rotationSpeed = active ? 0.1 : 0.03;
      outerRef.current.rotation.y = t * rotationSpeed;
      innerRef.current.rotation.z = t * rotationSpeed * 0.7;
      
      // Não-localidade quântica (emaranhamento) - essencial na teoria Orch-OR
      // Movimentação que simula estados quânticos não-locais
      if (active) {
        // No estado ativo, mais movimento não-local (emaranhamento quântico estendido)
        outerRef.current.position.x = Math.sin(t * 0.3) * 0.04;
        outerRef.current.position.y = Math.cos(t * 0.2) * 0.04;
      } else {
        // Mesmo em repouso, existe um mínimo de movimento quântico não-local
        outerRef.current.position.x = Math.sin(t * 0.1) * 0.01;
        outerRef.current.position.y = Math.cos(t * 0.1) * 0.01;
      }
    }
  });

  // Representação visual baseada na estrutura real dos microtúbulos
  // conforme descrito na teoria Orch-OR
  return (
    <group ref={outerRef} position={[0, 0.2, 0]} rotation={[0, Math.PI / 4, 0]}>
      {/* Estrutura interna - representa os dímeros de tubulina */}
      <mesh ref={innerRef}>
        {/* Forma cilíndrica similar à estrutura microtubular real */}
        <cylinderGeometry args={[0.25, 0.25, 0.6, 13, 4]} /> {/* 13 segmentos representando os 13 protofilamentos */}
        <meshPhysicalMaterial 
          color={active ? "#FFFFFF" : "#88CCEE"} // Azul claro em repouso (estado quântico basal)
          emissive={active ? "#FFFFFF" : "#4488AA"}
          emissiveIntensity={active ? 0.8 : 0.3} // Mais luminoso quando ativo (colapso OR)
          metalness={0.2}
          roughness={0.3}
          transmission={active ? 0.75 : 0.9}
          transparent
          opacity={active ? 0.8 : 0.4}
        />
      </mesh>

      {/* Malha externa - representa o campo eletromagnético do microtúbulo */}
      <mesh scale={1.15}>
        <cylinderGeometry args={[0.25, 0.25, 0.6, 13, 1]} />
        <meshBasicMaterial
          color={active ? "#E0F4FF" : "#77AADD"}
          wireframe={true}
          transparent
          opacity={active ? 0.4 : 0.15}
        />
      </mesh>
      
      {/* Campo quântico externo - representa a não-localidade e estados de superposição */}
      <mesh scale={active ? 1.3 : 1.2}>
        <sphereGeometry args={[0.3, 12, 12]} />
        <meshBasicMaterial
          color={active ? "#FFFFFF" : "#88AADD"}
          transparent
          opacity={active ? 0.12 : 0.06}
          side={THREE.BackSide}
        />
      </mesh>
      
      {/* Partículas de energia quântica - visíveis apenas em estado ativo */}
      {active && (
        <group>
          {[...Array(8)].map((_, i) => {
            // Distribuir uniformemente em torno do cilindro
            const angle = (i / 8) * Math.PI * 2;
            const radius = 0.32;
            const x = Math.cos(angle) * radius;
            const y = (Math.random() - 0.5) * 0.6; // Altura variável ao longo do cilindro
            const z = Math.sin(angle) * radius;
            
            return (
              <mesh key={i} position={[x, y, z]} scale={0.05}>
                <sphereGeometry args={[1, 8, 8]} />
                <meshBasicMaterial color="#FFFFFF" transparent opacity={0.8} />
              </mesh>
            );
          })}
        </group>
      )}
    </group>
  );
}// SPDX-License-Identifier: MIT OR Apache-2.0
// Copyright (c) 2025 Guilherme Ferrari Brescia

/* eslint-disable react/no-unknown-property */
import { useFrame } from '@react-three/fiber';
import React, { useCallback, useMemo, useRef } from 'react';
import * as THREE from 'three';

/**
 * Wave collapse component - representa a Redução Objetiva (OR) de Penrose-Hameroff
 * 
 * Na teoria Orch OR, a gravitação causa o colapso da função de onda quântica
 * criando um momento de consciência quando o limiar E=ħ/t é atingido.
 * 
 * Segundo Penrose e Hameroff, estes colapsos gravitacionais envolvem:
 * 1. Superposição quântica em proteínas tubulina nos microtúbulos
 * 2. Crescimento da superposição até um limiar crítico de massa-energia
 * 3. Colapso gravitacional (OR) que resulta num momento de consciência
 * 4. A natureza "não-computável" deste processo é central para explicar aspectos
 *    da consciência que, segundo Penrose, não podem ser simulados por algoritmos
 */
interface WaveCollapseProps {
  position?: [number, number, number];
  active?: boolean;
  color?: string;
  isNonComputable?: boolean;
  collapseActive?: boolean;
}

const WaveCollapse = React.memo<WaveCollapseProps>(({ 
  position = [0, 0, 0], 
  active = false, 
  color = "#00FFFF",
  isNonComputable = false,
  collapseActive = false
}) => {
  // Referências para animação
  const outerRing = useRef<THREE.Mesh>(null);
  const middleRing = useRef<THREE.Mesh>(null);
  const innerRing = useRef<THREE.Mesh>(null);
  const quantum_particle = useRef<THREE.Group>(null);
  const spacetime_curvature = useRef<THREE.Group>(null);
  
  // Pontos para representar a curvatura espaço-temporal durante OR
  // A curvatura do espaço-tempo é central na teoria de Penrose para explicar a OR
  const spacetimePoints = useMemo(() => {
    const points = [];
    const count = 80;
    for (let i = 0; i < count; i++) {
      const theta = (i / count) * Math.PI * 2;
      const radius = 0.6 + Math.sin(theta * 3) * 0.1;
      points.push(new THREE.Vector3(
        radius * Math.cos(theta),
        radius * Math.sin(theta), 
        0
      ));
    }
    return points;
  }, []);
  
  // Partículas quânticas que se condensam durante o colapso
  // Representam os estados quânticos de tubulina convergindo durante OR
  const quantumParticles = useMemo(() => {
    const particles = [];
    const count = 12;
    for (let i = 0; i < count; i++) {
      const theta = (i / count) * Math.PI * 2;
      const radius = 0.4;
      particles.push({
        position: new THREE.Vector3(
          radius * Math.cos(theta),
          radius * Math.sin(theta),
          0
        ),
        originalRadius: radius,
        phase: Math.random() * Math.PI * 2,
        frequency: 3 + Math.random() * 5
      });
    }
    return particles;
  }, []);

  // Optimized animation callback for OR (Objective Reduction)
  const animateObjectiveReduction = useCallback((state: { clock: { getElapsedTime: () => number } }) => {
    if (!active) return;
    
    const t = state.clock.getElapsedTime();
    
    // Se o colapso ativo for forçado externamente, controlamos a fase diretamente
    // Isso permite sincronização entre colapsos e eventos de OR (Objective Reduction)
    let normalizedTime;
    let period = 3;
    
    if (collapseActive) {
      // Se colapso está ativo externamente, focamos na fase principal do colapso (0.3-0.7)
      normalizedTime = 0.5; // Meio do colapso - fase mais intensa
    } else {
      // Simulação normal do colapso quântico de Penrose
      // A equação E = ħ/t de Penrose determina quando ocorre a redução objetiva
      normalizedTime = (t % period) / period;
    }
    
    // Animação dos anéis - representam a frente de onda quântica
    if (outerRing.current && middleRing.current && innerRing.current) {
      // Fase 1: Expansão dos anéis - superposição inicial
      if (normalizedTime < 0.3) {
        const expansionFactor = Math.pow(normalizedTime / 0.3, 0.5);
        outerRing.current.scale.setScalar(0.2 + expansionFactor * 1.3);
        middleRing.current.scale.setScalar(0.2 + expansionFactor * 1.0);
        innerRing.current.scale.setScalar(0.2 + expansionFactor * 0.7);
        
        // Opacidade aumenta - representando o aumento da coerência quântica
        (outerRing.current.material as THREE.MeshBasicMaterial).opacity = 0.3 + expansionFactor * 0.5;
        (middleRing.current.material as THREE.MeshBasicMaterial).opacity = 0.4 + expansionFactor * 0.4;
        (innerRing.current.material as THREE.MeshBasicMaterial).opacity = 0.5 + expansionFactor * 0.3;
      } 
      // Fase 2: Colapso quântico - momento da redução objetiva
      // Representa o limiar de Penrose (quando E=ħ/t é atingido)
      else if (normalizedTime < 0.7) {
        const collapseFactor = Math.pow((normalizedTime - 0.3) / 0.4, 1.5);
        // Colapso dos anéis - representando OR
        outerRing.current.scale.setScalar(1.5 - collapseFactor * 1.3);
        middleRing.current.scale.setScalar(1.2 - collapseFactor * 1.0);
        innerRing.current.scale.setScalar(0.9 - collapseFactor * 0.5);
        
        // Pulsos de intensidade durante o colapso - representam a transição de energia
        // Na teoria Orch OR, este é o momento em que a energia gravitacional
        // causa o colapso da função de onda
        const pulseIntensity = 0.8 + Math.sin(collapseFactor * Math.PI * 6) * 0.2;
        (outerRing.current.material as THREE.MeshBasicMaterial).opacity = 0.8 * pulseIntensity;
        (middleRing.current.material as THREE.MeshBasicMaterial).opacity = 0.8 * pulseIntensity;
        (innerRing.current.material as THREE.MeshBasicMaterial).opacity = 0.8 * pulseIntensity;
      }
      // Fase 3: Dissipação - após OR
      // Representa o retorno ao estado clássico pós-colapso
      else {
        const dissipationFactor = (normalizedTime - 0.7) / 0.3;
        
        // Redução da escala e opacidade - representa o estado pós-colapso
        outerRing.current.scale.setScalar(0.2 * (1 - dissipationFactor));
        middleRing.current.scale.setScalar(0.2 * (1 - dissipationFactor));
        innerRing.current.scale.setScalar(0.4 * (1 - dissipationFactor));
        
        // Opacidade diminui
        (outerRing.current.material as THREE.MeshBasicMaterial).opacity = 0.8 * (1 - dissipationFactor);
        (middleRing.current.material as THREE.MeshBasicMaterial).opacity = 0.8 * (1 - dissipationFactor);
        (innerRing.current.material as THREE.MeshBasicMaterial).opacity = 0.8 * (1 - dissipationFactor);
      }
      
      // Rotação continua - representa a fase quântica
      outerRing.current.rotation.z = t * 1.5;
      middleRing.current.rotation.z = -t * 1.0;
      innerRing.current.rotation.z = t * 0.5;
    }
    
    // Animação das partículas quânticas
    if (quantum_particle.current) {
      quantum_particle.current.children.forEach((child, i) => {
        const mesh = child as THREE.Mesh;
        const particle = quantumParticles[i % quantumParticles.length];
        
        // Fase 1: Movimento quântico - partículas em superposição
        if (normalizedTime < 0.3) {
          const expansionFactor = normalizedTime / 0.3;
          const quantum_phase = particle.phase + t * particle.frequency;
          const quantum_radius = particle.originalRadius * (1 + expansionFactor * 0.5);
          
          // Movimento em superposição quântica - representa tubulinas em superposição
          mesh.position.set(
            quantum_radius * Math.cos(quantum_phase) * Math.sin(t + i),
            quantum_radius * Math.sin(quantum_phase) * Math.cos(t + i),
            0.1 * Math.sin(quantum_phase * 2)
          );
          
          // Partículas ficam mais brilhantes - aumento da energia quântica
          mesh.scale.setScalar(0.5 + 0.5 * expansionFactor);
        }
        // Fase 2: Colapso quântico - partículas convergem
        else if (normalizedTime < 0.7) {
          const collapseFactor = (normalizedTime - 0.3) / 0.4;
          const collapseRadius = particle.originalRadius * (1 - collapseFactor);
          
          // Movimento de convergência (colapso) - redução objetiva
          mesh.position.set(
            collapseRadius * Math.cos(particle.phase),
            collapseRadius * Math.sin(particle.phase),
            0.05 * Math.cos(t * 5 + i) * (1 - collapseFactor)
          );
          
          // Partículas brilham intensamente durante o colapso - energia liberada
          const pulseIntensity = 1.0 + Math.sin(collapseFactor * Math.PI * 8) * 0.5;
          mesh.scale.setScalar(1.0 * pulseIntensity);
        }
        // Fase 3: Pós-colapso - partículas se condensam
        else {
          const dissipationFactor = (normalizedTime - 0.7) / 0.3;
          
          // Partículas convergem para o centro - estado clássico pós-OR
          mesh.position.set(
            0.1 * Math.cos(particle.phase) * (1 - dissipationFactor),
            0.1 * Math.sin(particle.phase) * (1 - dissipationFactor),
            0
          );
          
          // Partículas diminuem - energia dissipada
          mesh.scale.setScalar(1.0 * (1 - dissipationFactor));
        }
      });
    }
    
    // Animação da curvatura espaço-temporal
    if (spacetime_curvature.current) {
      spacetime_curvature.current.children.forEach((child, i) => {
        const mesh = child as THREE.Mesh;
        const point = spacetimePoints[i % spacetimePoints.length];
        
        // Curvatura do espaço-tempo durante OR
        // Segundo Penrose, a gravitação é responsável pelo colapso
        const curvature_intensity = normalizedTime < 0.7 ? 
          Math.sin(normalizedTime * Math.PI * 2) * 0.3 : 
          0.1 * (1 - (normalizedTime - 0.7) / 0.3);
        
        mesh.position.set(
          point.x * (1 + curvature_intensity),
          point.y * (1 + curvature_intensity),
          curvature_intensity * Math.sin(t * 2 + i * 0.1)
        );
        
        // Escala representa a intensidade da curvatura
        mesh.scale.setScalar(0.3 + curvature_intensity * 0.7);
      });
    }
  }, [active, collapseActive, quantumParticles, spacetimePoints]);
  
  // Animação da Redução Objetiva (OR)
  // Simula o processo de colapso descrito por Penrose-Hameroff
  useFrame(animateObjectiveReduction);
  
  if (!active) return null;
  
  // Cor base depende se é um processo não-computável (teoria de Penrose)
  // Processos não-computáveis são fundamentais na teoria de Penrose para explicar
  // aspectos da consciência que transcendem computação algoritmica
  const baseColor = isNonComputable ? "#FF00FF" : color;
  const hue = new THREE.Color(baseColor).getHSL({h:0, s:0, l:0}).h;
  
  // Cores para diferentes elementos do colapso
  const outerColor = new THREE.Color().setHSL(hue, 0.8, 0.7);
  const middleColor = new THREE.Color().setHSL((hue + 0.05) % 1, 0.9, 0.6);
  const innerColor = new THREE.Color().setHSL((hue + 0.1) % 1, 1.0, 0.5);
  
  return (
    <group position={new THREE.Vector3(...position)}>
      {/* Anéis de colapso quântico - representam a frente de onda durante OR */}
      <mesh ref={outerRing}>
        <torusGeometry args={[0.4, 0.02, 16, 100]} />
        {/* Opacidade dos anéis modulada por evento OR */}
{/* Opacidade mínima muito baixa em repouso (0.05), crescendo suavemente com collapseActive */}
<meshBasicMaterial color={outerColor} transparent opacity={collapseActive ? 1 : 0.05} />
      </mesh>
      <mesh ref={middleRing}>
        <torusGeometry args={[0.3, 0.02, 16, 100]} />
        {/* Opacidade dos anéis modulada por evento OR */}
{/* Opacidade mínima muito baixa em repouso (0.05), crescendo suavemente com collapseActive */}
<meshBasicMaterial color={middleColor} transparent opacity={collapseActive ? 1 : 0.05} />
      </mesh>
      <mesh ref={innerRing}>
        <torusGeometry args={[0.2, 0.02, 16, 100]} />
        {/* Opacidade dos anéis modulada por evento OR */}
{/* Opacidade mínima muito baixa em repouso (0.05), crescendo suavemente com collapseActive */}
<meshBasicMaterial color={innerColor} transparent opacity={collapseActive ? 1 : 0.05} />
      </mesh>
      
      {/* Partículas quânticas que se condensam durante o colapso */}
      <group ref={quantum_particle}>
        {quantumParticles.map((particle, i) => (
          <mesh key={i} position={particle.position}>
            <sphereGeometry args={[0.03, 8, 8]} />
            <meshBasicMaterial color={new THREE.Color().setHSL(hue, 0.8, 0.8)} />
          </mesh>
        ))}
      </group>
      
      {/* Curvatura espaço-temporal - representa o mecanismo gravitacional de Penrose */}
      <group ref={spacetime_curvature}>
        <line>
          <bufferGeometry>
            <bufferAttribute 
              attach="attributes-position" 
              args={[new Float32Array(spacetimePoints.length * 3), 3]}
            />
          </bufferGeometry>
          <lineBasicMaterial color={outerColor} transparent opacity={0.5} />
        </line>
      </group>
    </group>
  );
});

export default WaveCollapse;// SPDX-License-Identifier: MIT OR Apache-2.0
// Copyright (c) 2025 Guilherme Ferrari Brescia

import { NON_PASSIVE_EVENT_OPTIONS, PASSIVE_EVENT_OPTIONS, PASSIVE_EVENT_TYPES } from './PerformanceConstants';

/**
 * Event Optimizer for Orch-OS Neural Processing
 * Single Responsibility: Event listener optimization and passive event handling
 */
export class EventOptimizer {
  private static originalAddEventListener = EventTarget.prototype.addEventListener;
  private static originalRemoveEventListener = EventTarget.prototype.removeEventListener;
  private static isOptimized = false;

  /**
   * Configures global passive event listeners optimization
   */
  static configurePassiveEvents(): () => void {
    if (EventOptimizer.isOptimized) {
      return () => {}; // Already optimized
    }

    EventOptimizer.overrideEventListeners();
    EventOptimizer.addGlobalStyles();
    EventOptimizer.isOptimized = true;

    return EventOptimizer.cleanup;
  }

  /**
   * Overrides addEventListener to force passive events where appropriate
   */
  private static overrideEventListeners(): void {
    EventTarget.prototype.addEventListener = function(
      type: string,
      listener: EventListenerOrEventListenerObject,
      options?: boolean | AddEventListenerOptions
    ) {
      // Convert boolean options to object format
      let optionsObj: AddEventListenerOptions = {};
      
      if (typeof options === 'boolean') {
        optionsObj = { capture: options };
      } else if (options) {
        optionsObj = { ...options };
      }

      // Force passive: true for problematic events if not explicitly set to false
      if (PASSIVE_EVENT_TYPES.has(type) && optionsObj.passive !== false) {
        optionsObj.passive = true;
      }

      return EventOptimizer.originalAddEventListener.call(this, type, listener, optionsObj);
    };
  }

  /**
   * Adds global CSS styles for touch optimization
   */
  private static addGlobalStyles(): void {
    if (typeof document === 'undefined') return;

    const style = document.createElement('style');
    style.id = 'quantum-performance-styles';
    style.textContent = `
      * {
        touch-action: manipulation;
      }
      
      .quantum-three-canvas {
        touch-action: none;
      }
    `;
    document.head.appendChild(style);
  }

  /**
   * Cleans up optimizations and restores original behavior
   */
  private static cleanup(): void {
    if (!EventOptimizer.isOptimized) return;

    EventTarget.prototype.addEventListener = EventOptimizer.originalAddEventListener;
    EventTarget.prototype.removeEventListener = EventOptimizer.originalRemoveEventListener;

    const style = document.getElementById('quantum-performance-styles');
    if (style) {
      document.head.removeChild(style);
    }

    EventOptimizer.isOptimized = false;
  }

  /**
   * Optimizes specific canvas elements for OrbitControls
   */
  static optimizeCanvasElements(): void {
    if (typeof document === 'undefined') return;

    const canvasElements = document.querySelectorAll('.quantum-three-canvas');
    
    canvasElements.forEach(canvas => {
      if (canvas instanceof HTMLElement) {
        // Set specific touch-action for better OrbitControls performance
        canvas.style.touchAction = 'none';
        
        // Add passive event listeners for common gestures
        const passiveOptions = { passive: true };
        
        ['wheel', 'touchstart', 'touchmove'].forEach(eventType => {
          canvas.addEventListener(eventType, () => {}, passiveOptions);
        });
      }
    });
  }

  /**
   * Gets the appropriate event options for a given event type
   */
  static getEventOptions(eventType: string, forcePassive = false): AddEventListenerOptions {
    if (forcePassive || PASSIVE_EVENT_TYPES.has(eventType)) {
      return PASSIVE_EVENT_OPTIONS;
    }
    
    return NON_PASSIVE_EVENT_OPTIONS;
  }

  /**
   * Fixes passive event listener issues with OrbitControls
   */
  static fixOrbitControlsEvents(): void {
    if (typeof document === 'undefined') return;

    // Wait for React Three Fiber to mount
    setTimeout(() => {
      const canvasElements = document.querySelectorAll('canvas');
      
      canvasElements.forEach(canvas => {
        if (canvas.parentElement?.classList.contains('quantum-three-canvas') || 
            canvas.closest('.quantum-three-canvas')) {
          
          // Override addEventListener for wheel events
          const originalAddEventListener = canvas.addEventListener.bind(canvas);
          
          canvas.addEventListener = function(type: string, listener: any, options?: any) {
            // Force non-passive for wheel events to allow preventDefault
            if (type === 'wheel' || type === 'mousewheel') {
              const nonPassiveOptions = typeof options === 'object' 
                ? { ...options, passive: false }
                : { passive: false };
              return originalAddEventListener(type, listener, nonPassiveOptions);
            }
            return originalAddEventListener(type, listener, options);
          };
          
          // Also set touch-action for better mobile support
          canvas.style.touchAction = 'none';
        }
      });
    }, 100); // Small delay to ensure canvas is mounted
  }
}

// Export convenience functions
export const configurePassiveEvents = EventOptimizer.configurePassiveEvents;
export const optimizeCanvasElements = EventOptimizer.optimizeCanvasElements;
export const getEventOptions = EventOptimizer.getEventOptions; // SPDX-License-Identifier: MIT OR Apache-2.0
// Copyright (c) 2025 Guilherme Ferrari Brescia

import type { IMemoryOptimizer } from '../interfaces/PerformanceInterfaces';
import { NEURAL_FRAME_CONSTRAINTS } from './PerformanceConstants';

/**
 * Memory Optimizer for Orch-OS Neural Processing
 * Single Responsibility: Memory management and optimization
 */
export class MemoryOptimizer implements IMemoryOptimizer {
  private lastOptimizationTime = 0;
  private readonly optimizationCooldown = 5000; // 5 seconds

  /**
   * Optimizes memory usage by triggering garbage collection and cache clearing
   */
  optimize(): void {
    const now = performance.now();
    
    // Prevent too frequent optimizations
    if (now - this.lastOptimizationTime < this.optimizationCooldown) {
      return;
    }

    this.lastOptimizationTime = now;

    // Force garbage collection hint (if available)
    this.triggerGarbageCollection();

    // Clear Three.js cache if available
    this.clearThreeJSCache();
  }

  /**
   * Checks if the system is under memory pressure
   */
  checkPressure(): boolean {
    const usage = this.getMemoryUsage();
    return usage !== null && usage > NEURAL_FRAME_CONSTRAINTS.MEMORY_PRESSURE_THRESHOLD;
  }

  /**
   * Gets current memory usage in bytes
   */
  getMemoryUsage(): number | null {
    if (typeof window !== 'undefined' && 'performance' in window && 'memory' in window.performance) {
      const memory = (window.performance as any).memory;
      return memory?.usedJSHeapSize || null;
    }
    return null;
  }

  /**
   * Triggers garbage collection if available
   */
  private triggerGarbageCollection(): void {
    if (typeof window !== 'undefined' && 'gc' in window) {
      try {
        (window as any).gc();
      } catch {
        // Silent fail - gc not available
      }
    }
  }

  /**
   * Clears Three.js cache if available
   */
  private clearThreeJSCache(): void {
    if (typeof window !== 'undefined') {
      try {
        // Try to access THREE from global scope
        const THREE = (window as any).THREE;
        if (THREE?.Cache) {
          THREE.Cache.clear();
        }
      } catch {
        // Silent fail - Three.js not available
      }
    }
  }
}

// Singleton instance for global use
export const memoryOptimizer = new MemoryOptimizer(); // SPDX-License-Identifier: MIT OR Apache-2.0
// Copyright (c) 2025 Guilherme Ferrari Brescia

import type { FrameConstraints } from '../interfaces/PerformanceInterfaces';

/**
 * Performance Constants for Orch-OS Neural Processing
 * Single Responsibility: Central configuration for performance parameters
 */

export const NEURAL_FRAME_CONSTRAINTS: FrameConstraints = {
  TARGET_FPS: 60,
  MIN_FRAME_TIME: 16.67, // 1000ms / 60fps
  MAX_FRAME_TIME: 33.33, // 1000ms / 30fps (fallback)
  PERFORMANCE_THRESHOLD: 0.8,
  FRAME_BUDGET_MS: 8, // Aggressive optimization
  HEAVY_TASK_BUDGET_MS: 3, // Very strict budget during heavy tasks
  THROTTLE_HEAVY_TASKS: true,
  PAUSE_DURING_HEAVY_TASKS: false, // Disable pausing to prevent infinite loops
  HEAVY_TASK_DETECTION_THRESHOLD: 50, // More reasonable threshold (50ms instead of 100ms)
  MEMORY_PRESSURE_THRESHOLD: 50 * 1024 * 1024 // 50MB memory threshold
} as const;

export const PASSIVE_EVENT_OPTIONS = {
  passive: true,
  capture: false
} as const;

export const NON_PASSIVE_EVENT_OPTIONS = {
  passive: false,
  capture: false
} as const;

export const PASSIVE_EVENT_TYPES = new Set([
  'wheel',
  'mousewheel',
  'touchstart',
  'touchmove',
  'touchend',
  'scroll'
]);

export const THROTTLE_DELAYS = {
  WHEEL_EVENT: 16, // ~60fps throttling
  MESSAGE_HANDLER: 100,
  DEBOUNCE_DEFAULT: 100,
  DEBOUNCE_MAX_WAIT: 500
} as const; // SPDX-License-Identifier: MIT OR Apache-2.0
// Copyright (c) 2025 Guilherme Ferrari Brescia

import { useCallback, useEffect, useRef } from 'react';
import { MemoryOptimizer } from '../core/MemoryOptimizer';
import { NEURAL_FRAME_CONSTRAINTS } from '../core/PerformanceConstants';
import type { IAnimationFrameCallback, IAnimationFrameOptimizer } from '../interfaces/PerformanceInterfaces';
import { PerformanceMonitor } from '../monitors/PerformanceMonitor';

/**
 * Optimized Animation Frame Hook for Orch-OS Neural Processing
 * Single Responsibility: Optimized requestAnimationFrame handling with performance monitoring
 * 
 * Performance Optimizations:
 * - Defer expensive operations using requestIdleCallback
 * - Implement frame budgeting to prevent heavy frames
 * - Use time-slicing for long-running tasks
 * - Reduce logging frequency to prevent performance overhead
 */
export function useOptimizedAnimationFrame(
  callback: IAnimationFrameCallback,
  enabled: boolean = true
): IAnimationFrameOptimizer {
  const requestRef = useRef<number | null>(null);
  const previousTimeRef = useRef<number | null>(null);
  const frameTimeRef = useRef<number>(0);
  const lastHeavyTaskRef = useRef<number>(0);
  const heavyTaskActiveRef = useRef<boolean>(false);
  const memoryPressureRef = useRef<boolean>(false);
  const performanceMonitorRef = useRef(new PerformanceMonitor());
  const memoryOptimizerRef = useRef(new MemoryOptimizer());
  const lastLogRef = useRef<number>(0);
  const frameSkipCountRef = useRef<number>(0);
  const frameBudgetRef = useRef<number>(NEURAL_FRAME_CONSTRAINTS.FRAME_BUDGET_MS);
  const isIdleRef = useRef<boolean>(true);

  // Memory pressure detection using requestIdleCallback to defer work
  const checkMemoryPressure = useCallback(() => {
    if (typeof window !== 'undefined' && 'requestIdleCallback' in window) {
      window.requestIdleCallback(() => {
        const hasMemoryPressure = memoryOptimizerRef.current.checkPressure();
        if (hasMemoryPressure) {
          memoryPressureRef.current = true;
        }
      }, { timeout: 1000 });
    } else {
      // Fallback for environments without requestIdleCallback
      setTimeout(() => {
        const hasMemoryPressure = memoryOptimizerRef.current.checkPressure();
        if (hasMemoryPressure) {
          memoryPressureRef.current = true;
        }
      }, 0);
    }
  }, []);

  const optimizedCallback = useCallback((timestamp: number) => {
    const frameStartTime = performance.now();
    
    if (previousTimeRef.current !== null) {
      const deltaTime = timestamp - previousTimeRef.current;
      frameTimeRef.current = deltaTime;
      
      // Time-sliced performance monitoring - only update every few frames
      if (timestamp % 3 === 0) {
        const metrics = performanceMonitorRef.current.update(timestamp);
        
        // Check for memory pressure much less frequently (every 180 frames ≈ 3 seconds at 60fps)
        if (metrics.totalFrames % 180 === 0) {
          checkMemoryPressure();
        }
        
        // Adaptive frame budget based on recent performance
        const targetFrameTime = NEURAL_FRAME_CONSTRAINTS.MIN_FRAME_TIME;
        const avgFrameTime = metrics.averageFrameTime;
        
        // More conservative budget adjustments
        if (avgFrameTime > targetFrameTime * 2) {
          frameBudgetRef.current = Math.max(4, frameBudgetRef.current * 0.9); // Slower reduction
        } else if (avgFrameTime < targetFrameTime * 0.6) {
          frameBudgetRef.current = Math.min(NEURAL_FRAME_CONSTRAINTS.FRAME_BUDGET_MS, frameBudgetRef.current * 1.05); // Slower increase
        }
      }
      
      // More relaxed heavy task detection - focus on truly problematic frames
      const timeSinceLastHeavyTask = timestamp - lastHeavyTaskRef.current;
      
      // Only consider frames > 50ms as truly "heavy" (was 25ms)
      if (deltaTime > 50) {
        lastHeavyTaskRef.current = timestamp;
        heavyTaskActiveRef.current = true;
        
        // Much more throttled logging - only log once every 10 seconds
        const timeSinceLastLog = timestamp - lastLogRef.current;
        if (process.env.NODE_ENV !== 'production' && timeSinceLastLog > 10000) {
          // Use requestIdleCallback for logging to not block the main thread
          if (typeof window !== 'undefined' && 'requestIdleCallback' in window) {
            window.requestIdleCallback(() => {
              console.warn(
                `[QuantumPerformance] Heavy frame detected (${deltaTime.toFixed(2)}ms)`
              );
            });
          }
          lastLogRef.current = timestamp;
        }
      }
      
      // Reset heavy task flag after longer period for stability
      if (timeSinceLastHeavyTask > 2000) {
        heavyTaskActiveRef.current = false;
        memoryPressureRef.current = false;
        frameSkipCountRef.current = 0;
        isIdleRef.current = true;
      }
      
      // More conservative frame skipping strategy
      const shouldSkipFrame = (
        heavyTaskActiveRef.current && 
        NEURAL_FRAME_CONSTRAINTS.THROTTLE_HEAVY_TASKS &&
        frameSkipCountRef.current < 2 && // Reduced max consecutive skips
        deltaTime > 80 // Only skip on really bad frames
      );
      
      if (shouldSkipFrame) {
        frameSkipCountRef.current++;
        // Skip callback execution but continue animation loop
      } else {
        frameSkipCountRef.current = 0;
        
        try {
          // Execute callback with time budgeting
          const callbackStartTime = performance.now();
          
          // Use time-slicing: if we're running behind, reduce callback complexity
          const isRunningBehind = deltaTime > 32; // 2 frames behind at 60fps
          if (isRunningBehind) {
            // Potentially pass a flag to callback to reduce complexity
            callback(deltaTime, timestamp, { simplified: true });
          } else {
            callback(deltaTime, timestamp);
          }
          
          const callbackDuration = performance.now() - callbackStartTime;
          
          // More relaxed budget checking - only warn on significant violations
          if (callbackDuration > frameBudgetRef.current * 1.5) {
            heavyTaskActiveRef.current = true;
            lastHeavyTaskRef.current = timestamp;
            isIdleRef.current = false;
            
            // Throttled budget violation logging
            const timeSinceLastLog = timestamp - lastLogRef.current;
            if (process.env.NODE_ENV !== 'production' && timeSinceLastLog > 5000) {
              if (typeof window !== 'undefined' && 'requestIdleCallback' in window) {
                window.requestIdleCallback(() => {
                  console.warn(
                    `[QuantumPerformance] Frame budget exceeded: ${callbackDuration.toFixed(2)}ms (budget: ${frameBudgetRef.current.toFixed(2)}ms)`
                  );
                });
              }
              lastLogRef.current = timestamp;
            }
          } else {
            isIdleRef.current = true;
          }
        } catch (error) {
          // Defer error logging to not impact frame performance
          if (typeof window !== 'undefined' && 'requestIdleCallback' in window) {
            window.requestIdleCallback(() => {
              console.warn('[QuantumPerformance] Frame callback error:', error);
            });
          }
        }
      }
    }
    
    previousTimeRef.current = timestamp;
    
    // Always schedule next frame if enabled
    if (enabled) {
      requestRef.current = requestAnimationFrame(optimizedCallback);
    }
  }, [callback, enabled, checkMemoryPressure]);

  useEffect(() => {
    if (enabled) {
      requestRef.current = requestAnimationFrame(optimizedCallback);
    }
    
    return () => {
      if (requestRef.current) {
        cancelAnimationFrame(requestRef.current);
        requestRef.current = null;
      }
    };
  }, [enabled, optimizedCallback]);

  // Return performance metrics for monitoring
  return {
    currentFrameTime: frameTimeRef.current,
    performanceMetrics: performanceMonitorRef.current.getMetrics(),
    isHeavyTaskActive: heavyTaskActiveRef.current,
    hasMemoryPressure: memoryPressureRef.current
  };
} // SPDX-License-Identifier: MIT OR Apache-2.0
// Copyright (c) 2025 Guilherme Ferrari Brescia

import { useEffect } from 'react';

/**
 * 🧠 Symbolic OrbitControls Fix Hook for Orch-OS
 * 
 * Neural Fix Cortex - resolves passive event listener conflicts with @react-three/drei
 * OrbitControls by ensuring wheel events can call preventDefault() properly.
 */
export function useOrbitControlsFix(): void {
  useEffect(() => {
    if (typeof document === 'undefined') return;

    // Global fix for OrbitControls passive event listener issues
    const fixPassiveEvents = () => {
      // Override addEventListener globally to fix wheel events
      const originalAddEventListener = EventTarget.prototype.addEventListener;
      
      EventTarget.prototype.addEventListener = function(
        type: string,
        listener: EventListenerOrEventListenerObject,
        options?: boolean | AddEventListenerOptions
      ) {
        // For wheel events, force non-passive to allow preventDefault
        if (type === 'wheel' || type === 'mousewheel') {
          let opts: AddEventListenerOptions;
          
          if (typeof options === 'boolean') {
            opts = { capture: options, passive: false };
          } else if (options) {
            opts = { ...options, passive: false };
          } else {
            opts = { passive: false };
          }
          
          return originalAddEventListener.call(this, type, listener, opts);
        }
        
        return originalAddEventListener.call(this, type, listener, options);
      };
    };

    // Apply the fix
    fixPassiveEvents();

    // Additional canvas-specific fixes
    const applyCanvasFixes = () => {
      const canvases = document.querySelectorAll('canvas');
      canvases.forEach(canvas => {
        // Ensure touch-action is set for better mobile support
        canvas.style.touchAction = 'none';
        
        // Add a custom wheel event listener that won't be passive
        const wheelHandler = (e: WheelEvent) => {
          // Allow default OrbitControls behavior
          // This is just to register a non-passive listener
        };
        
        canvas.addEventListener('wheel', wheelHandler, { passive: false });
      });
    };

    // Apply canvas fixes immediately and after a delay for dynamic content
    applyCanvasFixes();
    const timeoutId = setTimeout(applyCanvasFixes, 1000);

    return () => {
      clearTimeout(timeoutId);
    };
  }, []);
} // SPDX-License-Identifier: MIT OR Apache-2.0
// Copyright (c) 2025 Guilherme Ferrari Brescia

import { useFrame } from '@react-three/fiber';
import { useCallback, useRef } from 'react';

/**
 * Simple throttled frame hook for React Three Fiber
 * Single Responsibility: Throttle animation frames to prevent performance issues
 */

type FrameCallback = (state: any, delta: number) => void;

interface ThrottleOptions {
  /** Maximum frames per second for this component (default: 30) */
  maxFPS?: number;
  /** Frame budget in milliseconds (default: 8ms) */
  frameBudget?: number;
  /** Whether to skip frames during heavy load (default: true) */
  adaptiveSkipping?: boolean;
  /** Priority level: 'high' | 'medium' | 'low' (default: 'medium') */
  priority?: 'high' | 'medium' | 'low';
  /** Enable debug logging every N frames */
  debugInterval?: number;
}

/**
 * Simple throttled useFrame replacement
 */
export function useThrottledFrame(
  callback: FrameCallback,
  options: ThrottleOptions = {}
): void {
  const lastRunRef = useRef<number>(0);
  const frameCountRef = useRef<number>(0);
  const performanceRef = useRef<{ sum: number; count: number }>({ sum: 0, count: 0 });

  const maxFPS = options.maxFPS ?? 30;
  const frameBudget = options.frameBudget ?? 8;
  const adaptiveSkipping = options.adaptiveSkipping ?? true;
  const priority = options.priority ?? 'medium';
  const debugInterval = options.debugInterval;

  const targetInterval = 1000 / maxFPS;

  const throttledCallback = useCallback((state: any, delta: number) => {
    const now = performance.now();
    const timeSinceLastRun = now - lastRunRef.current;

    // Always increment total frame count for debugging
    frameCountRef.current++;

    // Check if enough time has passed
    if (timeSinceLastRun < targetInterval) {
      return;
    }

    // Simple adaptive skipping based on recent performance
    if (adaptiveSkipping) {
      const avgFrameTime = performanceRef.current.count > 0 
        ? performanceRef.current.sum / performanceRef.current.count 
        : 0;

      // Skip low priority tasks if average frame time is high
      if (priority === 'low' && avgFrameTime > 20) {
        return;
      }

      // Skip medium priority tasks if performance is really bad
      if (priority === 'medium' && avgFrameTime > 33) {
        return;
      }
    }

    try {
      const startTime = performance.now();
      callback(state, delta);
      const duration = performance.now() - startTime;
      
      // Track performance
      performanceRef.current.sum += duration;
      performanceRef.current.count++;
      
      // Reset performance tracking periodically
      if (performanceRef.current.count >= 60) {
        performanceRef.current.sum *= 0.1;
        performanceRef.current.count = 1;
      }

      // Debug logging if enabled
      if (debugInterval && frameCountRef.current % debugInterval === 0 && process.env.NODE_ENV !== 'production') {
        const avgFrameTime = performanceRef.current.count > 0 
          ? (performanceRef.current.sum / performanceRef.current.count).toFixed(2)
          : '0.00';
        console.log(
          `[ThrottledFrame] Frame ${frameCountRef.current}: avg ${avgFrameTime}ms, current ${duration.toFixed(2)}ms, priority: ${priority}`
        );
      }

      // Warn if budget exceeded
      if (duration > frameBudget && process.env.NODE_ENV !== 'production') {
        console.warn(
          `[ThrottledFrame] Frame ${frameCountRef.current} exceeded budget: ${duration.toFixed(2)}ms (budget: ${frameBudget}ms)`
        );
      }

    } catch (error) {
      console.warn(`[ThrottledFrame] Frame ${frameCountRef.current} callback error:`, error);
    }

    lastRunRef.current = now;
  }, [callback, targetInterval, frameBudget, adaptiveSkipping, priority, debugInterval]);

  useFrame(throttledCallback);
}

/**
 * Performance-optimized useFrame replacement for quantum visualization
 * Use this instead of direct useFrame for quantum visualization components
 */
export function useOptimizedQuantumFrame(
  callback: FrameCallback,
  priority: 'high' | 'medium' | 'low' = 'medium'
): void {
  useThrottledFrame(callback, {
    maxFPS: priority === 'high' ? 60 : priority === 'medium' ? 30 : 15,
    frameBudget: priority === 'high' ? 12 : priority === 'medium' ? 8 : 4,
    adaptiveSkipping: true,
    priority,
    // Enable debug logging every 300 frames in development for quantum components
    debugInterval: process.env.NODE_ENV !== 'production' ? 300 : undefined
  });
} // SPDX-License-Identifier: MIT OR Apache-2.0
// Copyright (c) 2025 Guilherme Ferrari Brescia

/**
 * Performance Interfaces for Orch-OS Neural Processing
 * Implements Interface Segregation Principle - specific interfaces for specific needs
 */

// === Core Performance Types ===
export interface PerformanceMetrics {
  readonly fps: number;
  readonly averageFrameTime: number;
  readonly slowFrames: number;
  readonly totalFrames: number;
  readonly consecutiveSlowFrames: number;
  readonly heavyTaskPeriods: number;
  readonly isPerformanceGood: boolean;
  readonly slowFrameRatio: number;
}

export interface FrameConstraints {
  readonly TARGET_FPS: number;
  readonly MIN_FRAME_TIME: number;
  readonly MAX_FRAME_TIME: number;
  readonly PERFORMANCE_THRESHOLD: number;
  readonly FRAME_BUDGET_MS: number;
  readonly HEAVY_TASK_BUDGET_MS: number;
  readonly THROTTLE_HEAVY_TASKS: boolean;
  readonly PAUSE_DURING_HEAVY_TASKS: boolean;
  readonly HEAVY_TASK_DETECTION_THRESHOLD: number;
  readonly MEMORY_PRESSURE_THRESHOLD: number;
}

// === Animation Frame Interfaces ===
export interface IAnimationFrameCallback {
  (deltaTime: number, timestamp: number): void;
}

export interface IAnimationFrameOptimizer {
  readonly currentFrameTime: number;
  readonly performanceMetrics: PerformanceMetrics;
  readonly isHeavyTaskActive: boolean;
  readonly hasMemoryPressure: boolean;
}

// === Event Optimization Interfaces ===
export interface IEventOptions {
  readonly passive?: boolean;
  readonly capture?: boolean;
  readonly once?: boolean;
}

export interface IPassiveEventHandler<T extends Event = Event> {
  (event: T): void;
}

// === Memory Management Interfaces ===
export interface IMemoryOptimizer {
  optimize(): void;
  checkPressure(): boolean;
  getMemoryUsage(): number | null;
}

// === Task Management Interfaces ===
export interface IHeavyTask {
  readonly id: string;
  readonly fn: () => Promise<void>;
  readonly priority: number;
}

export interface IHeavyTaskManager {
  addTask(fn: () => Promise<void>, id: string, priority?: number): Promise<void>;
  isProcessing(): boolean;
  getQueueSize(): number;
}

// === Performance Monitoring Interfaces ===
export interface IPerformanceMonitor {
  update(timestamp: number): PerformanceMetrics;
  reset(): void;
  getMetrics(): PerformanceMetrics;
}

// === Message Handler Interfaces ===
export interface IMessageHandler<T = any> {
  (data: T): void;
}

export interface IOptimizedMessageHandler<T = any> {
  (data: T): void;
}

// === Configuration Interfaces ===
export interface IPerformanceConfig {
  readonly frameConstraints: FrameConstraints;
  readonly enableMemoryOptimization: boolean;
  readonly enableEventOptimization: boolean;
  readonly enableTaskManagement: boolean;
  readonly debugMode: boolean;
}

export interface IOptimizationLevel {
  readonly quality: number; // 0.25 to 1.0
  readonly adaptiveQuality: boolean;
} // SPDX-License-Identifier: MIT OR Apache-2.0
// Copyright (c) 2025 Guilherme Ferrari Brescia

import type { IHeavyTask, IHeavyTaskManager } from '../interfaces/PerformanceInterfaces';

/**
 * Heavy Task Manager for Orch-OS Neural Processing
 * Single Responsibility: Management of heavy computational tasks
 */
export class HeavyTaskManager implements IHeavyTaskManager {
  private tasks: IHeavyTask[] = [];
  private processing = false;

  /**
   * Adds a heavy task to the processing queue
   */
  async addTask(fn: () => Promise<void>, id: string, priority: number = 0): Promise<void> {
    const task: IHeavyTask = { fn, id, priority };
    
    this.tasks.push(task);
    this.tasks.sort((a, b) => b.priority - a.priority);
    
    if (!this.processing) {
      await this.processTasks();
    }
  }

  /**
   * Checks if the manager is currently processing tasks
   */
  isProcessing(): boolean {
    return this.processing;
  }

  /**
   * Gets the current queue size
   */
  getQueueSize(): number {
    return this.tasks.length;
  }

  /**
   * Processes all tasks in the queue
   */
  private async processTasks(): Promise<void> {
    this.processing = true;
    
    while (this.tasks.length > 0) {
      const task = this.tasks.shift();
      if (!task) break;

      try {
        await task.fn();
      } catch (error) {
        console.warn(`[HeavyTaskManager] Task ${task.id} failed:`, error);
      }
      
      // Yield control between tasks
      await this.yieldControl();
    }
    
    this.processing = false;
  }

  /**
   * Yields control to allow other operations to proceed
   */
  private async yieldControl(): Promise<void> {
    return new Promise(resolve => setTimeout(resolve, 1));
  }

  /**
   * Clears all pending tasks
   */
  clearTasks(): void {
    this.tasks = [];
  }
}

// Singleton instance for global use
export const heavyTaskManager = new HeavyTaskManager(); // SPDX-License-Identifier: MIT OR Apache-2.0
// Copyright (c) 2025 Guilherme Ferrari Brescia

import { NEURAL_FRAME_CONSTRAINTS } from '../core/PerformanceConstants';
import type { IPerformanceMonitor, PerformanceMetrics } from '../interfaces/PerformanceInterfaces';

/**
 * Performance Monitor for Orch-OS Neural Processing
 * Single Responsibility: Performance metrics collection and analysis
 */
export class PerformanceMonitor implements IPerformanceMonitor {
  private frameCount = 0;
  private lastTime = 0;
  private fps = 0;
  private averageFrameTime = NEURAL_FRAME_CONSTRAINTS.MIN_FRAME_TIME;
  private slowFrameCount = 0;
  private consecutiveSlowFrames = 0;
  private heavyTaskPeriods = 0;
  private readonly maxSlowFrames: number;

  constructor(maxSlowFrames = 30) {
    this.maxSlowFrames = maxSlowFrames;
  }

  /**
   * Updates performance metrics with new frame data
   */
  update(timestamp: number): PerformanceMetrics {
    this.frameCount++;
    
    if (this.lastTime === 0) {
      this.lastTime = timestamp;
      return this.getMetrics();
    }

    const deltaTime = timestamp - this.lastTime;
    this.lastTime = timestamp;

    // Update average frame time with exponential smoothing
    this.averageFrameTime = this.averageFrameTime * 0.9 + deltaTime * 0.1;

    // Count slow frames
    if (deltaTime > NEURAL_FRAME_CONSTRAINTS.MAX_FRAME_TIME) {
      this.slowFrameCount++;
      this.consecutiveSlowFrames++;
    } else {
      this.consecutiveSlowFrames = 0;
    }

    // Detect heavy task periods
    if (deltaTime > NEURAL_FRAME_CONSTRAINTS.HEAVY_TASK_DETECTION_THRESHOLD) {
      this.heavyTaskPeriods++;
    }

    // Calculate FPS every 60 frames
    if (this.frameCount % 60 === 0) {
      this.fps = Math.round(1000 / this.averageFrameTime);
      
      // Reset slow frame count periodically
      if (this.frameCount % 300 === 0) {
        this.slowFrameCount = Math.max(0, this.slowFrameCount - 10);
      }
    }

    return this.getMetrics();
  }

  /**
   * Resets all performance metrics
   */
  reset(): void {
    this.frameCount = 0;
    this.lastTime = 0;
    this.fps = 0;
    this.averageFrameTime = NEURAL_FRAME_CONSTRAINTS.MIN_FRAME_TIME;
    this.slowFrameCount = 0;
    this.consecutiveSlowFrames = 0;
    this.heavyTaskPeriods = 0;
  }

  /**
   * Gets current performance metrics
   */
  getMetrics(): PerformanceMetrics {
    const slowFrameRatio = this.frameCount > 0 ? this.slowFrameCount / this.frameCount : 0;
    const isPerformanceGood = 
      this.fps >= NEURAL_FRAME_CONSTRAINTS.TARGET_FPS * NEURAL_FRAME_CONSTRAINTS.PERFORMANCE_THRESHOLD &&
      slowFrameRatio < 0.1;

    return {
      fps: this.fps,
      averageFrameTime: this.averageFrameTime,
      slowFrames: this.slowFrameCount,
      totalFrames: this.frameCount,
      consecutiveSlowFrames: this.consecutiveSlowFrames,
      heavyTaskPeriods: this.heavyTaskPeriods,
      isPerformanceGood,
      slowFrameRatio
    };
  }
}

// Factory function for creating monitor instances
export const createPerformanceMonitor = (maxSlowFrames?: number): PerformanceMonitor => {
  return new PerformanceMonitor(maxSlowFrames);
}; // SPDX-License-Identifier: MIT OR Apache-2.0
// Copyright (c) 2025 Guilherme Ferrari Brescia

/**
 * Orch-OS Performance Optimization Suite
 * SOLID Architecture Implementation for Neural Processing Performance
 * 
 * This module follows SOLID principles:
 * - Single Responsibility: Each class/module has one clear purpose
 * - Open/Closed: Extensible through interfaces without modification
 * - Liskov Substitution: Interface implementations are interchangeable
 * - Interface Segregation: Specific interfaces for specific needs
 * - Dependency Inversion: Depend on abstractions, not concretions
 */

// === Core Interfaces (Interface Segregation Principle) ===
export type {
  FrameConstraints,
  IAnimationFrameCallback,
  IAnimationFrameOptimizer,
  IEventOptions, IHeavyTask,
  IHeavyTaskManager, IMemoryOptimizer, IMessageHandler, IOptimizationLevel, IOptimizedMessageHandler, IPassiveEventHandler, IPerformanceConfig, IPerformanceMonitor, PerformanceMetrics
} from './interfaces/PerformanceInterfaces';

// === Core Constants ===
export {
  NEURAL_FRAME_CONSTRAINTS, NON_PASSIVE_EVENT_OPTIONS, PASSIVE_EVENT_OPTIONS, PASSIVE_EVENT_TYPES,
  THROTTLE_DELAYS
} from './core/PerformanceConstants';

// === Core Optimizers (Single Responsibility Principle) ===
export { configurePassiveEvents, EventOptimizer, getEventOptions, optimizeCanvasElements } from './core/EventOptimizer';
export { MemoryOptimizer, memoryOptimizer } from './core/MemoryOptimizer';

// === Managers (Single Responsibility Principle) ===
export { HeavyTaskManager, heavyTaskManager } from './managers/HeavyTaskManager';

// === Monitors (Single Responsibility Principle) ===
export { createPerformanceMonitor, PerformanceMonitor } from './monitors/PerformanceMonitor';

// === Hooks (Open/Closed Principle - extensible) ===
export { useOptimizedAnimationFrame } from './hooks/useOptimizedAnimationFrame';
export { useOptimizedQuantumFrame, useThrottledFrame } from './hooks/useThrottledFrame';

// === Utilities (Single Responsibility Principle) ===
export {
  createDebouncedFunction, createOptimizedMessageHandler,
  createThrottledFunction
} from './utils/MessageHandlerOptimizer';

// === Local Imports for Legacy Functions ===
import { configurePassiveEvents as _configurePassiveEvents, optimizeCanvasElements as _optimizeCanvasElements } from './core/EventOptimizer';
import { memoryOptimizer as _memoryOptimizer } from './core/MemoryOptimizer';
import type { IHeavyTaskManager, IMemoryOptimizer, IPerformanceMonitor } from './interfaces/PerformanceInterfaces';
import { heavyTaskManager as _heavyTaskManager } from './managers/HeavyTaskManager';
import { createPerformanceMonitor as _createPerformanceMonitor } from './monitors/PerformanceMonitor';

// === Backwards Compatibility Exports ===
// These maintain compatibility with the old API while using the new SOLID architecture

/**
 * Legacy hook wrapper that maintains the old API
 */
export function useGlobalPassiveEventOptimization() {
  // Use the new EventOptimizer
  const cleanup = _configurePassiveEvents();
  _optimizeCanvasElements();
  
  return cleanup;
}

/**
 * Legacy hook wrapper for OrbitControls optimization
 */
export function useOptimizedOrbitControls() {
  _optimizeCanvasElements();
}

/**
 * Legacy function wrapper for Three.js memory optimization
 */
export function optimizeThreeJSMemory() {
  _memoryOptimizer.optimize();
}

/**
 * Legacy hook wrapper for heavy task management
 */
export function useHeavyTaskManager() {
  return {
    queueHeavyTask: (task: () => Promise<void>) => 
      _heavyTaskManager.addTask(task, `task-${Date.now()}`)
  };
}

/**
 * Convenience function to initialize all performance optimizations
 * Following the Dependency Inversion Principle - depends on abstractions
 */
export function initializeQuantumPerformanceOptimizations(): () => void {
  const cleanupFunctions: Array<() => void> = [];

  // Initialize event optimizations
  cleanupFunctions.push(_configurePassiveEvents());
  
  // Optimize canvas elements
  _optimizeCanvasElements();
  
  // Initialize memory optimization
  _memoryOptimizer.optimize();

  // Return cleanup function
  return () => {
    cleanupFunctions.forEach(cleanup => cleanup());
  };
}

/**
 * Factory function for creating a complete performance optimization suite
 * Follows Dependency Inversion - you can inject your own implementations
 */
export function createPerformanceOptimizationSuite(config?: {
  memoryOptimizer?: IMemoryOptimizer;
  heavyTaskManager?: IHeavyTaskManager;
  performanceMonitor?: IPerformanceMonitor;
}) {
  return {
    memoryOptimizer: config?.memoryOptimizer || _memoryOptimizer,
    heavyTaskManager: config?.heavyTaskManager || _heavyTaskManager,
    performanceMonitor: config?.performanceMonitor || _createPerformanceMonitor(),
    initialize: initializeQuantumPerformanceOptimizations
  };
} // SPDX-License-Identifier: MIT OR Apache-2.0
// Copyright (c) 2025 Guilherme Ferrari Brescia

import { CognitionEvent } from '../../../context/deepgram/types/CognitionEvent';
import { QuantumFrequencyBand } from '../QuantumVisualizationContext';

// Type guards para os diferentes tipos de eventos cognitivos
function isNeuralCollapseEvent(event: CognitionEvent): event is Extract<CognitionEvent, { type: 'neural_collapse' }> {
  return event.type === 'neural_collapse';
}

function isNeuralSignalEvent(event: CognitionEvent): event is Extract<CognitionEvent, { type: 'neural_signal' }> {
  return event.type === 'neural_signal';
}

function isSymbolicRetrievalEvent(event: CognitionEvent): event is Extract<CognitionEvent, { type: 'symbolic_retrieval' }> {
  return event.type === 'symbolic_retrieval';
}

function isFusionInitiatedEvent(event: CognitionEvent): event is Extract<CognitionEvent, { type: 'fusion_initiated' }> {
  return event.type === 'fusion_initiated';
}

function isSymbolicContextSynthesizedEvent(event: CognitionEvent): event is Extract<CognitionEvent, { type: 'symbolic_context_synthesized' }> {
  return event.type === 'symbolic_context_synthesized';
}

function isEmergentPatternsEvent(event: CognitionEvent): event is Extract<CognitionEvent, { type: 'emergent_patterns' }> {
  return event.type === 'emergent_patterns';
}

/**
 * Constantes científicas da teoria Orch-OR (Penrose-Hameroff)
 * Valores refinados baseados em publicações científicas recentes
 */
export const ORCH_OR_CONSTANTS = {
  // Duração dos eventos quânticos (milissegundos)
  // Dilatados para visualização didática
  SUPERPOSITION_DURATION_MS: 600,   // Dilatação didática dos ~25ms reais
  COHERENCE_BUILDUP_MS: 250,        // Dilatação didática dos ~75ms reais
  CONSCIOUS_MOMENT_MS: 1500,        // Dilatação didática dos ~100ms reais
  
  // Níveis de coerência quântica (valores normalizados)
  MIN_COHERENCE: 0.05,              // Coerência mínima em repouso
  BASELINE_COHERENCE: 0.3,          // Coerência basal normal
  ENTANGLEMENT_THRESHOLD: 0.6,      // Limiar para emaranhamento quântico significativo
  COLLAPSE_THRESHOLD: 0.85,         // Limiar para colapso iminente
};

/**
 * Determina a banda de frequência quântica correspondente a um tipo de evento cognitivo
 * TERAHERTZ: Atividade quântica isolada (alta energia)
 * GIGAHERTZ: Atividade quântica em grupos de tubulinas
 * MEGAHERTZ: Coerência em grupos de microtúbulos
 * KILOHERTZ: Integração microtubular em escala neuronal
 * HERTZ: Oscilações macroscópicas em redes neurais (EEG)
 */
export const getFrequencyBandForEvent = (event: CognitionEvent): QuantumFrequencyBand => {
  const type = event.type;
  
  // Eventos de alto nível cognitivo - baixa frequência
  if (type === 'neural_collapse' || type === 'symbolic_context_synthesized') {
    return QuantumFrequencyBand.HERTZ; // EEG theta-gamma
  }
  
  // Eventos de processamento intermediário - frequências médias
  if (type === 'fusion_initiated' || type === 'symbolic_retrieval') {
    return QuantumFrequencyBand.KILOHERTZ; // Atividade neural local
  }
  
  // Eventos de nível básico/sensorial - maiores frequências
  if (type === 'neural_signal' || type === 'raw_prompt') {
    return QuantumFrequencyBand.MEGAHERTZ; // Atividade de microtúbulos
  }
  
  // Eventos extremamente rápidos/primitivos - frequências ultrarápidas
  if (type === 'emergent_patterns') {
    return QuantumFrequencyBand.GIGAHERTZ; // Vibrações quânticas
  }
  
  // Processos macroscópicos - EEG
  if (type === 'gpt_response') {
    return QuantumFrequencyBand.HERTZ;
  }
  
  // Nível fundamental para outras interações
  return QuantumFrequencyBand.TERAHERTZ; // Nível base
};

/**
 * Calcula a amplitude do efeito quântico baseado no tipo e propriedades do evento
 * Baseado na teoria Orch-OR sobre intensidade de processos quânticos
 */
export const getAmplitudeForEvent = (event: CognitionEvent): number => {
  // Para eventos com informação explícita de intensidade
  if (isNeuralSignalEvent(event)) {
    return Math.max(0.2, Math.min(1, event.intensity));
  }
  
  // Para eventos de colapso que usam carga emocional
  if (isNeuralCollapseEvent(event)) {
    return Math.max(0.5, Math.min(1, event.emotionalWeight));
  }
  
  // Symbolic_retrieval - baseado na quantidade de insights
  if (isSymbolicRetrievalEvent(event)) {
    return Math.max(0.3, Math.min(1, (event.insights.length / 10)));
  }
  
  // Variação padrão dependendo do tipo de evento
  if (isNeuralCollapseEvent(event)) return 0.9;  // Colapsos são eventos de alta amplitude
  if (isFusionInitiatedEvent(event)) return 0.7; // Fusão tem amplitude moderada-alta
  if (isSymbolicContextSynthesizedEvent(event)) return 0.8; // Síntese tem alta amplitude
  
  return 0.5 + (Math.random() * 0.2); // Outros eventos - amplitude média com variação
};

/**
 * Determina se um evento cognitivo é não-computável 
 * Baseado na teoria de Penrose sobre a não-computabilidade da consciência
 */
export const isNonComputableEvent = (event: CognitionEvent): boolean => {
  // Neural_collapse possui informação sobre determinismo
  if (isNeuralCollapseEvent(event)) {
    return 'isDeterministic' in event ? !event.isDeterministic : true; // Não-determinístico = não-computável
  }
  
  // Probabilidades de não-computabilidade baseadas na teoria
  if (isEmergentPatternsEvent(event)) {
    return Math.random() < 0.7; // Padrões emergentes frequentemente não-computáveis
  }
  
  if (isSymbolicContextSynthesizedEvent(event)) {
    return Math.random() < 0.4; // Síntese parcialmente não-computável
  }
  
  return false; // Maioria dos eventos são computáveis
};

/**
 * Faz mapeamento refinado de eventos cognitivos para regiões cerebrais
 * Baseado na teoria Orch-OR e nos modelos de consciência quântica
 */
export const getCoreForEvent = (event: CognitionEvent): string => {
  const type = event.type;
  
  if (type === 'raw_prompt' || type === 'temporary_context') {
    return 'SENSORY_CORTEX';      // Entrada sensorial inicial
  }
  if (type === 'neural_signal') {
    return 'THALAMUS';            // Processamento subcortical
  }
  if (type === 'symbolic_retrieval') {
    return 'HIPPOCAMPUS';         // Memória e recuperação
  }
  if (type === 'fusion_initiated') {
    return 'PREFRONTAL_CORTEX';   // Integração e fusão de informação
  }
  if (type === 'neural_collapse') {
    return 'GLOBAL_WORKSPACE';    // Espaço de trabalho global - consciência
  }
  if (type === 'symbolic_context_synthesized') {
    return 'CORTICAL_COLUMNS';    // Minicoluna cortical - unidade de processamento
  }
  if (type === 'gpt_response') {
    return 'LANGUAGE_CENTERS';    // Áreas de linguagem
  }
  if (type === 'emergent_patterns') {
    return 'ASSOCIATION_AREAS';   // Áreas associativas multimodais
  }
  return 'THALAMUS';            // Default: tálamo como integrador central
};

/**
 * Mapeia eventos cognitivos para propriedades quânticas segundo a teoria Orch-OR
 * Esta é a função principal para tradução de estados cognitivos para fenômenos quânticos
 */
export const mapCognitionEventToQuantumProperties = (event: CognitionEvent) => {
  return {
    core: getCoreForEvent(event),
    frequencyBand: getFrequencyBandForEvent(event),
    amplitude: getAmplitudeForEvent(event),
    nonComputable: isNonComputableEvent(event),
    // Uma função auxiliar para determinar o nível do tripleto de acordo com a teoria
    tripletLevel: getTripletLevel(event)
  };
};

/**
 * Determina o nível do tripleto de acordo com a teoria Orch-OR
 * Na teoria, informações são organizadas em "triplets of triplets"
 */
export const getTripletLevel = (event: CognitionEvent): 'primary' | 'secondary' | 'tertiary' => {
  if (isNeuralCollapseEvent(event)) return 'tertiary';
  if (isSymbolicContextSynthesizedEvent(event)) return 'secondary';
  if (isFusionInitiatedEvent(event)) return 'secondary';
  if (isSymbolicRetrievalEvent(event) && event.insights.length > 5) return 'secondary';
  return 'primary';
};
// SPDX-License-Identifier: MIT OR Apache-2.0
// Copyright (c) 2025 Guilherme Ferrari Brescia

/**
 * Performance Optimizations for Orch-OS Neural Processing
 * 
 * This file now serves as a compatibility layer that re-exports 
 * the new SOLID architecture implementation.
 * 
 * The new architecture is located in the ./performance/ directory
 * and follows SOLID principles for better maintainability and extensibility.
 */

// Re-export everything from the new SOLID architecture
export * from './performance';

// Import required functions for legacy support
import {
    configurePassiveEvents,
    createPerformanceMonitor,
    createThrottledFunction
} from './performance';

// Maintain backwards compatibility by re-exporting specific functions
// that were previously defined in this file
export {
    createOptimizedMessageHandler,
    NEURAL_FRAME_CONSTRAINTS as NEURAL_FRAME_CONSTRAINTS_LEGACY, NON_PASSIVE_EVENT_OPTIONS as nonPassiveEventOptions, optimizeThreeJSMemory, PASSIVE_EVENT_OPTIONS as passiveEventOptions, useGlobalPassiveEventOptimization, useHeavyTaskManager, useOptimizedAnimationFrame, useOptimizedOrbitControls, useOptimizedQuantumFrame, useThrottledFrame
} from './performance';

// Additional legacy exports with different names for backwards compatibility
import { PerformanceMonitor } from './performance';

export class QuantumPerformanceMonitor extends PerformanceMonitor {
  // Legacy alias - extends the new PerformanceMonitor
}

// Legacy function aliases
export const configurePassiveOrbitControls = () => {
  return configurePassiveEvents();
};

export const usePassiveEventListener = <K extends keyof HTMLElementEventMap>(
  element: HTMLElement | null,
  eventType: K,
  handler: (event: HTMLElementEventMap[K]) => void,
  options?: {
    passive?: boolean;
    capture?: boolean;
    once?: boolean;
  }
) => {
  // Simple implementation for backwards compatibility
  if (!element || typeof window === 'undefined') return;

  const eventOptions = {
    passive: options?.passive ?? true,
    capture: options?.capture ?? false,
    once: options?.once ?? false
  };

  element.addEventListener(eventType, handler as EventListener, eventOptions);

  return () => {
    element.removeEventListener(eventType, handler as EventListener, eventOptions);
  };
};

export const useOptimizedWheelHandler = (
  element: HTMLElement | null,
  onWheel: (deltaY: number, event: WheelEvent) => void,
  enabled: boolean = true
) => {
  if (!element || !enabled || typeof window === 'undefined') return;

  const throttleRef = { current: 0 };
  const THROTTLE_MS = 16; // ~60fps throttling

  const handler = (event: WheelEvent) => {
    const now = performance.now();
    if (now - throttleRef.current >= THROTTLE_MS) {
      throttleRef.current = now;
      
      const deltaY = Math.sign(event.deltaY) * Math.min(Math.abs(event.deltaY), 100);
      
      try {
        onWheel(deltaY, event);
      } catch (error) {
        console.warn('[QuantumPerformance] Wheel handler error:', error);
      }
    }
  };

  element.addEventListener('wheel', handler, { passive: true });

  return () => {
    element.removeEventListener('wheel', handler);
  };
};

// Legacy debounce function
export const usePerformanceDebounce = <T extends (...args: any[]) => any>(
  callback: T,
  delay: number = 100
): T => {
  return createThrottledFunction(callback, delay);
};

export const useQuantumPerformanceAutoOptimization = () => {
  const monitor = createPerformanceMonitor();
  
  return {
    optimizationLevel: 1.0,
    performanceMetrics: monitor
  };
}; // SPDX-License-Identifier: MIT OR Apache-2.0
// Copyright (c) 2025 Guilherme Ferrari Brescia

export { default as QuantumModel } from './QuantumModel';
export { default as QuantumVisualizationContainer, QuantumVisualizationContainer as default } from './QuantumVisualizationContainer';
// SPDX-License-Identifier: MIT OR Apache-2.0
// Copyright (c) 2025 Guilherme Ferrari Brescia

import React, { useState } from 'react';
import { useQuantumVisualization, OrchORState } from './QuantumVisualizationContext';
import './QuantumVisualization.css';

// Define the quantum phenomena with their respective colors and descriptions
export const QUANTUM_PHENOMENA = {
  SUPERPOSITION: {
    id: 'quantum-superposition',
    label: 'Quantum Superposition',
    color: '#9D6AFF',
    description: 'Multiple quantum states existing simultaneously in microtubules before collapse.'
  },
  REDUCTION: {
    id: 'objective-reduction',
    label: 'Objective Reduction',
    color: '#00B4D8',
    description: 'Orchestrated collapse of quantum states through gravity-induced reduction.'
  },
  ENTANGLEMENT: {
    id: 'quantum-entanglement',
    label: 'Quantum Entanglement',
    color: '#E63B7A',
    description: 'Non-local quantum connections between microtubules across neural networks.'
  },
  CONSCIOUS: {
    id: 'conscious-state',
    label: 'Conscious State',
    color: '#3BE669',
    description: 'Emergent consciousness arising from orchestrated quantum collapses.'
  },
  COHERENCE: {
    id: 'tubulin-coherence',
    label: 'Tubulin Coherence',
    color: '#FFD166',
    description: 'Quantum resonance maintained in microtubule structures.'
  },
  ORCHESTRATION: {
    id: 'orchestration',
    label: 'Orchestration',
    color: '#00CBD1',
    description: 'Synchronization of quantum processes across neural architectures.'
  },
  DECOHERENCE: {
    id: 'quantum-decoherence',
    label: 'Quantum Decoherence',
    color: '#FF5500', // Laranja mais vivo para melhor visibilidade
    description: 'Process by which quantum states lose coherence due to environmental interaction, a key challenge in Orch-OR.'
  },
  ISOLATION: {
    id: 'quantum-isolation',
    label: 'Quantum Isolation',
    color: '#00CCFF', // Azul mais brilhante para melhor visibilidade
    description: 'Protective mechanisms that shield microtubules from decoherence, enabling quantum effects at body temperature.'
  },
  OBSERVER: {
    id: 'observer',
    label: 'Observer',
    color: '#FFFFFF',
    description: 'Self-referential quantum measurement process in consciousness.'
  }
};

interface LegendItemProps {
  id: string;
  label: string;
  color: string;
  active?: boolean;
  selected?: boolean;
  description: string;
  onClick: (id: string, multiSelect: boolean) => void;
}

const LegendItem: React.FC<LegendItemProps> = ({ 
  id, 
  label, 
  color, 
  active = false, 
  selected = false,
  description,
  onClick 
}) => {
  const [showTooltip, setShowTooltip] = useState(false);
  
  // Handler para detectar clique com Command (Mac) ou Ctrl (Windows/Linux) pressionado
  const handleClick = (e: React.MouseEvent) => {
    // Se Command ou Ctrl está pressionado, permitir seleção múltipla
    onClick(id, e.metaKey || e.ctrlKey); // metaKey = Command no Mac, ctrlKey = Ctrl em outras plataformas
  };
  
  return (
    <div 
      className={`quantum-legend-item ${active ? 'active' : ''} ${selected ? 'selected' : ''}`} 
      onClick={handleClick}
      onMouseEnter={() => setShowTooltip(true)}
      onMouseLeave={() => setShowTooltip(false)}
      title={`${label}${selected ? ' (selected)' : ''} - ⌘/Ctrl+Click for multiple selection`}
    >
      <div 
        className={`quantum-legend-indicator quantum-color-${id}`} 
        data-color={color}
      />
      <span className="quantum-legend-label">{label}</span>
      {showTooltip && (
        <div className={`quantum-legend-tooltip tooltip-color-${id}`}>
          {description}
          {selected ? " (selected)" : ""}
          <div className="tooltip-hint">
            ⌘/Ctrl+Click for multiple selection
          </div>
        </div>
      )}
    </div>
  );
};

/**
 * Component that displays legends for quantum phenomena in the visualization
 * Shows which phenomena are active at a specific moment and allows filtering
 */
export const QuantumLegend: React.FC = () => {
  const {
    quantumSuperpositions,
    objectiveReductions,
    quantumEntanglements,
    consciousStates,
    observerState,
    activeVisualFilters,
    setActiveVisualFilter
  } = useQuantumVisualization();

  // Determine if each Orch OR quantum phenomenon is active based on events
  const isSuperpositionActive = quantumSuperpositions.length > 0;
  const isObjectiveReductionActive = objectiveReductions.length > 0;
  const isQuantumEntanglementActive = quantumEntanglements.length > 0;
  const isConsciousStateActive = consciousStates.length > 0;
  
  // Assegurar que tubulina e orquestração estejam ativas no estado de repouso
  // Mesmo sem eventos cognitivos, há um nível básico de coerência quântica
  // de acordo com a teoria Orch-OR
  const isCoherenceActive = true; // Sempre ativo para refletir o estado quântico de base
  const isOrchestrationActive = true; // Sempre ativo para refletir orquestração em nível base
  const isObserverActive = observerState === 'active' || consciousStates.length > 0;
  
  // Decoerência e isolamento são fenômenos físicos sempre presentes
  // em diferentes graus, de acordo com a teoria Orch-OR
  const isDecoherenceActive = true; // A decoerência é sempre uma ameaça presente
  const isIsolationActive = true;   // Os mecanismos de isolamento estão sempre ativos
  
  // Handle legend item click to toggle filtering, com suporte para seleção múltipla
  const handleLegendClick = (id: string, multiSelect: boolean = false) => {
    // Passa o id e o estado do Command/Ctrl para o contexto
    setActiveVisualFilter(id, multiSelect);
  };

  // Add the title at the top of the visualization
  React.useEffect(() => {
    // Check if title already exists
    const existingTitle = document.querySelector('.quantum-matrix-title');
    if (!existingTitle) {
      const container = document.querySelector('.quantum-visualization-container');
      if (container) {
        const titleElement = document.createElement('h1');
        titleElement.className = 'quantum-matrix-title';
        titleElement.textContent = 'QUANTUM CONSCIOUSNESS MATRIX';
        container.insertBefore(titleElement, container.firstChild);
      }
    }
  }, []);

  return (
    <div className="quantum-legend">
      <LegendItem 
        id={QUANTUM_PHENOMENA.SUPERPOSITION.id}
        label={QUANTUM_PHENOMENA.SUPERPOSITION.label}
        color={QUANTUM_PHENOMENA.SUPERPOSITION.color}
        description={QUANTUM_PHENOMENA.SUPERPOSITION.description}
        active={isSuperpositionActive}
        selected={activeVisualFilters.includes(QUANTUM_PHENOMENA.SUPERPOSITION.id)}
        onClick={handleLegendClick}
      />
      <LegendItem 
        id={QUANTUM_PHENOMENA.REDUCTION.id}
        label={QUANTUM_PHENOMENA.REDUCTION.label}
        color={QUANTUM_PHENOMENA.REDUCTION.color}
        description={QUANTUM_PHENOMENA.REDUCTION.description}
        active={isObjectiveReductionActive}
        selected={activeVisualFilters.includes(QUANTUM_PHENOMENA.REDUCTION.id)}
        onClick={handleLegendClick}
      />
      <LegendItem 
        id={QUANTUM_PHENOMENA.ENTANGLEMENT.id}
        label={QUANTUM_PHENOMENA.ENTANGLEMENT.label}
        color={QUANTUM_PHENOMENA.ENTANGLEMENT.color}
        description={QUANTUM_PHENOMENA.ENTANGLEMENT.description}
        active={isQuantumEntanglementActive}
        selected={activeVisualFilters.includes(QUANTUM_PHENOMENA.ENTANGLEMENT.id)}
        onClick={handleLegendClick}
      />
      <LegendItem 
        id={QUANTUM_PHENOMENA.CONSCIOUS.id}
        label={QUANTUM_PHENOMENA.CONSCIOUS.label}
        color={QUANTUM_PHENOMENA.CONSCIOUS.color}
        description={QUANTUM_PHENOMENA.CONSCIOUS.description}
        active={isConsciousStateActive} 
        selected={activeVisualFilters.includes(QUANTUM_PHENOMENA.CONSCIOUS.id)}
        onClick={handleLegendClick}
      />
      <LegendItem 
        id={QUANTUM_PHENOMENA.COHERENCE.id}
        label={QUANTUM_PHENOMENA.COHERENCE.label}
        color={QUANTUM_PHENOMENA.COHERENCE.color}
        description={QUANTUM_PHENOMENA.COHERENCE.description}
        active={isCoherenceActive}
        selected={activeVisualFilters.includes(QUANTUM_PHENOMENA.COHERENCE.id)}
        onClick={handleLegendClick}
      />
      <LegendItem 
        id={QUANTUM_PHENOMENA.ORCHESTRATION.id}
        label={QUANTUM_PHENOMENA.ORCHESTRATION.label}
        color={QUANTUM_PHENOMENA.ORCHESTRATION.color}
        description={QUANTUM_PHENOMENA.ORCHESTRATION.description}
        active={isOrchestrationActive}
        selected={activeVisualFilters.includes(QUANTUM_PHENOMENA.ORCHESTRATION.id)}
        onClick={handleLegendClick}
      />
      <LegendItem 
        id={QUANTUM_PHENOMENA.DECOHERENCE.id}
        label={QUANTUM_PHENOMENA.DECOHERENCE.label}
        color={QUANTUM_PHENOMENA.DECOHERENCE.color}
        description={QUANTUM_PHENOMENA.DECOHERENCE.description}
        active={isDecoherenceActive}
        selected={activeVisualFilters.includes(QUANTUM_PHENOMENA.DECOHERENCE.id)}
        onClick={handleLegendClick}
      />
      <LegendItem 
        id={QUANTUM_PHENOMENA.ISOLATION.id}
        label={QUANTUM_PHENOMENA.ISOLATION.label}
        color={QUANTUM_PHENOMENA.ISOLATION.color}
        description={QUANTUM_PHENOMENA.ISOLATION.description}
        active={isIsolationActive}
        selected={activeVisualFilters.includes(QUANTUM_PHENOMENA.ISOLATION.id)}
        onClick={handleLegendClick}
      />
      <LegendItem 
        id={QUANTUM_PHENOMENA.OBSERVER.id}
        label={QUANTUM_PHENOMENA.OBSERVER.label}
        color={QUANTUM_PHENOMENA.OBSERVER.color}
        description={QUANTUM_PHENOMENA.OBSERVER.description}
        active={isObserverActive} 
        selected={activeVisualFilters.includes(QUANTUM_PHENOMENA.OBSERVER.id)}
        onClick={handleLegendClick}
      />
    </div>
  );
};

export default QuantumLegend;// SPDX-License-Identifier: MIT OR Apache-2.0
// Copyright (c) 2025 Guilherme Ferrari Brescia

import { OrbitControls } from '@react-three/drei';
import { Canvas } from '@react-three/fiber';
import React, { Suspense, useEffect, useMemo, useState } from 'react';
import { QuantumField } from './components/QuantumField';
import './QuantumVisualizationCSS.css';
import { useOrbitControlsFix } from './utils/performance/hooks/useOrbitControlsFix';

// === Performance Configuration ===
const PERFORMANCE_CONFIG = {
  frameRate: 60,
  pixelRatio: typeof window !== 'undefined' ? Math.min(window.devicePixelRatio, 2) : 1,
  shadowMapSize: 1024,
  antialias: false, // Disable for performance
  powerPreference: 'high-performance' as const,
  stencil: false,
  depth: true,
  alpha: false // Disable transparency for better performance
} as const;

// === Constants ===
// Classes CSS dos elementos estáticos
const QUANTUM_ELEMENT_CLASSES = [
  'quantum-element-1',
  'quantum-element-2',
  'quantum-element-3',
  'quantum-element-4',
  'quantum-element-5',
  'quantum-element-6'
] as const;

// === CSS Fallback Component ===
const CssQuantumFallback: React.FC = React.memo(() => (
  <div className="quantum-visualization-css">
    {/* Fundo */}
    <div className="quantum-background" />

    {/* Elementos quânticos estáticos */}
    {QUANTUM_ELEMENT_CLASSES.map((cls, idx) => (
      <div key={`${cls}-${idx}`} className={cls} />
    ))}

    {/* Partículas adicionais */}
    <div className="quantum-particles-container">
      {Array.from({ length: 10 }, (_, idx) => {
        // Posição e atraso determinísticos (5 posições x 5 delays)
        const posCls = `quantum-particle-pos-${(idx % 5) + 1}`;
        const delayCls = `quantum-particle-delay-${(idx % 5) + 1}`;
        return <div key={`particle-${idx}`} className={`quantum-particle ${posCls} ${delayCls}`} />;
      })}
    </div>
  </div>
));

CssQuantumFallback.displayName = 'CssQuantumFallback';

// === Optimized OrbitControls Configuration ===
const ORBIT_CONTROLS_CONFIG = {
  enablePan: true,
  enableZoom: true,
  enableRotate: true,
  minDistance: 8,
  maxDistance: 30,
  enableDamping: true,
  dampingFactor: 0.05,
  rotateSpeed: 0.5,
  zoomSpeed: 0.8,
  panSpeed: 0.8,
  // Performance optimizations
  maxPolarAngle: Math.PI,
  minPolarAngle: 0,
  autoRotate: false,
  autoRotateSpeed: 2.0,
  // Fix passive event listener issues
  mouseButtons: {
    LEFT: 0,  // Rotate
    MIDDLE: 1, // Dolly
    RIGHT: 2   // Pan
  },
  touches: {
    ONE: 0,   // Rotate
    TWO: 2    // Dolly & Pan
  }
} as const;

// === Three.js Scene Components ===
const QuantumThreeScene: React.FC = React.memo(() => (
  <>
    <ambientLight intensity={1} />
    <OrbitControls {...ORBIT_CONTROLS_CONFIG} />
    <QuantumField />
  </>
));

QuantumThreeScene.displayName = 'QuantumThreeScene';

/**
 * Performance-optimized error boundary for WebGL context loss
 * Implements symbolic graceful degradation for neural processing stability
 */
class WebGLErrorBoundary extends React.Component<
  { children: React.ReactNode; fallback: React.ComponentType },
  { hasError: boolean }
> {
  constructor(props: { children: React.ReactNode; fallback: React.ComponentType }) {
    super(props);
    this.state = { hasError: false };
  }

  static getDerivedStateFromError(): { hasError: boolean } {
    return { hasError: true };
  }

  componentDidCatch(error: Error, errorInfo: React.ErrorInfo) {
    console.warn('[QuantumModel] WebGL context error, falling back to CSS:', error, errorInfo);
  }

  render() {
    if (this.state.hasError) {
      const FallbackComponent = this.props.fallback;
      return <FallbackComponent />;
    }

    return this.props.children;
  }
}

// === Main Component ===
export const QuantumModel: React.FC = React.memo(() => {
  const [webglAvailable, setWebglAvailable] = useState<boolean>(true);

  // Memoized WebGL detection for performance
  const webglSupport = useMemo(() => {
    try {
      const canvas = document.createElement('canvas');
      const gl =
        canvas.getContext('webgl2', { powerPreference: PERFORMANCE_CONFIG.powerPreference }) ||
        canvas.getContext('webgl', { powerPreference: PERFORMANCE_CONFIG.powerPreference }) ||
        canvas.getContext('experimental-webgl', { powerPreference: PERFORMANCE_CONFIG.powerPreference });
      
      if (gl && 'clearColor' in gl && 'clear' in gl && 'COLOR_BUFFER_BIT' in gl) {
        // Test basic rendering capability
        (gl as WebGLRenderingContext).clearColor(0, 0, 0, 1);
        (gl as WebGLRenderingContext).clear((gl as WebGLRenderingContext).COLOR_BUFFER_BIT);
        return true;
      }
      return false;
    } catch {
      return false;
    }
  }, []);

  useEffect(() => {
    setWebglAvailable(webglSupport);
  }, [webglSupport]);

  // Fix passive event listener issues with OrbitControls
  useOrbitControlsFix();

  // Performance-optimized Canvas configuration
  const canvasConfig = useMemo(() => ({
    className: "quantum-three-canvas",
    shadows: true,
    camera: { position: [0, 0, 15] as [number, number, number], fov: 40 },
    dpr: PERFORMANCE_CONFIG.pixelRatio,
    performance: { min: 0.8 }, // Maintain 80% frame rate minimum
    gl: {
      powerPreference: PERFORMANCE_CONFIG.powerPreference,
      antialias: PERFORMANCE_CONFIG.antialias,
      stencil: PERFORMANCE_CONFIG.stencil,
      depth: PERFORMANCE_CONFIG.depth,
      alpha: PERFORMANCE_CONFIG.alpha,
      preserveDrawingBuffer: false,
      premultipliedAlpha: false,
      failIfMajorPerformanceCaveat: false
    },
    onCreated: ({ gl, size }: { gl: any; size: { width: number; height: number } }) => {
      try {
        // Optimize WebGL context for performance
        if (gl.shadowMap) {
          gl.shadowMap.enabled = true;
          gl.shadowMap.type = 2; // PCFShadowMap for performance
        }
        
        // Use renderer setSize if available
        if (gl.setSize && typeof gl.setSize === 'function') {
          gl.setSize(size.width, size.height);
        }
        
        if (gl.setClearColor && typeof gl.setClearColor === 'function') {
          gl.setClearColor(0x000000);
        }
        
        // Enable performance optimizations
        if (gl.setPixelRatio && typeof gl.setPixelRatio === 'function') {
          gl.setPixelRatio(PERFORMANCE_CONFIG.pixelRatio);
        }
        
        if (gl.outputEncoding !== undefined) {
          gl.outputEncoding = 3001; // sRGBEncoding
        }
        
        // Fix passive event listener issues with OrbitControls
        if (gl.domElement) {
          // Set touch-action to prevent default browser behavior
          gl.domElement.style.touchAction = 'none';
          
          // Override wheel event handler to be non-passive
          const originalAddEventListener = gl.domElement.addEventListener;
          gl.domElement.addEventListener = function(type: string, listener: any, options?: any) {
            // For wheel events used by OrbitControls, ensure they're non-passive
            if (type === 'wheel' || type === 'mousewheel') {
              const opts = typeof options === 'object' 
                ? { ...options, passive: false }
                : { passive: false };
              return originalAddEventListener.call(this, type, listener, opts);
            }
            return originalAddEventListener.call(this, type, listener, options);
          };
        }
        
      } catch (error) {
        console.warn('[QuantumModel] WebGL configuration warning:', error);
      }
    }
  }), []);

  if (webglAvailable) {
    return (
      <WebGLErrorBoundary fallback={CssQuantumFallback}>
        <Canvas {...canvasConfig}>
          <Suspense fallback={null}>
            <QuantumThreeScene />
          </Suspense>
        </Canvas>
      </WebGLErrorBoundary>
    );
  }

  console.log('[QuantumModel] WebGL não disponível, usando fallback CSS com otimizações neurais');
  return <CssQuantumFallback />;
});

QuantumModel.displayName = 'QuantumModel';

export default QuantumModel;/* SPDX-License-Identifier: MIT OR Apache-2.0 */
/* Copyright (c) 2025 Guilherme Ferrari Brescia */

.quantum-visualization-container {
  position: relative;
  border-radius: 0;
  overflow: visible;
  width: 100%;
  height: 100%;
  background: transparent !important;
  z-index: 2;
}

.quantum-visualization-homogeneous {
  background: transparent !important;
  border-radius: 0 !important;
}

.quantum-visualization-container.fixed-height {
  height: 280px;
}

.quantum-visualization-container.fixed-width {
  width: 100%;
}

/* Classes for custom sizes */
.quantum-visualization-container[data-width],
.quantum-visualization-container[data-height] {
  width: var(--custom-width, 100%);
  height: var(--custom-height, 280px);
}

.quantum-model-container {
  width: 100%;
  height: 100%;
  min-height: 280px;
}

/* Quantum Matrix Title */
/* Título principal da Matrix - Estilo sci-fi otimizado para performance */
.quantum-matrix-title {
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  text-align: center;
  font-family: 'Share Tech Mono', 'Orbitron', monospace;
  font-weight: 400;
  font-size: 14px;
  letter-spacing: 2px; /* Reduzido para melhor performance de renderização */
  color: #00f5ff; /* Cor sólida em vez de rgba para melhor renderização */
  z-index: 30;
  pointer-events: none;
  text-transform: uppercase;
  margin: 0;
  
  /* Container otimizado */
  padding: 12px 25px 12px 35px;
  background-color: rgba(8, 20, 30, 0.35); /* background-color em vez de background */
  -webkit-backdrop-filter: blur(5px);
  backdrop-filter: blur(5px);
  width: 100%;
  
  /* Efeitos simplificados - apenas uma sombra */
  border: none;
  box-shadow: 0 0 10px rgba(0, 245, 255, 0.2);
  
  /* Apenas um gradiente para o scanner - otimização */
  background-image: linear-gradient(90deg, 
    transparent 0%, 
    rgba(0, 245, 255, 0.05) 20%, 
    rgba(0, 245, 255, 0.1) 50%, 
    rgba(0, 245, 255, 0.05) 80%, 
    transparent 100%);
  background-size: 200% 100%;
  
  /* Sombra de texto única - reduz custo de renderização */
  text-shadow: 0 0 8px rgba(0, 245, 255, 0.8);
  
  /* Animação única - usa transform para aceleração por hardware */
  animation: quantumHoloScan 8s infinite linear;
  
  /* Will-change - informa o browser para otimizar a animação */
  will-change: background-position, color;
    
  /* Decorador holográfico */
  display: flex;
  align-items: center;
  justify-content: center;
}

/* Círculo decorativo esquerdo otimizado */
.quantum-matrix-title::before {
  content: '';
  margin-right: 12px;
  width: 12px;
  height: 12px;
  display: inline-block;
  border-radius: 50%;
  background-color: #00f5ff; /* Cor sólida */
  box-shadow: 0 0 6px #00f5ff; /* Sombra única e simplificada */
  animation: quantumBeatPulse 3s infinite alternate ease-in-out;
  will-change: transform, opacity; /* Prepara o browser para estas mudanças */
}

/* Removido o pseudo-elemento ::after para economizar recursos de renderização */

/* Animação otimizada de scanner para o título - usando apenas background-position */
@keyframes quantumHoloScan {
  0% {
    background-position: -100% 0;
  }
  100% {
    background-position: 200% 0;
  }
}

/* Animação otimizada para o indicador cíclico - usando transform para GPU acceleration */
@keyframes quantumBeatPulse {
  0% {
    transform: scale(0.85);
    opacity: 0.7;
  }
  100% {
    transform: scale(1.15);
    opacity: 1;
  }
}

/* Removidas as animações não utilizadas: quantumHoloPulse e quantumCodeScan */

/* Styles for quantum legend - Reposicionada seguindo boas práticas UI/UX */
.quantum-legend {
  position: absolute;
  bottom: 20px; /* Reposicionada para o canto inferior direito para melhor acessibilidade */
  right: 20px;
  display: flex;
  flex-direction: column;
  gap: 4px;
  background-color: rgba(0, 0, 0, 0.85); /* Mais opaco para melhor legibilidade */
  border-radius: 12px;
  padding: 12px;
  -webkit-backdrop-filter: blur(10px);
  backdrop-filter: blur(10px);
  z-index: 5;
  max-width: 220px; /* Ligeiramente mais largo para melhor leitura */
  font-size: 12px; /* Tamanho ligeiramente maior para melhor legibilidade */
  box-shadow: 0 4px 16px rgba(0, 0, 0, 0.2); /* Sombra mais definida */
  border: 1px solid rgba(255, 255, 255, 0.15);
  transition: opacity 0.3s ease, transform 0.3s ease;
  opacity: 0.9; /* Levemente mais visível por padrão */
}

.quantum-legend:hover {
  opacity: 1; /* Fully opaque on hover */
  transform: translateY(-2px); /* Subtle lift on hover */
}

.quantum-legend-item {
  display: flex;
  align-items: center;
  color: rgba(255, 255, 255, 0.8);
  transition: all 0.3s ease;
  opacity: 0.7;
  padding: 6px 8px; /* Espaçamento para melhor clickabilidade */
  border-radius: 6px; /* Leve arredondamento para cada item */
  position: relative;
  cursor: pointer;
}

.quantum-legend-item:hover {
  background-color: rgba(255, 255, 255, 0.1);
  transform: translateX(2px);
}

.quantum-legend-item.active {
  color: rgba(255, 255, 255, 1);
  opacity: 1;
}

/* Item da legenda com estado selecionado - estilo melhorado para seleção múltipla */
.quantum-legend-item.selected {
  background-color: rgba(255, 255, 255, 0.15);
  box-shadow: 
    inset 0 0 0 1px rgba(255, 255, 255, 0.3),
    0 0 10px rgba(255, 255, 255, 0.2);
  transform: translateX(4px);
  transition: all 0.2s ease-out;
}

/* Hover effect with Command/Ctrl+Click hint */
.quantum-legend-item:hover:not(.selected):after {
  position: absolute;
  bottom: -20px;
  right: 10px;
  font-size: 9px;
  color: rgba(255, 255, 255, 0.6);
  opacity: 0;
  transform: translateY(5px);
  pointer-events: none;
  transition: all 0.2s ease-out;
  animation: fadeInHelp 1s forwards 0.5s;
}

@keyframes fadeInHelp {
  to { opacity: 0.8; transform: translateY(0); }
}

.quantum-legend-indicator {
  width: 10px;
  height: 10px;
  border-radius: 50%;
  margin-right: 8px;
  transition: all 0.3s ease;
  box-shadow: 0 0 0 rgba(255, 255, 255, 0);
}

.quantum-legend-item.active .quantum-legend-indicator {
  box-shadow: 0 0 8px currentColor;
}

.quantum-legend-item.selected .quantum-legend-indicator {
  transform: scale(1.2);
  box-shadow: 0 0 12px currentColor;
}

/* Tooltip for legend items - positioned above items */
.quantum-legend-tooltip {
  position: absolute;
  bottom: 100%;
  left: 50%;
  transform: translateX(-50%);
  width: 220px;
  padding: 10px 14px;
  border-radius: 8px;
  margin-bottom: 12px;
  font-size: 12px;
  line-height: 1.5;
  pointer-events: none;
  z-index: 20;
  opacity: 0;
  animation: fadeInTop 0.2s forwards;
  border: 1.5px solid;
  background-color: rgba(0, 0, 0, 0.85);
  -webkit-backdrop-filter: blur(12px);
  backdrop-filter: blur(12px);
  color: #FFFFFF;
  font-weight: 500;
  letter-spacing: 0.3px;
  box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5), 0 0 0 1px rgba(255, 255, 255, 0.1);
  text-shadow: 0 1px 2px rgba(0, 0, 0, 0.5);
}

@keyframes fadeInTop {
  from { opacity: 0; transform: translateX(-50%) translateY(10px); }
  to { opacity: 1; transform: translateX(-50%) translateY(0); }
}

/* Style for Command/Ctrl+Click hint inside tooltip */
.tooltip-hint {
  margin-top: 8px;
  padding-top: 6px;
  border-top: 1px solid rgba(255, 255, 255, 0.2);
  font-size: 10px;
  color: rgba(255, 255, 255, 0.7);
  font-style: italic;
  display: flex;
  align-items: center;
  gap: 5px;
}

/* Ícone de atalho */
.tooltip-hint:before {
  content: '\2318'; /* Símbolo do comando/tecla */
  font-size: 12px;
  color: rgba(0, 245, 255, 0.9);
}

/* Tooltip colors for each phenomenon */
.tooltip-color-quantum-superposition {
  background-color: rgba(157, 106, 255, 0.25); /* Opacidade aumentada */
  border-color: #9D6AFF;
  box-shadow: 0 0 15px rgba(157, 106, 255, 0.3); /* Glow sutil para destaque */
}

.tooltip-color-objective-reduction {
  background-color: rgba(0, 180, 216, 0.25);
  border-color: #00B4D8;
  box-shadow: 0 0 15px rgba(0, 180, 216, 0.3);
}

.tooltip-color-quantum-entanglement {
  background-color: rgba(230, 59, 122, 0.25);
  border-color: #E63B7A;
  box-shadow: 0 0 15px rgba(230, 59, 122, 0.3);
}

.tooltip-color-conscious-state {
  background-color: rgba(59, 230, 105, 0.25);
  border-color: #3BE669;
  box-shadow: 0 0 15px rgba(59, 230, 105, 0.3);
}

.tooltip-color-tubulin-coherence {
  background-color: rgba(255, 209, 102, 0.25);
  border-color: #FFD166;
  box-shadow: 0 0 15px rgba(255, 209, 102, 0.3);
}

.tooltip-color-orchestration {
  background-color: rgba(0, 203, 209, 0.25);
  border-color: #00CBD1;
  box-shadow: 0 0 15px rgba(0, 203, 209, 0.3);
}

.tooltip-color-observer {
  background-color: rgba(255, 255, 255, 0.25);
  border-color: #FFFFFF;
  box-shadow: 0 0 15px rgba(255, 255, 255, 0.3);
}

.tooltip-color-quantum-decoherence {
  background-color: rgba(255, 85, 0, 0.25);
  border-color: #FF5500;
  box-shadow: 0 0 15px rgba(255, 85, 0, 0.3);
}

.tooltip-color-quantum-isolation {
  background-color: rgba(0, 204, 255, 0.25);
  border-color: #00CCFF;
  box-shadow: 0 0 15px rgba(0, 204, 255, 0.3);
}

@keyframes fadeIn {
  from { opacity: 0; transform: translate(10px, -50%); }
  to { opacity: 1; transform: translate(0, -50%); }
}

@keyframes fadeInLeft {
  from { opacity: 0; transform: translate(-10px, -50%); }
  to { opacity: 1; transform: translate(0, -50%); }
}

/* Specific colors for each quantum phenomenon - scientifically based on the frequencies and phenomena they represent */
/* Superposition: Violeta (frequência alta - terahertz) - baseado no espectro eletromagnético */
.quantum-color-quantum-superposition {
  background-color: #9D6AFF;
}

/* Objective Reduction: Azul esverdeado (colapso de função de onda) - baseado nas distribuições de probabilidade */
.quantum-color-objective-reduction {
  background-color: #00B4D8;
}

/* Quantum Entanglement: Magenta (fenômeno não-local) - baseado no espectro de ressonância magnética */
.quantum-color-quantum-entanglement {
  background-color: #E63B7A;
}

/* Conscious State: Verde (emergente) - baseado nos sinais EEG de consciência */
.quantum-color-conscious-state {
  background-color: #3BE669;
}

/* Tubulin Coherence: Ouro/Amarelo (oscilações de Fröhlich) - baseado na frequência ressonante 4-8 MHz */
.quantum-color-tubulin-coherence {
  background-color: #FFD166;
}

/* Orchestration: Turquesa (coordenação de múltiplos processos) - baseado na modulação de polarização */
.quantum-color-orchestration {
  background-color: #00CBD1;
}

/* Observer: Branco (luz completa - todos comprimentos de onda) - baseado na física do observador quântico */
.quantum-color-observer {
  background-color: #FFFFFF;
}

/* Decoherence: Laranja (perda de coerência quântica) - baseado na termodinâmica de sistemas abertos */
.quantum-color-quantum-decoherence {
  background-color: #FF5500;
}

/* Isolation: Azul ciano (mecanismos protetores) - baseado nos campos de exclusão de água estruturada */
.quantum-color-quantum-isolation {
  background-color: #00CCFF;
}

/* Legend toggle button */
.quantum-legend-toggle {
  position: absolute;
  bottom: 20px; /* Alinhado com a parte inferior da legenda */
  right: 246px; /* Posicionado à esquerda da legenda */
  width: 36px;
  height: 36px;
  border-radius: 50%;
  background: rgba(0, 0, 0, 0.85);
  border: 1px solid rgba(255, 255, 255, 0.2);
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 5;
  cursor: pointer;
  opacity: 0.9;
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
  transition: all 0.2s ease;
  -webkit-backdrop-filter: blur(10px);
  backdrop-filter: blur(10px);
}

.quantum-legend-toggle:hover {
  transform: scale(1.1);
  background-color: rgba(20, 20, 40, 0.9);
  border-color: rgba(255, 255, 255, 0.3);
}

.quantum-legend-toggle svg {
  width: 18px;
  height: 18px;
  color: rgba(255, 255, 255, 0.9);
  vertical-align: middle;
}

.material-symbols-outlined {
  font-size: 18px !important;
  line-height: 1;
  font-variation-settings: 'FILL' 1, 'wght' 400, 'GRAD' 0, 'opsz' 24;
  font-family: 'Material Symbols Outlined';
  -webkit-font-feature-settings: 'liga';
  font-feature-settings: 'liga';
  -webkit-font-smoothing: antialiased;
  text-rendering: optimizeLegibility;
}

/* Material icons style - legacy support */
.material-symbols-outlined {
  font-size: 16px;
}// SPDX-License-Identifier: MIT OR Apache-2.0
// Copyright (c) 2025 Guilherme Ferrari Brescia

import React, { useState, useEffect, useRef } from 'react';
import './QuantumVisualization.css';
import { QuantumVisualizationProvider, useQuantumVisualization, QuantumFrequencyBand, QuantumCore } from './QuantumVisualizationContext';
import { CognitionEvent } from '../../context/deepgram/types/CognitionEvent';
import { QuantumModel } from './index';
import { QuantumLegend } from './QuantumLegend';
// Import científico refinado da tradução cognitiva para fenômenos quânticos
import { mapCognitionEventToQuantumProperties } from './utils/CognitionMapper';

interface QuantumVisualizationContainerProps {
  cognitionEvents: CognitionEvent[] | null;
  width?: string;
  height?: string;
  showLegend?: boolean;
  lowPerformanceMode?: boolean; // Modo de baixa performance para dispositivos menos potentes
}

/**
 * Container principal para visualização quântica de eventos cognitivos segundo a teoria Orch-OR
 * 
 * Este componente implementa a interface visual para a teoria Penrose-Hameroff de
 * Redução Objetiva Orquestrada (Orch-OR), modelando a transformação de sinais neurais 
 * em fenômenos quânticos como superposição, emaranhamento e colapso (OR).
 * 
 * Simbolicamente, representa o conector entre processos neurais simbólicos e fenômenos quânticos,
 * servindo como interface cortical entre cognição e estruturas quânticas de Planck.
 */
export const QuantumVisualizationContainer: React.FC<QuantumVisualizationContainerProps> = ({
  cognitionEvents,
  width = '100%',
  height = '280px',
  showLegend = true,
  lowPerformanceMode = false
}) => {
  return (
    <QuantumVisualizationProvider>
      <QuantumVisualizationContent 
        cognitionEvents={cognitionEvents} 
        width={width} 
        height={height}
        showLegend={showLegend}
        lowPerformanceMode={lowPerformanceMode}
      />
    </QuantumVisualizationProvider>
  );
};

// Inner component to use hooks with context
const QuantumVisualizationContent: React.FC<QuantumVisualizationContainerProps> = ({
  cognitionEvents,
  width,
  height,
  showLegend,
  lowPerformanceMode = false
}) => {
  // Get quantum context functions from the Orch OR model - apenas os realmente utilizados
  const {
    // Estados quânticos realmente utilizados na renderização ou processamento
    quantumSuperpositions,
    quantumEntanglements,
    objectiveReductions,
    consciousStates,
    
    // Métodos para adicionar efeitos quânticos
    addQuantumSuperposition,
    addQuantumEntanglement,
    addObjectiveReduction,
    addConsciousState,
    setActiveRegion,
    
    // Métricas de orquestração utilizadas no processamento
    tubulinCoherenceLevel,
    orchestrationIntensity,
    setPlanckScaleFeedback,
    
    // Gerenciamento de efeitos
    clearAllEffects,
    setTubulinCoherenceLevel,
    setOrchestrationIntensity
  } = useQuantumVisualization();
  
  // Referência para rastrear se já inicializamos os efeitos quânticos basais
  const initializedRef = useRef(false);
  
  // Initialize quantum state effects - baseado na teoria Orch-OR, apenas UMA VEZ
  useEffect(() => {
    // Evitar múltiplas inicializações
    if (initializedRef.current) {
      return;
    }
    
    // Apenas reseta os estados uma vez para garantir início limpo
    clearAllEffects(); // Isso agora mantém um estado basal (Modificamos o clearAllEffects)
    
    // Marcar como inicializado para evitar chamadas repetidas
    initializedRef.current = true;
    
    // Coerencia e orquestração nos níveis iniciais adequados
    setTubulinCoherenceLevel(0.3); // Coerência inicial moderada 
    setOrchestrationIntensity(0.5); // Orquestração inicial moderada
    
    // Active region inicial - tálamo como integrador central
    setActiveRegion('THALAMUS');
  }, [clearAllEffects, setTubulinCoherenceLevel, setOrchestrationIntensity, setActiveRegion]);
  
  // State to control whether the legend is visible
  const [legendVisible, setLegendVisible] = useState(showLegend);
  
  // Ref para o container DOM
  const containerRef = React.useRef<HTMLDivElement>(null);
  
  // Event processing - rastreia eventos processados por seus timestamps
  const processedEventTimestampsRef = React.useRef<Set<string>>(new Set());
  
  // Ref para controle de processamento
  const processingEventRef = React.useRef<boolean>(false);
  
  // Utilidade para identificar eventos de forma única por timestamp e tipo
  const getEventKey = (event: CognitionEvent): string => {
    return `${event.type}-${event.timestamp}`;
  };
  
  // REMOVIDO: O timer automático de reset estava causando problemas, fazendo tudo desaparecer
  
  /**
   * Processa um evento cognitivo e o traduz para fenômenos quânticos segundo a teoria Orch-OR
   * Esta função implementa a tradução científica entre cognição e fenômenos quânticos
   */
  const handleCognitionEvent = React.useCallback((event: CognitionEvent) => {
    // Usa o CognitionMapper para traduzir o evento cognitivo para propriedades quânticas
    const quantumProperties = mapCognitionEventToQuantumProperties(event);
    
    // Ajusta a coerência e intensidade de orquestração baseado no evento
    if (event.type === 'neural_collapse') {
      // Eventos de colapso reduzem temporariamente a coerência e aumentam orquestração
      const newCoherence = Math.max(0.1, tubulinCoherenceLevel * 0.7);
      setTubulinCoherenceLevel(newCoherence);
      
      const newIntensity = Math.min(1, orchestrationIntensity * 1.3);
      setOrchestrationIntensity(newIntensity);
      
      // No momento do colapso, adiciona um efeito de reduction (OR)
      addObjectiveReduction(quantumProperties.core as QuantumCore);
      
      // Com cada colapso, atualizamos a região ativa
      setActiveRegion(quantumProperties.core as QuantumCore);
    } 
    else if (event.type === 'neural_signal') {
      // Sinais neurais aumentam a coerência quântica e superposição
      const newCoherence = Math.min(0.95, tubulinCoherenceLevel + 0.1);
      setTubulinCoherenceLevel(newCoherence);
      
      // Adiciona superposição com propriedades mapeadas do evento
      addQuantumSuperposition(
        quantumProperties.core as QuantumCore, 
        quantumProperties.frequencyBand as QuantumFrequencyBand
      );
    }
    else if (event.type === 'symbolic_retrieval') {
      // Recuperação simbólica cria entanglement entre regiões
      addQuantumEntanglement(
        'HIPPOCAMPUS' as QuantumCore, // Origem (hipocampo - memória)
        quantumProperties.frequencyBand as QuantumFrequencyBand // Banda de frequência
      );
    }
    else if (event.type === 'symbolic_context_synthesized' || event.type === 'fusion_initiated') {
      // Síntese e fusão criam estados conscientes
      addConsciousState(
        quantumProperties.core as QuantumCore,
        quantumProperties.frequencyBand as QuantumFrequencyBand
      );
    }
    // NOVO: Padrões emergentes geram entrelamento complexo entre múltiplas regiões
    else if (event.type === 'emergent_patterns') {
      // Na teoria Orch-OR, padrões emergentes representam a formação de estados cognitivos complexos
      // através de múltiplos entrelamentos quânticos
      addQuantumEntanglement(
        'PREFRONTAL' as QuantumCore,
        QuantumFrequencyBand.KILOHERTZ
      );
      
      // Segundo entrelamento para região relacionada à memória
      addQuantumEntanglement(
        'HIPPOCAMPUS' as QuantumCore,
        QuantumFrequencyBand.MEGAHERTZ
      );
      
      // Aumenta a orquestração global para refletir integração de informações
      setOrchestrationIntensity(Math.min(1, orchestrationIntensity + 0.2));
    }
    // Nota: 'raw_prompt' não gera efeitos quânticos diretos conforme teoria Orch-OR
    // Na teoria, processos quânticos só ocorrem após processamento neural inicial
    
    // MELHORADO: Eventos não-computáveis têm efeito quântico mais significativo
    if (quantumProperties.nonComputable) {
      setPlanckScaleFeedback(true); // Ativa o feedback de escala de Planck
      
      // Na teoria Orch-OR, eventos não-computáveis representam aspectos da consciência 
      // que transcendem algoritmização e emergem da física quântica
      addQuantumSuperposition(
        quantumProperties.core as QuantumCore,
        QuantumFrequencyBand.TERAHERTZ // Maior frequência - nível quântico fundamental
      );
      
      // Aumento significativo de coerência - característico de eventos não-computáveis
      setTubulinCoherenceLevel(Math.min(0.98, tubulinCoherenceLevel + 0.15));
    }
  }, [tubulinCoherenceLevel, orchestrationIntensity, setTubulinCoherenceLevel, 
      setOrchestrationIntensity, addObjectiveReduction, addQuantumSuperposition, 
      addQuantumEntanglement, addConsciousState, setActiveRegion, setPlanckScaleFeedback]);

  // Processar novo evento cognitivo quando disponível - mantém o ciclo Orch-OR
  useEffect(() => {
    // Não processa se não houver eventos ou se ainda não inicializamos
    if (!cognitionEvents || cognitionEvents.length === 0 || !initializedRef.current) {
      return;
    }
    
    // Identifica apenas os eventos novos que ainda não foram processados
    const newEvents = cognitionEvents.filter(event => {
      const eventKey = getEventKey(event);
      return !processedEventTimestampsRef.current.has(eventKey);
    });
    
    // Se não há eventos novos, não processa nada
    if (newEvents.length === 0) {
      if (process.env.NODE_ENV !== 'production') {
        console.log('[OrchORContainer] No new events to process');
      }
      return;
    }
    
    // Se já estiver processando um evento, ignora para evitar sobreposições
    if (processingEventRef.current) {
      if (process.env.NODE_ENV !== 'production') {
        console.log(`[OrchORContainer] Ignorando processamento: já existe um evento em processamento`);
      }
      return;
    }
    
    // Marca como em processamento
    processingEventRef.current = true;

    // Processa os novos eventos
    if (process.env.NODE_ENV !== 'production') {
      console.log(`[OrchORContainer] Processing ${newEvents.length} new cognition events`);
    }
    
    // Marca os eventos como processados e os processa
    newEvents.forEach(event => {
      // Adiciona o evento à lista de eventos já processados
      const eventKey = getEventKey(event);
      processedEventTimestampsRef.current.add(eventKey);
      
      // Processa o evento
      handleCognitionEvent(event);
    });
    
    // Limita o tamanho do set de eventos processados (evita memory leak)
    if (processedEventTimestampsRef.current.size > 100) {
      // Mantém apenas os 50 mais recentes se exceder 100 eventos
      const keysArray = Array.from(processedEventTimestampsRef.current);
      const toRemove = keysArray.slice(0, keysArray.length - 50);
      toRemove.forEach(key => processedEventTimestampsRef.current.delete(key));
    }
    
    // Libera para novo processamento depois que este for concluído
    setTimeout(() => {
      processingEventRef.current = false;
    }, 100);
  }, [cognitionEvents, handleCognitionEvent]);

  // Toggle legend visibility
  const toggleLegend = () => setLegendVisible(prev => !prev);

  // Create custom CSS properties if custom sizes are needed
  useEffect(() => {
    if (containerRef.current && (width !== '100%' || height !== '280px')) {
      containerRef.current.style.setProperty('--custom-width', width || '100%');
      containerRef.current.style.setProperty('--custom-height', height || '280px');
    }
  }, [width, height]);

  // Adiciona classes específicas para os estados de Orch OR
  const getOrchORClassNames = () => {
    const classNames = [];
    
    // Classes refletindo intensidades de coerência
    if (tubulinCoherenceLevel > 0.7) classNames.push('high-coherence');
    else if (tubulinCoherenceLevel > 0.3) classNames.push('medium-coherence');
    else classNames.push('low-coherence');
    
    // Classes refletindo intensidades de orquestração
    if (orchestrationIntensity > 0.7) classNames.push('intense-orchestration');
    else if (orchestrationIntensity > 0.3) classNames.push('medium-orchestration');
    else classNames.push('minimal-orchestration');
    
    // Classes baseadas no estado predominante
    if (quantumSuperpositions.length > 0) classNames.push('quantum-superposition-active');
    if (quantumEntanglements.length > 0) classNames.push('quantum-entanglement-active');
    if (objectiveReductions.length > 0) classNames.push('objective-reduction-active');
    if (consciousStates.length > 0) classNames.push('conscious-moment-active');
    
    return classNames.join(' ');
  };

  return (
    <div 
      ref={containerRef}
      className={`quantum-visualization-container 
        ${height === '280px' ? 'fixed-height' : ''} 
        ${width === '100%' ? 'fixed-width' : ''} 
        ${lowPerformanceMode ? 'low-performance-mode' : ''}
        ${getOrchORClassNames()}
      `}
      data-width={width !== '100%' ? width : undefined}
      data-height={height !== '280px' ? height : undefined}
      data-coherence={tubulinCoherenceLevel.toFixed(2)}
      data-orchestration={orchestrationIntensity.toFixed(2)}
    >
      {/* Quantum Visualization always visible */}
      <QuantumModel />

      {/* Botão de toggle para a legenda quântica */}
      <button 
        className="quantum-legend-toggle" 
        onClick={toggleLegend}
        aria-label="Toggle quantum legend"
        title="Toggle quantum legend"
      >
        {legendVisible ? (
          <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="white">
            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
          </svg>
        ) : (
          <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="white">
            <path d="M12 4C7 4 2.73 7.11 1 12c1.73 4.89 6 8 11 8s9.27-3.11 11-8c-1.73-4.89-6-8-11-8zm0 14c-3.31 0-6-2.69-6-6s2.69-6 6-6 6 2.69 6 6-2.69 6-6 6zm0-10c-2.21 0-4 1.79-4 4s1.79 4 4 4 4-1.79 4-4-1.79-4-4-4z"/>
          </svg>
        )}
      </button>
      
      {/* Legend for quantum phenomena */}
      {legendVisible && <QuantumLegend />}
    </div>
  );
};

export default QuantumVisualizationContainer;
// SPDX-License-Identifier: MIT OR Apache-2.0
// Copyright (c) 2025 Guilherme Ferrari Brescia

import React, { createContext, useContext, useState, useCallback } from 'react';
import { nanoid } from 'nanoid';

// Define the type for cognition cores - represents different regions/modules of the brain's quantum processing
export type QuantumCore = string;

// Quantum frequency bands based on research by Anirban Bandyopadhyay's team
// These correspond to the different oscillation frequency ranges observed in microtubules
export enum QuantumFrequencyBand {
  TERAHERTZ = 'terahertz',   // Fastest oscillations at quantum level
  GIGAHERTZ = 'gigahertz',   // Quantum vibrations in microtubules
  MEGAHERTZ = 'megahertz',   // Neural quantum resonance 
  KILOHERTZ = 'kilohertz',   // Medium-scale neural activity
  HERTZ = 'hertz'            // Macroscopic brain waves/EEG
}

// Quantum consciousness states from the Orch OR theory
export enum OrchORState {
  QUANTUM_SUPERPOSITION = 'quantum_superposition',  // Quantum states in superposition (pre-conscious)
  QUANTUM_COHERENCE = 'quantum_coherence',         // Coherent quantum states across microtubules
  OBJECTIVE_REDUCTION = 'objective_reduction',     // Orchestrated collapse (Orch OR)
  CONSCIOUS_MOMENT = 'conscious_moment'            // Post-collapse state (moment of consciousness)
}

// Triplet level - implements the "triplets of triplets" pattern described in Orch OR research
export type TripletLevel = 'primary' | 'secondary' | 'tertiary';

// Quantum effect - represents a single quantum phenomenon in the Orch OR model
export interface QuantumEffect {
  id: string;                        // Unique identifier
  core: QuantumCore;                 // Brain region/module affected
  orchORState: OrchORState;          // Current state in the Orch OR process
  frequencyBand: QuantumFrequencyBand; // Oscillation frequency
  tripletLevel: TripletLevel;        // Level in the triplet hierarchy
  tripletGroup?: number;             // Group identifier within the triplet pattern
  amplitude: number;                 // Quantum amplitude (0-1)
  phaseCoherence?: number;          // Quantum coherence measure (0-1)
  createdAt: number;                 // Creation timestamp
  collapseThreshold?: number;        // Threshold for objective reduction (τ ≈ ħ/EG)
  planckScale?: boolean;             // Whether effect operates at Planck scale
  nonComputable?: boolean;           // Penrose's non-computable decision (true for conscious moments)
}

// Context interface for quantum visualization based on Orch OR
export interface QuantumVisualizationContextType {
  // Quantum effects organized by Orch OR states
  quantumSuperpositions: QuantumEffect[];   // Pre-conscious quantum states
  quantumEntanglements: QuantumEffect[];    // Quantum entanglement between tubulins
  objectiveReductions: QuantumEffect[];     // Collapse events (conscious moments)
  consciousStates: QuantumEffect[];         // Post-reduction states
  
  // Methods to add quantum effects
  addQuantumSuperposition: (core: QuantumCore, frequencyBand?: QuantumFrequencyBand) => void;
  addQuantumEntanglement: (core: QuantumCore, frequencyBand?: QuantumFrequencyBand) => void;
  addObjectiveReduction: (core: QuantumCore, frequencyBand?: QuantumFrequencyBand) => void;
  addConsciousState: (core: QuantumCore, frequencyBand?: QuantumFrequencyBand) => void;
  
  // Observer and orchestration state
  observerState: 'active' | 'inactive';
  setObserverState: (state: 'active' | 'inactive') => void;
  activeRegion: QuantumCore | null;
  setActiveRegion: (region: QuantumCore | null) => void;
  tubulinCoherenceLevel: number;           // Overall coherence level (0-1)
  setTubulinCoherenceLevel: (level: number) => void; // Setter for coherence level
  orchestrationIntensity: number;         // Orchestration intensity (0-1)
  setOrchestrationIntensity: (intensity: number) => void; // Setter for orchestration intensity
  setPlanckScaleFeedback: (active: boolean) => void;
  
  // Visual filtering for legend interaction
  activeVisualFilters: string[];      // IDs of the active filters (empty array means show all)
  setActiveVisualFilter: (filterId: string, multiSelect?: boolean) => void; // Set active visual filter
  removeVisualFilter: (filterId: string) => void; // Remove a specific filter
  clearVisualFilters: () => void; // Clear all filters
  // Effect management
  clearAllEffects: (preserveBasalState?: boolean, resetLevel?: number) => void;
}

export const QuantumVisualizationContext = createContext<QuantumVisualizationContextType | null>(null);

interface QuantumVisualizationProviderProps {
  children: React.ReactNode;
}

export const QuantumVisualizationProvider: React.FC<QuantumVisualizationProviderProps> = ({ children }) => {
  // Orch OR quantum states from the theory
  const [quantumSuperpositions, setQuantumSuperpositions] = useState<QuantumEffect[]>([]);
  const [quantumEntanglements, setQuantumEntanglements] = useState<QuantumEffect[]>([]);
  const [objectiveReductions, setObjectiveReductions] = useState<QuantumEffect[]>([]);
  const [consciousStates, setConsciousStates] = useState<QuantumEffect[]>([]);
  
  // Observer and region states
  const [observerState, _setObserverState] = useState<'active' | 'inactive'>('inactive');
  const [activeRegion, _setActiveRegion] = useState<QuantumCore | null>(null);
  
  // Orchestration metrics based on Orch OR theory
  const [tubulinCoherenceLevel, setTubulinCoherenceLevel] = useState<number>(0);
  const [orchestrationIntensity, setOrchestrationIntensity] = useState<number>(0);
  const [planckScaleFeedback, setPlanckScaleFeedback] = useState<boolean>(false);
  
  // State for visual filtering (activated by legend)
  const [activeVisualFilters, setActiveVisualFilters] = useState<string[]>([]);
  
  // Handler to add/remove a filter with multiSelect support
  const setActiveVisualFilter = useCallback((filterId: string, multiSelect: boolean = false) => {
    setActiveVisualFilters(prev => {
      // Se já está selecionado
      if (prev.includes(filterId)) {
        // Remove o filtro
        return prev.filter(id => id !== filterId);
      } else {
        // Se multiSelect (Command/Ctrl pressionado), adiciona à seleção atual
        if (multiSelect) {
          return [...prev, filterId];
        }
        // Sem multiSelect, substitui toda a seleção atual
        return [filterId];
      }
    });
  }, []);
  
  // Remove um filtro específico
  const removeVisualFilter = useCallback((filterId: string) => {
    setActiveVisualFilters(prev => prev.filter(id => id !== filterId));
  }, []);
  
  // Limpa todos os filtros
  const clearVisualFilters = useCallback(() => {
    setActiveVisualFilters([]);
  }, []);
  
  // Memoized state updaters
  const setObserverState = useCallback((state: 'active' | 'inactive') => _setObserverState(state), []);
  const setActiveRegion = useCallback((region: QuantumCore | null) => _setActiveRegion(region), []);

  // No automatic clearing interval to avoid update depth exceeded errors
  // We'll manage lifetime of effects more carefully through add/clear functions

  // Implementation of "triplets of triplets" pattern from Orch OR research
  // Each quantum effect type follows the hierarchy of 3 primary triplets, each with 3 secondary triplets
  
  /**
   * Add a quantum superposition effect - represents pre-conscious quantum states in microtubules
   * Maps to: neural_signal, emergent_patterns events
   */
  const addQuantumSuperposition = React.useCallback((core: QuantumCore, frequencyBand: QuantumFrequencyBand = QuantumFrequencyBand.TERAHERTZ) => {
    try {
      if (process.env.NODE_ENV !== 'production') {
        console.log('[OrchOR] addQuantumSuperposition:', core, frequencyBand, new Date().toISOString());
      }
      
      setQuantumSuperpositions(prev => {
        // Implement "triplets of triplets" pattern
        const primaryTripletCount = prev.filter(p => 
          p.tripletLevel === 'primary' && 
          p.frequencyBand === frequencyBand
        ).length;
        
        // Limit to max 9 effects (3 primary triplets × 3 per triplet)
        if (primaryTripletCount >= 9) return prev;
        
        // Calculate which triplet group this belongs to
        const tripletGroup = Math.floor(primaryTripletCount / 3) + 1;
        
        // Create new quantum effect with Orch OR properties
        const newEffect: QuantumEffect = {
          id: nanoid(),
          core,
          orchORState: OrchORState.QUANTUM_SUPERPOSITION,
          frequencyBand,
          tripletLevel: 'primary',
          tripletGroup,
          amplitude: Math.random() * 0.5 + 0.5, // Strong amplitude for superpositions
          createdAt: Date.now(),
          planckScale: frequencyBand === QuantumFrequencyBand.TERAHERTZ, // Only terahertz operates at Planck scale
          // Calculate theoretical collapse threshold based on Penrose's equation τ ≈ ħ/EG
          collapseThreshold: Math.random() * 300 + 100 // Simulated milliseconds until collapse
        };
        
        return [...prev, newEffect];
      });
      
      // Update orchestration metrics
      updateOrchestrationMetrics();
      
    } catch (error) {
      console.error('[OrchOR] Error in addQuantumSuperposition:', error);
    }
  }, []);

  /**
   * Add a quantum entanglement effect - represents quantum coherence across microtubules
   * Maps to: fusion_initiated events
   */
  const addQuantumEntanglement = React.useCallback((core: QuantumCore, frequencyBand: QuantumFrequencyBand = QuantumFrequencyBand.GIGAHERTZ) => {
    try {
      if (process.env.NODE_ENV !== 'production') {
        console.log('[OrchOR] addQuantumEntanglement:', core, frequencyBand, new Date().toISOString());
      }
      
      setQuantumEntanglements(prev => {
        // Maintain triplet pattern
        const existingCount = prev.filter(p => 
          p.tripletLevel === 'primary' && 
          p.frequencyBand === frequencyBand
        ).length;
        
        if (existingCount >= 9) return prev;
        
        const tripletGroup = Math.floor(existingCount / 3) + 1;
        
        const newEffect: QuantumEffect = {
          id: nanoid(),
          core,
          orchORState: OrchORState.QUANTUM_COHERENCE,
          frequencyBand,
          tripletLevel: 'primary',
          tripletGroup,
          amplitude: Math.random() * 0.3 + 0.7, // High amplitude for entanglements
          phaseCoherence: Math.random() * 0.4 + 0.6, // High coherence
          createdAt: Date.now(),
          // Entanglements can span multiple frequency bands
          planckScale: frequencyBand === QuantumFrequencyBand.TERAHERTZ || frequencyBand === QuantumFrequencyBand.GIGAHERTZ
        };
        
        return [...prev, newEffect];
      });
      
      // Increase coherence level when entanglements occur
      setTubulinCoherenceLevel(prev => Math.min(1, prev + 0.1));
      updateOrchestrationMetrics();
      
    } catch (error) {
      console.error('[OrchOR] Error in addQuantumEntanglement:', error);
    }
  }, []);

  /**
   * Add an objective reduction effect - represents quantum collapse (moment of proto-consciousness)
   * Maps to: neural_collapse, symbolic_retrieval events
   */
  const addObjectiveReduction = React.useCallback((core: QuantumCore, frequencyBand: QuantumFrequencyBand = QuantumFrequencyBand.MEGAHERTZ) => {
    try {
      if (process.env.NODE_ENV !== 'production') {
        console.log('[OrchOR] addObjectiveReduction:', core, frequencyBand, new Date().toISOString());
      }
      
      setObjectiveReductions(prev => {
        // Maintain triplet pattern
        const existingCount = prev.filter(p => 
          p.tripletLevel === 'primary' && 
          p.frequencyBand === frequencyBand
        ).length;
        
        if (existingCount >= 9) return prev;
        
        const tripletGroup = Math.floor(existingCount / 3) + 1;
        
        const newEffect: QuantumEffect = {
          id: nanoid(),
          core,
          orchORState: OrchORState.OBJECTIVE_REDUCTION,
          frequencyBand,
          tripletLevel: 'primary',
          tripletGroup,
          amplitude: Math.random() * 0.6 + 0.4, // Medium-high amplitude
          createdAt: Date.now(),
          // According to Penrose-Hameroff, OR is a gravitational process at the quantum-classical boundary
          planckScale: false,
          // OR connects to non-computable processes in fundamental spacetime
          nonComputable: Math.random() > 0.3 // 70% chance of non-computable reduction
        };
        
        return [...prev, newEffect];
      });
      
      // Objective reductions temporarily decrease coherence
      setTubulinCoherenceLevel(prev => Math.max(0, prev - 0.15));
      updateOrchestrationMetrics();
      
    } catch (error) {
      console.error('[OrchOR] Error in addObjectiveReduction:', error);
    }
  }, []);

  /**
   * Add a conscious state effect - represents post-reduction conscious moment
   * Maps to: symbolic_context_synthesized, GPT_response events
   */
  const addConsciousState = React.useCallback((core: QuantumCore, frequencyBand: QuantumFrequencyBand = QuantumFrequencyBand.KILOHERTZ) => {
    try {
      if (process.env.NODE_ENV !== 'production') {
        console.log('[OrchOR] addConsciousState:', core, frequencyBand, new Date().toISOString());
      }
      
      setConsciousStates(prev => {
        // Maintain triplet pattern
        const existingCount = prev.filter(p => 
          p.tripletLevel === 'primary' && 
          p.frequencyBand === frequencyBand
        ).length;
        
        if (existingCount >= 9) return prev;
        
        const tripletGroup = Math.floor(existingCount / 3) + 1;
        
        const newEffect: QuantumEffect = {
          id: nanoid(),
          core,
          orchORState: OrchORState.CONSCIOUS_MOMENT,
          frequencyBand,
          tripletLevel: 'primary',
          tripletGroup,
          amplitude: 1.0, // Maximum amplitude for conscious states
          phaseCoherence: 1.0, // Perfect coherence achieved
          createdAt: Date.now(),
          planckScale: false,
          nonComputable: true // Per Penrose, consciousness involves non-computable processes
        };
        
        return [...prev, newEffect];
      });
      
      // Conscious states temporarily max out orchestration
      setOrchestrationIntensity(1.0);
      
      // Decay orchestration gradually
      setTimeout(() => {
        setOrchestrationIntensity(prev => Math.max(0, prev - 0.2));
      }, 500);
      
    } catch (error) {
      console.error('[OrchOR] Error in addConsciousState:', error);
    }
  }, []);
  
  // Helper to update overall orchestration metrics based on current quantum state
  const updateOrchestrationMetrics = useCallback(() => {
    // Calculate orchestration intensity based on quantum effects present
    const totalEffects = 
      quantumSuperpositions.length + 
      quantumEntanglements.length + 
      objectiveReductions.length + 
      consciousStates.length;
      
    // Weight consciousness states higher in orchestration
    const weightedSum = 
      quantumSuperpositions.length * 0.2 + 
      quantumEntanglements.length * 0.3 + 
      objectiveReductions.length * 0.5 + 
      consciousStates.length * 1.0;
      
    // Normalize to 0-1 range
    const normalizedIntensity = totalEffects > 0 ? 
      Math.min(1.0, weightedSum / (totalEffects * 0.5)) : 0;
      
    setOrchestrationIntensity(normalizedIntensity);
  }, [quantumSuperpositions, quantumEntanglements, objectiveReductions, consciousStates, setOrchestrationIntensity]);
  
  /**
   * Limpa todos os efeitos quânticos, com opção de manter ou não um estado basal
   * @param preserveBasalState Se true, mantém um estado quântico basal conforme teoria Orch-OR 
   * @param resetLevel Nível de coerência para resetar (0-1)
   */
  const clearAllEffects = useCallback((preserveBasalState = true, resetLevel = 0.3) => {
    try {
      // Primeiro limpar todos os estados existentes
      setQuantumSuperpositions([]);
      setQuantumEntanglements([]);
      setObjectiveReductions([]);
      setConsciousStates([]);
      
      // Se não está preservando estado basal, apenas zera tudo e retorna
      if (!preserveBasalState) {
        if (process.env.NODE_ENV !== 'production') {
          console.log('[OrchOR] clearAllEffects - full reset (no basal state)');
        }
        setTubulinCoherenceLevel(0.1); // Ainda mantém um mínimo de coerência (10%)
        setOrchestrationIntensity(0.1);
        setActiveRegion(null);
        return;
      }
      
      // Imediatamente adicionar o estado quântico basal (Orch-OR)
      // Duas superposições quânticas (oscilações de Fröhlich nos microtuúbulos)
      const baseSuper1: QuantumEffect = {
        id: nanoid(),
        core: 'THALAMUS', // Tálamo como base essencial da consciência quântica
        orchORState: OrchORState.QUANTUM_SUPERPOSITION,
        frequencyBand: QuantumFrequencyBand.MEGAHERTZ, // 8MHz (banda Fröhlich)
        tripletLevel: 'primary',
        tripletGroup: 1,
        amplitude: 0.2,  // Reduzido um pouco para não ser tão intenso
        phaseCoherence: 0.2,
        createdAt: Date.now()
      };
      
      const baseSuper2: QuantumEffect = {
        id: nanoid(),
        core: 'PREFRONTAL', // Segundo centro essencial para consciência
        orchORState: OrchORState.QUANTUM_SUPERPOSITION,
        frequencyBand: QuantumFrequencyBand.MEGAHERTZ,
        tripletLevel: 'primary',
        tripletGroup: 1,
        amplitude: 0.15,  // Reduzido um pouco para não ser tão intenso
        phaseCoherence: 0.2,
        createdAt: Date.now()
      };
      
      // Um entrelamento quântico básico (coerência quântica de base)
      const baseEntanglement: QuantumEffect = {
        id: nanoid(),
        core: 'HIPPOCAMPUS',
        orchORState: OrchORState.QUANTUM_COHERENCE,
        frequencyBand: QuantumFrequencyBand.MEGAHERTZ,
        tripletLevel: 'primary',
        tripletGroup: 1,
        amplitude: 0.2,  // Reduzido um pouco para não ser tão intenso
        phaseCoherence: 0.3,
        createdAt: Date.now()
      };
      
      // Adicionar estado quântico basal
      setQuantumSuperpositions([baseSuper1, baseSuper2]);
      setQuantumEntanglements([baseEntanglement]);
      
      // Atualizar coerência basal (Faixa típica de repouso em Orch-OR)
      setTubulinCoherenceLevel(resetLevel); // Nível de coerência configurado
      setOrchestrationIntensity(resetLevel - 0.1); // Ligeiramente menor que a coerência
      
      // Manter o tálamo como região ativa mesmo em repouso
      setActiveRegion('THALAMUS');
      setObserverState('active'); // Observer sempre ativo em nível basal
      
    } catch (error) {
      console.error('[OrchOR] Error in clearAllEffects:', error);
    }
  }, [
    setQuantumSuperpositions,
    setQuantumEntanglements,
    setObjectiveReductions,
    setConsciousStates,
    setTubulinCoherenceLevel,
    setOrchestrationIntensity,
    setObserverState,
    setActiveRegion
  ]);

  return (
    <QuantumVisualizationContext.Provider
      value={{
        // Quantum states based on Orch OR theory
        quantumSuperpositions,
        quantumEntanglements,
        objectiveReductions,
        consciousStates,
        
        // Methods to add quantum effects
        addQuantumSuperposition,
        addQuantumEntanglement,
        addObjectiveReduction,
        addConsciousState,
        
        // Observer and orchestration state
        observerState,
        setObserverState,
        activeRegion,
        setActiveRegion,
        tubulinCoherenceLevel,
        setTubulinCoherenceLevel: (level: number) => setTubulinCoherenceLevel(level),
        orchestrationIntensity,
        setOrchestrationIntensity: (intensity: number) => setOrchestrationIntensity(intensity),
        setPlanckScaleFeedback: (active: boolean) => setPlanckScaleFeedback(active),
        
        // Visual filtering for legend interaction
        activeVisualFilters,
        setActiveVisualFilter,
        removeVisualFilter,
        clearVisualFilters,
        // Effect management
        clearAllEffects
      }}
    >
      {children}
    </QuantumVisualizationContext.Provider>
  );
};

export const useQuantumVisualization = () => {
  const context = useContext(QuantumVisualizationContext);
  if (!context) {
    throw new Error('useQuantumVisualization must be used within a QuantumVisualizationProvider');
  }
  return context;
};
/* SPDX-License-Identifier: MIT OR Apache-2.0
 * Copyright (c) 2025 Guilherme Ferrari Brescia
 */

/* 
  Visualização Quântica CSS
*/

.quantum-three-canvas {
  width: 100%;
  height: 280px;
  min-height: 200px;
  display: block;
}

/* Implementação de efeitos quânticos usando CSS puro para 
  garantir visibilidade mesmo sem suporte a WebGL
*/

.quantum-visualization-css {
  position: relative;
  width: 100%;
  height: 100%;
  min-height: 280px;
  overflow: hidden;
  border-radius: 8px;
  background: linear-gradient(135deg, rgb(2,0,36) 0%, rgb(9,9,121) 35%, rgb(0,25,60) 100%);
}

.quantum-background {
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  opacity: 0.7;
  background: 
    radial-gradient(circle at 30% 30%, rgba(45, 85, 255, 0.1) 0%, rgba(5, 5, 30, 0) 50%),
    radial-gradient(circle at 70% 60%, rgba(120, 70, 255, 0.1) 0%, rgba(5, 5, 30, 0) 50%),
    radial-gradient(circle at 50% 50%, rgba(10, 10, 40, 0.3) 0%, rgba(5, 5, 30, 0) 100%);
  animation: pulse 15s ease-in-out infinite alternate;
}

/* Elementos quânticos de visualização para o QuantumModel */
.quantum-element-1 {
  position: absolute;
  top: 25%;
  left: 10%;
  width: 40px;
  height: 40px;
  border-radius: 50%;
  background: radial-gradient(circle, rgba(0,90,255,1) 0%, rgba(0,50,200,0.7) 50%, rgba(0,0,150,0) 100%);
  filter: blur(2px);
  opacity: 0.8;
  animation: float 4s ease-in-out infinite;
}

.quantum-element-2 {
  position: absolute;
  top: 45%;
  left: 40%;
  width: 120px;
  height: 15px;
  background: linear-gradient(90deg, rgba(200,0,200,0.9) 0%, rgba(255,100,255,0.7) 50%, rgba(200,0,255,0.9) 100%);
  box-shadow: 0 0 15px rgba(200, 0, 255, 0.8);
  animation: glow 3s infinite alternate;
  transform: rotate(-15deg);
  transform-origin: left center;
}

.quantum-element-3 {
  position: absolute;
  top: 30%;
  right: 20%;
  width: 60px;
  height: 60px;
  border-radius: 50%;
  border: 2px solid rgba(100, 255, 255, 0.8);
  box-shadow: 0 0 20px rgba(100, 255, 255, 0.5), inset 0 0 20px rgba(100, 255, 255, 0.5);
  animation: collapse 3s infinite;
  opacity: 0.8;
}

.quantum-element-4 {
  position: absolute;
  top: 65%;
  left: 60%;
  width: 90px;
  height: 30px;
  border-radius: 40%;
  background: radial-gradient(ellipse, rgba(180,255,140,0.7) 0%, rgba(120,200,100,0.3) 70%, rgba(0,0,0,0) 100%);
  filter: blur(5px);
  animation: float 5s infinite alternate;
  transform: rotate(20deg);
}

.quantum-element-5 {
  position: absolute;
  top: 40%;
  left: 70%;
  width: 20px;
  height: 20px;
  border-radius: 50%;
  background: radial-gradient(circle, rgba(255,255,100,0.9) 0%, rgba(255,200,50,0.3) 70%, rgba(0,0,0,0) 100%);
  box-shadow: 0 0 10px rgba(255, 255, 0, 0.8);
  animation: pulse2 2s infinite alternate;
  opacity: 0.8;
}

.quantum-element-6 {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: radial-gradient(circle at 30% 30%, rgba(0,40,80,0.6) 0%, rgba(0,10,20,0.1) 70%);
  opacity: 0.4;
  animation: shift 15s infinite alternate;
}

.quantum-particles-container {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  pointer-events: none;
  z-index: 5;
}

/* Classes de posicionamento para as partículas */
.quantum-particle-pos-1 {
  left: 15%;
  top: 20%;
}

.quantum-particle-pos-2 {
  left: 35%;
  top: 35%;
}

.quantum-particle-pos-3 {
  left: 65%;
  top: 25%;
}

.quantum-particle-pos-4 {
  left: 80%;
  top: 60%;
}

.quantum-particle-pos-5 {
  left: 45%;
  top: 75%;
}

/* Classes de atraso para animações das partículas */
.quantum-particle-delay-1 {
  animation-delay: 0.5s;
}

.quantum-particle-delay-2 {
  animation-delay: 1.2s;
}

.quantum-particle-delay-3 {
  animation-delay: 2.3s;
}

.quantum-particle-delay-4 {
  animation-delay: 3.1s;
}

.quantum-particle-delay-5 {
  animation-delay: 4.5s;
}

/* Partículas quânticas - representam estados quânticos em superposição */
.quantum-particle {
  position: absolute;
  border-radius: 50%;
  filter: blur(1px);
  transform-origin: center center;
  transition: all 0.5s ease;
  pointer-events: none;
  animation: quantum-flicker 3s ease-in-out infinite alternate;
}

/* Linhas de conexão - representam entrelamento quântico */
.quantum-connection {
  position: absolute;
  filter: blur(1px);
  transform-origin: left center;
  pointer-events: none;
  animation: quantum-pulse 4s ease-in-out infinite alternate;
}

/* Colapso de onda - representa redução objetiva */
.quantum-wave-collapse {
  position: absolute;
  border-radius: 50%;
  border: 2px solid rgba(100, 200, 255, 0.8);
  box-shadow: 0 0 10px rgba(120, 180, 255, 0.5), inset 0 0 15px rgba(100, 200, 255, 0.3);
  background: transparent;
  pointer-events: none;
  animation: collapse-pulse 3s ease-in-out infinite;
}

/* Animações quânticas */
@keyframes quantum-flicker {
  0%, 100% {
    transform: scale(1);
    filter: blur(1px);
  }
  50% {
    transform: scale(1.2);
    filter: blur(2px);
  }
}

@keyframes quantum-pulse {
  0%, 100% {
    opacity: 0.3;
    filter: blur(1px);
  }
  50% {
    opacity: 0.7;
    filter: blur(2px);
  }
}

@keyframes collapse-pulse {
  0% {
    transform: scale(0.1);
    opacity: 0.8;
  }
  100% {
    transform: scale(1);
    opacity: 0;
  }
}

@keyframes pulse {
  0%, 100% {
    transform: scale(1);
  }
  50% {
    transform: scale(1.05);
  }
}

/* Adaptações para diferentes tamanhos */
@media screen and (max-width: 768px) {
  .quantum-visualization-css {
    min-height: 200px;
  }
}
/* SPDX-License-Identifier: MIT OR Apache-2.0
 * Copyright (c) 2025 Guilherme Ferrari Brescia
 */

/* Neural card container - base styling */
.orchos-card {
  font-family: 'Inter', Arial, sans-serif;
  min-height: 0;
  min-width: 0;
  display: flex;
  flex-direction: column;
  height: 100%; /* Preenche altura disponível */
  width: 100%; /* Preenche largura disponível */
  padding: clamp(0.45rem, 2vw, 0.7rem); /* Padding menor */
  border-radius: 0.85rem;               /* Raio menor */
  border: 3px solid var(--neural-accent-color, #00faff);
  background: rgba(24,24,40,0.55);
  box-shadow: 0 8px 40px 0 #000b, 0 0 32px 4px rgba(var(--neural-accent-rgb, 0, 250, 255), 0.2) inset;
  -webkit-backdrop-filter: blur(12px) saturate(1.2);
  backdrop-filter: blur(12px) saturate(1.2);
  position: relative; /* Garante contexto para popup absoluto */
  overflow: hidden;
  min-width: 0;
  max-width: 100%;
  box-sizing: border-box;
  margin: 0;
  transition: box-shadow 0.3s ease, border-color 0.3s ease;
}


/* Hover/focus padronizado para todos os cards (inclusive ai) */
.orchos-card:hover,
.orchos-card:active,
.orchos-card:focus-visible {
  box-shadow: 0 8px 48px 0 #000d, 0 0 40px 6px rgba(var(--neural-accent-rgb, 0, 250, 255), 0.32) inset, 0 0 0 2px var(--neural-accent-color, #00faff);
  border-color: var(--neural-accent-color, #00faff);
  z-index: 3;
  transition: box-shadow 0.25s, border-color 0.25s;
}


/* Classes para o conteúdo do card */
.transcription-card-content {
  min-height: 0;
  min-width: 0;
  display: flex;
  flex-direction: column;
  justify-content: flex-start;
  gap: clamp(0.18rem, 1vw, 0.35rem); /* Gap menor */
  padding: 0;
  margin: clamp(0.1rem, 1vw, 0.25rem) 0 clamp(0.25rem, 2vw, 0.5rem) 0;
  position: relative;
  z-index: 1;
  flex: 1 1 auto;
  min-height: 0;
}

/* Estilo para áreas de texto dentro dos cards */
.transcription-card-content textarea,
.transcription-card-content .text-area-container {
  border: 0.5px solid rgba(var(--neural-accent-rgb), 0.2);
  border-radius: 0.75rem;
  background-color: rgba(24,24,40,0.35);
  transition: border-color 0.2s ease, height 0.2s ease;
  width: 100%; /* Preenche toda a largura disponível */
  flex: 1 1 auto; /* Cresce para preencher espaço disponível */
  min-height: 0; /* Permite encolher quando necessário */
  resize: none; /* Remove resize handle para layout mais limpo */
  display: flex; /* Para conteúdo interno */
  flex-direction: column; /* Organiza conteúdo */
  height: auto !important; /* Força altura automática, substituindo inline styles */
  min-height: min(120px, 25vh) !important; /* Altura mínima responsiva */
  max-height: 100% !important; /* Nunca ultrapassa o container */
}

/* Textarea específico - componente TextEditor */
textarea.orchos-textarea-neural,
.orchos-textarea-neural {
  height: auto !important; /* Força altura automática */
  min-height: min(30vh, 150px) !important; /* Altura mínima responsível */
  max-height: 100% !important; /* Nunca ultrapassa o card */
  flex: 1 1 auto !important; /* Prioriza crescimento */
  overflow-y: auto !important; /* Scroll vertical quando necessário */
  box-sizing: border-box !important;
  padding: clamp(0.75rem, 2.5vw, 1rem) !important;
  font-size: clamp(0.9rem, 1.5vw, 1rem) !important;
  line-height: 1.5 !important;
  color: rgba(255, 255, 255, 0.9) !important;
}

/* Seletores específicos para sobrescrever estilos inline */
textarea[style*="height"],
div[style*="height"] textarea {
  height: auto !important;
  min-height: min(30vh, 150px) !important;
}

/* Para conteúdo maior, adiciona scroll interno ao invés de crescer indefinidamente */
.transcription-card-content textarea[rows],
.transcription-card-content textarea.orchos-textarea-neural {
  overflow-y: auto !important;
  max-height: 100% !important;
}

/* Container para TextEditor */
.flex-1.flex.flex-col.min-h-0 {
  display: flex;
  flex-direction: column;
  flex: 1 1 auto;
  min-height: 0;
  height: 100%;
  width: 100%;
}

.transcription-card-content textarea:focus,
.transcription-card-content .text-area-container:focus-within {
  border-color: var(--neural-accent-color);
  box-shadow: 0 0 8px rgba(var(--neural-accent-rgb), 0.2);
}

/* Estilos para mensagens dentro dos cards */
.message-container {
  padding: clamp(0.5rem, 2.5%, 0.75rem);
  border-radius: 0.5rem;
  background: rgba(0, 0, 0, 0.25);
  margin: clamp(0.25rem, 2%, 0.5rem) 0;
  border-left: 2px solid var(--neural-accent-color, #00faff);
  width: 100%; /* Preenche toda a largura disponível */
  box-sizing: border-box;
  overflow-wrap: break-word; /* Quebra palavras longas */
  word-break: break-word; /* Ajuda em nomes de arquivos */
}

/* Cabeçalho do card */
.transcription-card-header {
  --neural-accent-color: inherit; /* Garante herança da cor do card pai */
  display: flex;
  align-items: center;
  gap: clamp(0.5rem, 2%, 0.75rem); /* Gap responsivo */
  margin-bottom: clamp(0.5rem, 3%, 1rem); /* Margem responsiva */
  min-height: 32px; /* Altura mínima para garantir visibilidade */
  flex-wrap: wrap;
  position: relative;
  z-index: 2; /* Garante que fique acima do conteúdo */
  width: 100%; /* Preenche toda a largura disponível */
}

/* Título do card */
.transcription-card-title {
  color: var(--neural-accent-color, #00faff) !important; /* Força prioridade da cor simbólica */
  font-size: 1.15rem; /* Ligeiramente aumentado */
  font-weight: 600;
  letter-spacing: 0.025rem; /* Aumentado para melhor legibilidade */
  margin: 0;
  padding: 0;
  display: flex;
  align-items: center;
  gap: 0.5rem;
}

/* Ícone do card */
.transcription-card-icon {
  color: var(--neural-accent-color, #00faff) !important;
  fill: var(--neural-accent-color, #00faff) !important;
  stroke: var(--neural-accent-color, #00faff) !important;
  display: flex;
  align-items: center;
  justify-content: center;
  height: 24px; /* Tamanho fixo para consistência */
  width: 24px; /* Tamanho fixo para consistência */
}

/* Ações do cabeçalho do card */
.transcription-card-header-actions {
  display: flex;
  flex-wrap: wrap;
  gap: clamp(0.35rem, 2%, 0.75rem); /* Gap responsivo */
  margin-left: auto;
  align-items: center;
  min-height: 32px; /* Altura mínima consistente */
  justify-content: flex-end; /* Alinha à direita */
}

/* Estilos para tipos específicos de cards */
[data-type="context"] {
  --neural-accent-color: #00faff;
  --neural-accent-rgb: 0, 250, 255;
  border-color: #00faff;
}

[data-type="transcription"] {
  --neural-accent-color: #ff416c;
  --neural-accent-rgb: 255, 65, 108;
  border-color: #ff416c;
}

[data-type="cognition"] {
  --neural-accent-color: #7c4dff;
  --neural-accent-rgb: 124, 77, 255;
  border-color: #7c4dff;
}

[data-type="ai"] {
  --neural-accent-color: #ff80ab;
  --neural-accent-rgb: 255, 128, 171;
  border-color: #ff80ab;
}

/* Rodapé do card */
.orchos-card-footer {
  display: flex;
  align-items: center;
  justify-content: flex-end;
  gap: clamp(0.35rem, 2%, 0.75rem); /* Gap responsivo */
  margin-top: auto; /* Empurra para o final do card */
  padding-top: clamp(0.5rem, 2%, 0.75rem); /* Padding responsivo */
  border-top: 1px solid rgba(var(--neural-accent-rgb), 0.1); /* Separador sutil */
  position: relative;
  z-index: 2;
  width: 100%; /* Preenche toda a largura disponível */
  flex-wrap: wrap; /* Permite quebra em telas menores */
}

/* Estilo para botões dentro dos cards */
.orchos-card button {
  font-family: 'Inter', Arial, sans-serif;
  font-weight: 500;
  min-height: 28px; /* Altura mínima consistente */
  padding: clamp(0.15rem, 1%, 0.25rem) clamp(0.5rem, 2%, 0.75rem); /* Padding responsivo */
  border-radius: 0.5rem; /* Arredondamento consistente */
  transition: all 0.2s ease; /* Transição suave */
  display: inline-flex;
  align-items: center;
  justify-content: center;
  gap: clamp(0.25rem, 1.5%, 0.5rem);
  flex-shrink: 0; /* Evita encolhimento excessivo */
  white-space: nowrap; /* Evita quebra de texto */
  overflow: hidden; /* Esconde overflow */
  text-overflow: ellipsis; /* Mostra elipses (...) quando necessário */
}

/* Corrige o foco em botões para não afetar o card pai */
.orchos-card button:focus {
  outline: 2px solid var(--neural-accent-color, #00faff);
  box-shadow: 0 0 8px rgba(var(--neural-accent-rgb), 0.5);
}

/* Hover state para botões */
.orchos-card button:hover {
  transform: translateY(-1px);
  box-shadow: 0 2px 8px rgba(var(--neural-accent-rgb), 0.3);
}

.transcription-panel-grid {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 2.5rem;
  margin: 0 auto;
  max-width: 1200px;
  align-items: flex-start;
  padding: 0 1.5rem 2.5rem 1.5rem;
}

@media (max-width: 1100px) {
  .transcription-panel-grid {
    grid-template-columns: 1fr;
    gap: 2rem;
    max-width: 700px;
    padding: 0 0.5rem 2rem 0.5rem;
  }
}
// SPDX-License-Identifier: MIT OR Apache-2.0
// Copyright (c) 2025 Guilherme Ferrari Brescia

import React from "react";
import "./SimpleCard.css";

/**
 * SimpleCard — Implementação concreta de um córtex neural de interface.
 * 
 * Intent simbólico: Neurônio de interface que organiza informação cognitiva em
 * um container espacial com propriedades quânticas de contexto.
 * 
 * Linhagem neural: Interface -> Córtex Visual -> Representação Simbólica
 */
export interface SimpleCardProps {
  /** Title of the card, displayed in the header */
  title: string;
  /** Card content */
  children: React.ReactNode;
  /** Optional debug border */
  debugBorder?: boolean;
  /** Symbolic type for color/glow (context, transcription, cognition, ai) */
  type?: 'context' | 'transcription' | 'cognition' | 'ai';
  /** Optional icon (JSX.Element) to show in header */
  icon?: React.ReactNode;
  /** Optional actions (e.g., buttons) to render in the header, right-aligned */
  headerActions?: React.ReactNode;
  /** Optional footer actions (e.g., buttons) to render at the bottom of the card */
  footerActions?: React.ReactNode;
  /** For backward compatibility with previous APIs */
  defaultOpen?: boolean;
};

/**
 * Implementação concreta do córtex neural para o painel de transcrição.
 * Alinha-se às interfaces de domínio para modularização e reutilização em outros módulos.
 */


const SimpleCard: React.FC<SimpleCardProps> = ({ 
  title, 
  children, 
  debugBorder, 
  type, 
  icon, 
  headerActions = undefined,
  footerActions = undefined
}) => {
  const contentId = `neural-content-${title.replace(/\s+/g, '-').toLowerCase()}`;
  
  // Componente final com estrutura semântica e acessível
  return (
    <div
      className="orchos-card neural-card"
      data-state="expanded"
      data-debugborder={debugBorder ? "true" : undefined}
      data-type={type}
    >
      <div className="transcription-card-header">
        {icon && (
          <span className="transcription-card-icon" aria-hidden="true">
            {icon}
          </span>
        )}
        <span
          className="transcription-card-title"
          title={title}
        >
          {title}
        </span>
        {headerActions && (
          <div className="transcription-card-header-actions ml-auto">
            {headerActions}
          </div>
        )}
      </div>
      
      {/* Conteúdo do card neural */}
      <div 
        className="transcription-card-content" 
        id={contentId}
      >
        {children}
      </div>
      
      {footerActions && (
        <div className="orchos-card-footer">
          {footerActions}
        </div>
      )}
    </div>
  );
};

export default SimpleCard;// SPDX-License-Identifier: MIT OR Apache-2.0
// Copyright (c) 2025 Guilherme Ferrari Brescia

import { createContext, ReactNode, useContext, useState } from 'react';
import { SimpleModuleState } from '../../../domain/core/interfaces/components/SimpleModule';

/**
 * Contexto para o estado de colapso/expansão de módulos neurais da interface.
 * 
 * Intent Simbólico: Permite orquestração coordenada de múltiplos estados de colapso
 * nos módulos corticais, possibilitando comunicação neural entre componentes irmãos.
 */
interface SimpleContextState {
  expandedModules: Set<string>;
  toggleModule: (id: string) => void;
  isExpanded: (id: string) => boolean;
  collapseAll: () => void;
  expandAll: (moduleIds: string[]) => void;
}

const SimpleContext = createContext<SimpleContextState | null>(null);

/**
 * Provider para gerenciamento de estado de colapso/expansão entre múltiplos módulos.
 * 
 * Linhagem Neural: Orquestrador Cortical → Adaptação Dinâmica → Interface Visual
 */
export const SimpleProvider: React.FC<{ children: ReactNode }> = ({ children }) => {
  const [expandedModules, setExpandedModules] = useState<Set<string>>(new Set());

  const toggleModule = (id: string) => {
    setExpandedModules(prev => {
      const newSet = new Set(prev);
      if (newSet.has(id)) {
        newSet.delete(id);
      } else {
        newSet.add(id);
      }
      return newSet;
    });
  };

  const isExpanded = (id: string) => expandedModules.has(id);
  
  const collapseAll = () => setExpandedModules(new Set());
  const expandAll = (moduleIds: string[]) => setExpandedModules(new Set(moduleIds));

  return (
    <SimpleContext.Provider value={{ expandedModules, toggleModule, isExpanded, collapseAll, expandAll }}>
      {children}
    </SimpleContext.Provider>
  );
};
