
/**
 * Hook para utilização do contexto de collapse/expand nos módulos corticais.
 * Retorna funções e estado para sincronizar estados de colapso.
 */
export const useSimple = (): SimpleContextState => {
  const context = useContext(SimpleContext);
  if (!context) {
    throw new Error('useSimple deve ser usado dentro de um SimpleProvider');
  }
  return context;
};

/**
 * Hook para um módulo colapsável individual.
 * Fornece estado e funções para gerenciar colapso/expansão sincronizada.
 */
export const useSimpleModule = (id: string, defaultOpen = false): SimpleModuleState => {
  const context = useContext(SimpleContext);
  const [localOpen, setLocalOpen] = useState(defaultOpen);
  
  // Se não houver contexto, usa state local
  if (!context) {
    return {
      isExpanded: localOpen,
      toggle: () => setLocalOpen(!localOpen)
    };
  }
  
  // Inicializa o módulo como aberto no contexto se for padrão
  if (defaultOpen && !context.isExpanded(id)) {
    context.toggleModule(id);
  }
  
  return {
    isExpanded: context.isExpanded(id),
    toggle: () => context.toggleModule(id)
  };
};import React, { useEffect, useRef } from "react";
import { SelectedDevices } from "../../../../../context";
import AudioSettingsSimple from "../../settings/AudioSettingsSimple";

interface AudioSettingsPopoverProps {
  show: boolean;
  onClose: () => void;
  anchorRef?: React.RefObject<HTMLElement>;
  settings: {
    // Language
    language: string;
    setLanguage: (value: string) => void;

    // Device selection
    isMicrophoneOn: boolean;
    setIsMicrophoneOn: (value: boolean) => void;
    isSystemAudioOn: boolean;
    setIsSystemAudioOn: (value: boolean) => void;
    audioDevices: MediaDeviceInfo[];
    selectedDevices: SelectedDevices;
    handleDeviceChange: (deviceId: string, isSystemAudio: boolean) => void;
  };
}

/**
 * Audio Settings Popover component
 * Shows audio configuration options in a floating panel
 */
export const AudioSettingsPopover: React.FC<AudioSettingsPopoverProps> = ({
  show,
  onClose,
  anchorRef,
  settings,
}) => {
  const popoverRef = useRef<HTMLDivElement>(null);

  // Close popover when clicking outside
  useEffect(() => {
    const handleClickOutside = (event: MouseEvent) => {
      if (
        popoverRef.current &&
        !popoverRef.current.contains(event.target as Node) &&
        anchorRef?.current &&
        !anchorRef.current.contains(event.target as Node)
      ) {
        onClose();
      }
    };

    if (show) {
      document.addEventListener("mousedown", handleClickOutside);
    }

    return () => {
      document.removeEventListener("mousedown", handleClickOutside);
    };
  }, [show, onClose, anchorRef]);

  // Handle escape key
  useEffect(() => {
    const handleEscape = (event: KeyboardEvent) => {
      if (event.key === "Escape") {
        onClose();
      }
    };

    if (show) {
      document.addEventListener("keydown", handleEscape);
    }

    return () => {
      document.removeEventListener("keydown", handleEscape);
    };
  }, [show, onClose]);

  if (!show) return null;

  return (
    <div ref={popoverRef} className="audio-settings-popover-container">
      <div
        className="audio-settings-popover"
        style={{
          backgroundColor: "rgba(17, 24, 39, 0.95)",
          backdropFilter: "blur(20px)",
          border: "1px solid rgba(0, 240, 255, 0.2)",
          borderRadius: "12px",
          boxShadow:
            "0 10px 30px rgba(0, 0, 0, 0.5), 0 0 20px rgba(0, 240, 255, 0.1)",
          padding: "24px",
          width: "360px",
          zIndex: 50,
        }}
      >
        <AudioSettingsSimple
          // Language
          language={settings.language}
          setLanguage={settings.setLanguage}
          // Device selection
          isMicrophoneOn={settings.isMicrophoneOn}
          setIsMicrophoneOn={settings.setIsMicrophoneOn}
          isSystemAudioOn={settings.isSystemAudioOn}
          setIsSystemAudioOn={settings.setIsSystemAudioOn}
          audioDevices={settings.audioDevices}
          selectedDevices={settings.selectedDevices}
          handleDeviceChange={settings.handleDeviceChange}
        />
      </div>
    </div>
  );
};
import React from "react";
import { MicrophoneState } from "../../../../../context";
import { ChatControlsProps } from "../types/ChatTypes";

/**
 * Chat controls component with modern futuristic icons
 * Enhanced with better visual feedback and animations
 */
export const ChatControls: React.FC<ChatControlsProps> = ({
  microphoneState,
  onToggleRecording,
  onSend,
  onToggleContext,
  canSend,
  showContext,
  onToggleAudioSettings,
  showAudioSettings,
  audioSettingsButtonRef,
}) => {
  return (
    <div className="input-controls">
      {/* Context Toggle Button - Modern design */}
      <button
        className={`control-btn context-btn ${showContext ? "active" : ""}`}
        onClick={onToggleContext}
        title={showContext ? "Hide context field" : "Add context"}
        type="button"
      >
        <svg width="24" height="24" viewBox="0 0 24 24" fill="none">
          <rect
            x="3"
            y="3"
            width="18"
            height="18"
            rx="4"
            stroke="currentColor"
            strokeWidth="1.5"
            strokeLinecap="round"
            strokeLinejoin="round"
          />
          <path
            d="M8 12h8M12 8v8"
            stroke="currentColor"
            strokeWidth="1.5"
            strokeLinecap="round"
          />
          <circle cx="12" cy="12" r="3" fill="currentColor" opacity="0.3" />
        </svg>
      </button>

      {/* Audio Settings Button - Futuristic wave design */}
      <button
        ref={audioSettingsButtonRef as React.RefObject<HTMLButtonElement>}
        className={`control-btn audio-settings-btn ${
          showAudioSettings ? "active" : ""
        }`}
        onClick={onToggleAudioSettings}
        title="Audio settings"
        type="button"
      >
        <svg width="24" height="24" viewBox="0 0 24 24" fill="none">
          <path d="M3 12h4l4-4v12l-4-4H3z" fill="currentColor" opacity="0.8" />
          <path
            d="M14 8c1.5 1 2.5 2.5 2.5 4s-1 3-2.5 4"
            stroke="currentColor"
            strokeWidth="1.5"
            strokeLinecap="round"
          />
          <path
            d="M17 5c2.5 1.5 4 4 4 7s-1.5 5.5-4 7"
            stroke="currentColor"
            strokeWidth="1.5"
            strokeLinecap="round"
            opacity="0.6"
          />
        </svg>
      </button>

      {/* Microphone Button - Modern minimal design */}
      <button
        className={`control-btn mic-btn ${
          microphoneState === MicrophoneState.Open ? "recording" : ""
        }`}
        onClick={onToggleRecording}
        title={
          microphoneState === MicrophoneState.Open
            ? "Stop recording"
            : "Start recording"
        }
        type="button"
      >
        <svg width="24" height="24" viewBox="0 0 24 24" fill="none">
          {microphoneState === MicrophoneState.Open ? (
            // Recording state - animated square
            <g>
              <rect x="8" y="8" width="8" height="8" fill="currentColor" rx="2">
                <animate
                  attributeName="rx"
                  values="2;4;2"
                  dur="1.5s"
                  repeatCount="indefinite"
                />
              </rect>
              <circle
                cx="12"
                cy="12"
                r="9"
                stroke="currentColor"
                strokeWidth="1.5"
                opacity="0.3"
              />
            </g>
          ) : (
            // Microphone icon - sleek design
            <>
              <rect
                x="9"
                y="3"
                width="6"
                height="11"
                rx="3"
                fill="currentColor"
              />
              <path
                d="M5 10v2a7 7 0 0014 0v-2"
                stroke="currentColor"
                strokeWidth="1.5"
                strokeLinecap="round"
              />
              <line
                x1="12"
                y1="19"
                x2="12"
                y2="22"
                stroke="currentColor"
                strokeWidth="1.5"
              />
              <line
                x1="8"
                y1="22"
                x2="16"
                y2="22"
                stroke="currentColor"
                strokeWidth="1.5"
                strokeLinecap="round"
              />
            </>
          )}
        </svg>
      </button>

      {/* Send Button - Modern arrow design */}
      <button
        className={`control-btn send-btn ${canSend ? "ready" : "disabled"}`}
        onClick={onSend}
        disabled={!canSend}
        title="Send message (Enter)"
        type="button"
      >
        <svg width="24" height="24" viewBox="0 0 24 24" fill="none">
          <path
            d="M3 12L5 4l16 8-16 8 2-8zm2 0h7"
            stroke="currentColor"
            strokeWidth="1.5"
            strokeLinecap="round"
            strokeLinejoin="round"
            fill="none"
          />
          <circle cx="12" cy="12" r="2" fill="currentColor" opacity="0.3" />
        </svg>
      </button>
    </div>
  );
};
import React, { useState } from "react";
import { ChatConversation } from "../types/ChatHistoryTypes";

interface ChatHistorySidebarProps {
  conversations: ChatConversation[];
  currentConversationId: string | null;
  onSelectConversation: (id: string) => void;
  onCreateNewConversation: () => void;
  onDeleteConversation: (id: string) => void;
  onSearchConversations: (query: string) => ChatConversation[];
  isProcessing?: boolean; // Disable new conversation while AI is processing
}

export const ChatHistorySidebar: React.FC<ChatHistorySidebarProps> = ({
  conversations,
  currentConversationId,
  onSelectConversation,
  onCreateNewConversation,
  onDeleteConversation,
  onSearchConversations,
  isProcessing = false,
}) => {
  const [searchQuery, setSearchQuery] = useState("");
  const [hoveredId, setHoveredId] = useState<string | null>(null);

  // Filter conversations based on search
  const displayedConversations = searchQuery
    ? onSearchConversations(searchQuery)
    : conversations;

  // Format date for display
  const formatDate = (date: Date): string => {
    const now = new Date();
    const diffMs = now.getTime() - date.getTime();
    const diffMins = Math.floor(diffMs / 60000);
    const diffHours = Math.floor(diffMs / 3600000);
    const diffDays = Math.floor(diffMs / 86400000);

    if (diffMins < 1) return "Agora";
    if (diffMins < 60) return `${diffMins}m atrás`;
    if (diffHours < 24) return `${diffHours}h atrás`;
    if (diffDays < 7) return `${diffDays}d atrás`;

    return date.toLocaleDateString("pt-BR", {
      day: "2-digit",
      month: "short",
    });
  };

  return (
    <div className="chat-history-sidebar">
      {/* Header */}
      <div className="sidebar-header">
        <h2 className="sidebar-title">Conversas</h2>
        <button
          className={`new-chat-button ${isProcessing ? "disabled" : ""}`}
          onClick={onCreateNewConversation}
          disabled={isProcessing}
          title={
            isProcessing ? "Aguarde o processamento terminar" : "Nova conversa"
          }
        >
          <svg width="20" height="20" viewBox="0 0 20 20" fill="none">
            <path
              d="M10 4v12m6-6H4"
              stroke="currentColor"
              strokeWidth="2"
              strokeLinecap="round"
            />
          </svg>
        </button>
      </div>

      {/* Search */}
      <div className="sidebar-search">
        <input
          type="text"
          placeholder="Buscar conversas..."
          value={searchQuery}
          onChange={(e) => setSearchQuery(e.target.value)}
          className="search-input"
        />
        <svg
          className="search-icon"
          width="16"
          height="16"
          viewBox="0 0 16 16"
          fill="none"
        >
          <circle cx="7" cy="7" r="5" stroke="currentColor" strokeWidth="1.5" />
          <path
            d="M11 11l3 3"
            stroke="currentColor"
            strokeWidth="1.5"
            strokeLinecap="round"
          />
        </svg>
      </div>

      {/* Conversations List */}
      <div className="conversations-list">
        {displayedConversations.length === 0 ? (
          <div className="no-conversations">
            {searchQuery
              ? "Nenhuma conversa encontrada"
              : "Nenhuma conversa ainda"}
          </div>
        ) : (
          displayedConversations.map((conv) => (
            <div
              key={conv.id}
              className={`conversation-item ${
                conv.id === currentConversationId ? "active" : ""
              }`}
              onClick={() => onSelectConversation(conv.id)}
              onMouseEnter={() => setHoveredId(conv.id)}
              onMouseLeave={() => setHoveredId(null)}
            >
              <div className="conversation-content">
                <h3 className="conversation-title">{conv.title}</h3>
                <p className="conversation-preview">
                  {conv.lastMessage || "Conversa vazia"}
                </p>
                <span className="conversation-time">
                  {formatDate(conv.lastMessageTime)}
                </span>
              </div>

              {/* Delete button */}
              {hoveredId === conv.id && (
                <button
                  className="delete-button"
                  onClick={(e) => {
                    e.stopPropagation();
                    if (window.confirm("Excluir esta conversa?")) {
                      onDeleteConversation(conv.id);
                    }
                  }}
                  title="Excluir conversa"
                >
                  <svg width="16" height="16" viewBox="0 0 16 16" fill="none">
                    <path
                      d="M4 4l8 8m0-8l-8 8"
                      stroke="currentColor"
                      strokeWidth="1.5"
                      strokeLinecap="round"
                    />
                  </svg>
                </button>
              )}
            </div>
          ))
        )}
      </div>
    </div>
  );
};
import React from "react";
import { useDeepgram } from "../../../../../context";
import { ChatState, ConversationalChatProps } from "../types/ChatTypes";
import { ChatControls } from "./ChatControls";
import { ContextInput } from "./ContextInput";
// import { DebugControls } from "./DebugControls"; // Removed - debug controls disabled
import { MessageInput } from "./MessageInput";
import { TranscriptionDisplay } from "./TranscriptionDisplay";

interface ChatInputAreaProps extends ConversationalChatProps {
  chatState: ChatState;
  onSendMessage: () => void;
  onKeyPress: (e: React.KeyboardEvent) => void;
  onToggleContext: () => void;
  onAddTestMessage: () => void;
  onAddTestAI: () => void;
  onRestore: () => void;
  onClearAll: () => void;
  hasBackup: boolean;
  onToggleAudioSettings?: () => void;
  showAudioSettings?: boolean;
  audioSettingsButtonRef?: React.RefObject<HTMLElement>;
}

/**
 * Chat input area component
 * Follows composition pattern - combines input-related components
 * Debug controls removed for cleaner UI
 */
export const ChatInputArea: React.FC<ChatInputAreaProps> = ({
  transcriptionText,
  onClearTranscription,
  microphoneState,
  onToggleRecording,
  chatState,
  onSendMessage,
  onKeyPress,
  onToggleContext,
  onAddTestMessage,
  onAddTestAI,
  onRestore,
  onClearAll,
  hasBackup,
  onToggleAudioSettings,
  showAudioSettings,
  audioSettingsButtonRef,
}) => {
  const canSend =
    !!(chatState.inputMessage.trim() || transcriptionText.trim()) &&
    !chatState.isProcessing;

  // Get transcriptions with status from Deepgram context
  const { getAllTranscriptionsWithStatus } = useDeepgram();
  const transcriptionsWithStatus = getAllTranscriptionsWithStatus
    ? getAllTranscriptionsWithStatus()
    : [];

  return (
    <div className="chat-input-area">
      {/* Context Input */}
      <ContextInput
        value={chatState.currentContext}
        onChange={chatState.setCurrentContext}
        onClose={() => {
          chatState.setCurrentContext("");
          chatState.setShowContextField(false);
        }}
        show={chatState.showContextField}
      />

      {/* Main Input Area */}
      <div className="main-input-wrapper">
        <div className="input-row">
          {/* Transcription Display */}
          <TranscriptionDisplay
            text={transcriptionText}
            onClear={onClearTranscription}
            transcriptions={transcriptionsWithStatus}
          />

          {/* Input Bottom Row - Input + Controls */}
          <div className="input-bottom-row">
            {/* Message Input */}
            <MessageInput
              value={chatState.inputMessage}
              onChange={chatState.setInputMessage}
              onSend={onSendMessage}
              onKeyPress={onKeyPress}
              placeholder="Type your message or use voice transcription..."
            />

            {/* Main Chat Controls - Debug controls removed */}
            <ChatControls
              microphoneState={microphoneState}
              onToggleRecording={onToggleRecording}
              onSend={onSendMessage}
              onToggleContext={onToggleContext}
              canSend={canSend}
              showContext={
                chatState.showContextField || !!chatState.currentContext
              }
              onToggleAudioSettings={onToggleAudioSettings}
              showAudioSettings={showAudioSettings}
              audioSettingsButtonRef={audioSettingsButtonRef}
            />
          </div>
        </div>
      </div>

      {/* TODO: Add AudioSettingsPopover component here
      <AudioSettingsPopover
        show={showAudioSettings}
        onClose={() => setShowAudioSettings(false)}
        anchorRef={audioSettingsButtonRef}
        settings={audioSettings}
      />
      */}
    </div>
  );
};
import React from "react";
import { ChatMessage, ChatMessagesContainerProps } from "../types/ChatTypes";
import { ScrollToBottomButton } from "./ScrollToBottomButton";

// Memoized message component for performance
const MessageItem: React.FC<{ message: ChatMessage }> = React.memo(
  ({ message }) => {
    // Generate unique IDs for gradients to avoid conflicts
    const messageId = message.id || Math.random().toString(36).substr(2, 9);
    const gradientId = `gradient-${message.type}-${messageId}`;

    return (
      <div className={`message ${message.type}-message`}>
        <div className="message-avatar">
          {message.type === "user" ? (
            <svg width="24" height="24" viewBox="0 0 24 24" fill="none">
              <defs>
                <linearGradient
                  id={gradientId}
                  x1="0%"
                  y1="0%"
                  x2="100%"
                  y2="100%"
                >
                  <stop offset="0%" stopColor="#00faff" />
                  <stop offset="100%" stopColor="#0066cc" />
                </linearGradient>
              </defs>
              <circle cx="12" cy="12" r="10" fill={`url(#${gradientId})`} />
              {/* Bonequinho centralizado - cabeça e corpo */}
              <path
                d="M12 10c1.66 0 3-1.34 3-3s-1.34-3-3-3-3 1.34-3 3 1.34 3 3 3zm0 1c-2 0-6 1-6 3v1.5c0 0.28 0.22 0.5 0.5 0.5h11c0.28 0 0.5-0.22 0.5-0.5V14c0-2-4-3-6-3z"
                fill="white"
              />
            </svg>
          ) : (
            <svg width="24" height="24" viewBox="0 0 24 24" fill="none">
              <defs>
                <linearGradient
                  id={gradientId}
                  x1="0%"
                  y1="0%"
                  x2="100%"
                  y2="100%"
                >
                  <stop offset="0%" stopColor="#ff4dd2" />
                  <stop offset="100%" stopColor="#7c4dff" />
                </linearGradient>
              </defs>
              <circle cx="12" cy="12" r="10" fill={`url(#${gradientId})`} />
              {/* AI brain icon - melhor centralizado */}
              <rect
                x="8.5"
                y="8.5"
                width="7"
                height="7"
                rx="1.5"
                fill="white"
              />
              <circle cx="12" cy="12" r="1.5" fill={`url(#${gradientId})`} />
            </svg>
          )}
        </div>

        <div className="message-bubble-wrapper">
          <div className="message-content">
            {message.hasContext && message.contextContent && (
              <div className="message-context">
                <div className="context-label">Context:</div>
                <div className="context-content">{message.contextContent}</div>
              </div>
            )}
            <div className="message-text">{message.content}</div>
          </div>

          {/* Timestamp fora do bubble, similar ao WhatsApp */}
          <div className="message-timestamp">
            {message.timestamp.toLocaleTimeString([], {
              hour: "2-digit",
              minute: "2-digit",
            })}
          </div>
        </div>
      </div>
    );
  }
);

// Typing indicator component
const TypingIndicator: React.FC = React.memo(() => {
  const gradientId = `gradient-typing-${Date.now()}`;

  return (
    <div className="message system-message typing-indicator">
      <div className="message-avatar">
        <svg width="24" height="24" viewBox="0 0 24 24" fill="none">
          <defs>
            <linearGradient id={gradientId} x1="0%" y1="0%" x2="100%" y2="100%">
              <stop offset="0%" stopColor="#ff4dd2" />
              <stop offset="100%" stopColor="#7c4dff" />
            </linearGradient>
          </defs>
          <circle cx="12" cy="12" r="10" fill={`url(#${gradientId})`} />
          {/* AI brain icon - melhor centralizado */}
          <rect x="8.5" y="8.5" width="7" height="7" rx="1.5" fill="white" />
          <circle cx="12" cy="12" r="1.5" fill={`url(#${gradientId})`} />
        </svg>
      </div>
      <div className="message-bubble-wrapper">
        <div className="message-content">
          <div className="message-text typing-animation">
            <span></span>
            <span></span>
            <span></span>
          </div>
        </div>
      </div>
    </div>
  );
});

// Welcome message component
const WelcomeMessage: React.FC<{
  onAddTestMessage: () => void;
  onResetState: () => void;
  onClearMessages: () => void;
}> = React.memo(({ onAddTestMessage, onResetState, onClearMessages }) => {
  const gradientId = `gradient-welcome-${Date.now()}`;

  return (
    <div className="welcome-message">
      <div className="welcome-icon">
        <svg width="48" height="48" viewBox="0 0 24 24" fill="none">
          <defs>
            <linearGradient id={gradientId} x1="0%" y1="0%" x2="100%" y2="100%">
              <stop offset="0%" stopColor="#00faff" />
              <stop offset="100%" stopColor="#7c4dff" />
            </linearGradient>
          </defs>
          <circle
            cx="12"
            cy="12"
            r="10"
            stroke={`url(#${gradientId})`}
            strokeWidth="2"
          />
          <path
            d="M8 12l2 2 4-4"
            stroke={`url(#${gradientId})`}
            strokeWidth="2"
            strokeLinecap="round"
            strokeLinejoin="round"
          />
        </svg>
      </div>
      <h3>Welcome to Orch-OS Neural Chat</h3>
      <p>
        Start a conversation by typing a message or using voice transcription.
      </p>

      {/* Debug buttons removed for cleaner UI */}
    </div>
  );
});

/**
 * Chat messages container component
 * Follows Single Responsibility Principle - only handles message display and scroll
 */
export const ChatMessagesContainer: React.FC<ChatMessagesContainerProps> = ({
  messages,
  isProcessing,
  onScrollChange,
  scrollRef,
  showScrollButton,
  onScrollToBottom,
  onAddTestMessage = () => {},
  onResetState = () => {},
  onClearMessages = () => {},
}) => {
  const handleScroll = () => {
    if (scrollRef.current) {
      const { scrollTop, scrollHeight, clientHeight } = scrollRef.current;
      const distanceFromBottom = scrollHeight - scrollTop - clientHeight;
      // Tolerância mínima de 2 pixels, consistente com useChatScroll
      const isNearBottom = distanceFromBottom <= 2;
      onScrollChange(isNearBottom);
    }
  };

  return (
    <div className="chat-messages-container">
      <div className="chat-messages" ref={scrollRef} onScroll={handleScroll}>
        <div className="messages-wrapper">
          {messages.map((message) => (
            <MessageItem key={message.id} message={message} />
          ))}

          {isProcessing && <TypingIndicator />}

          {messages.length === 0 && !isProcessing && (
            <WelcomeMessage
              onAddTestMessage={onAddTestMessage}
              onResetState={onResetState}
              onClearMessages={onClearMessages}
            />
          )}

          {/* Hidden div for scroll to bottom */}
          <div style={{ float: "left", clear: "both" }} />
        </div>
      </div>

      {/* Scroll to bottom button */}
      <ScrollToBottomButton
        show={showScrollButton}
        onClick={onScrollToBottom}
      />
    </div>
  );
};
import React from "react";
import { ContextInputProps } from "../types/ChatTypes";

/**
 * Context input component
 * Follows Single Responsibility Principle - only handles context input
 */
export const ContextInput: React.FC<ContextInputProps> = ({
  value,
  onChange,
  onClose,
  show,
}) => {
  if (!show && !value) return null;

  const handleChange = (e: React.ChangeEvent<HTMLTextAreaElement>) => {
    onChange(e.target.value);
  };

  return (
    <div className="context-input-wrapper">
      <div className="context-label">
        <svg width="16" height="16" viewBox="0 0 20 20" fill="none">
          <circle cx="10" cy="10" r="8" stroke="currentColor" strokeWidth="2" />
          <path
            d="M10 5v5l3 3"
            stroke="currentColor"
            strokeWidth="2"
            strokeLinecap="round"
          />
        </svg>
        Context (will be included with next message)
        <button
          className="context-close-btn"
          onClick={onClose}
          title="Remove context"
          type="button"
        >
          ×
        </button>
      </div>
      <textarea
        className="context-input"
        value={value}
        onChange={handleChange}
        placeholder="Add situational context..."
        rows={2}
        autoFocus={show}
      />
    </div>
  );
};
import React, { useEffect, useRef, useState } from "react";
import { ChatInputProps } from "../types/ChatTypes";

/**
 * Message input component
 * Follows Single Responsibility Principle - only handles message input
 */
export const MessageInput: React.FC<ChatInputProps> = ({
  value,
  onChange,
  onSend,
  onKeyPress,
  disabled = false,
  placeholder = "Type your message or use voice transcription...",
}) => {
  const inputRef = useRef<HTMLTextAreaElement>(null);
  const [isTyping, setIsTyping] = useState(false);
  const typingTimeoutRef = useRef<NodeJS.Timeout | null>(null);

  // Auto-resize textarea (KISS principle - simple and focused)
  useEffect(() => {
    if (inputRef.current) {
      inputRef.current.style.height = "44px";
      inputRef.current.style.height = `${inputRef.current.scrollHeight}px`;
    }
  }, [value]);

  // Handle typing indicator
  useEffect(() => {
    if (value.trim().length > 0) {
      setIsTyping(true);

      // Clear existing timeout
      if (typingTimeoutRef.current) {
        clearTimeout(typingTimeoutRef.current);
      }

      // Set new timeout to remove typing indicator
      typingTimeoutRef.current = setTimeout(() => {
        setIsTyping(false);
      }, 1000);
    } else {
      setIsTyping(false);
    }

    return () => {
      if (typingTimeoutRef.current) {
        clearTimeout(typingTimeoutRef.current);
      }
    };
  }, [value]);

  const handleChange = (e: React.ChangeEvent<HTMLTextAreaElement>) => {
    onChange(e.target.value);
  };

  return (
    <div className={`message-input-wrapper ${isTyping ? "typing" : ""}`}>
      <textarea
        ref={inputRef}
        className="message-input"
        value={value}
        onChange={handleChange}
        onKeyPress={onKeyPress}
        placeholder={placeholder}
        disabled={disabled}
        rows={1}
        style={{
          minHeight: "44px",
          maxHeight: "120px",
          resize: "none",
          overflow: "auto",
        }}
      />
    </div>
  );
};
import React, { useEffect, useRef } from "react";

interface ScrollToBottomButtonProps {
  show: boolean;
  onClick: () => void;
}

/**
 * Scroll to bottom button component
 * Follows KISS principle - simple button with single purpose
 */
export const ScrollToBottomButton: React.FC<ScrollToBottomButtonProps> = ({
  show,
  onClick,
}) => {
  const buttonRef = useRef<HTMLButtonElement>(null);

  useEffect(() => {
    const button = buttonRef.current;
    if (!button) return;

    // Handle wheel events on the button
    const handleWheel = (e: WheelEvent) => {
      // Prevent default to avoid any conflicts
      e.preventDefault();

      // Find the chat messages container
      const chatMessages = document.querySelector(".chat-messages");
      if (chatMessages) {
        // Manually scroll the chat container
        chatMessages.scrollTop += e.deltaY;
      }
    };

    // Add wheel event listener
    button.addEventListener("wheel", handleWheel, { passive: false });

    return () => {
      button.removeEventListener("wheel", handleWheel);
    };
  }, []);

  return (
    <button
      ref={buttonRef}
      className={`scroll-to-bottom-btn ${show ? "visible" : ""}`}
      onClick={onClick}
      aria-label="Scroll to bottom"
      type="button"
    >
      <svg
        width="24"
        height="24"
        viewBox="0 0 24 24"
        fill="none"
        xmlns="http://www.w3.org/2000/svg"
      >
        <defs>
          <linearGradient
            id="scrollGradient"
            x1="0%"
            y1="0%"
            x2="100%"
            y2="100%"
          >
            <stop offset="0%" stopColor="#ffffff" stopOpacity="0.9" />
            <stop offset="100%" stopColor="#ffffff" stopOpacity="0.7" />
          </linearGradient>
        </defs>
        <path
          d="M12 4v12m0 0l-6-6m6 6l6-6"
          stroke="url(#scrollGradient)"
          strokeWidth="2.5"
          strokeLinecap="round"
          strokeLinejoin="round"
        />
        <path
          d="M5 20h14"
          stroke="url(#scrollGradient)"
          strokeWidth="2.5"
          strokeLinecap="round"
        />
      </svg>
    </button>
  );
};
import React from "react";
import { useAutoScroll } from "../hooks/useAutoScroll";
import { TranscriptionDisplayProps } from "../types/ChatTypes";

/**
 * Transcription display component
 * Follows Single Responsibility Principle - only displays transcription
 */
export const TranscriptionDisplay: React.FC<TranscriptionDisplayProps> = ({
  text,
  onClear,
  transcriptions,
}) => {
  // Auto-scroll hook - observa mudanças em transcriptions ou text
  const scrollRef = useAutoScroll<HTMLDivElement>([transcriptions, text], {
    behavior: "smooth",
  });

  // Check if we should show the component
  const hasContent = transcriptions
    ? transcriptions.some((t) => !t.sent)
    : text && text.trim().length > 0;

  // Don't render anything if there's no content
  if (!hasContent) return null;

  // If we have structured transcriptions with sent status, use that
  if (transcriptions && transcriptions.length > 0) {
    // Concatenate all pending (not sent) transcriptions into a single string
    const pendingTranscriptions = transcriptions
      .filter((t) => !t.sent)
      .map((t) => t.text)
      .join(" "); // Join with space instead of newline for continuous text

    // If no pending transcriptions, don't show the component
    if (!pendingTranscriptions) return null;

    return (
      <div className="transcription-display">
        <div className="transcription-label">
          <svg width="16" height="16" viewBox="0 0 24 24" fill="none">
            <circle
              cx="12"
              cy="12"
              r="3"
              fill="currentColor"
              className="pulse-dot"
            />
            <circle
              cx="12"
              cy="12"
              r="8"
              stroke="currentColor"
              strokeWidth="1.5"
              opacity="0.5"
            />
            <circle
              cx="12"
              cy="12"
              r="11"
              stroke="currentColor"
              strokeWidth="1"
              opacity="0.3"
            />
            <path
              d="M12 3v2M12 19v2M3 12h2M19 12h2"
              stroke="currentColor"
              strokeWidth="1.5"
              opacity="0.4"
            />
          </svg>
          Live Transcription:
        </div>
        <div
          className="transcription-text transcription-scrollable"
          ref={scrollRef}
        >
          {pendingTranscriptions}
        </div>
        <button
          className="transcription-clear-btn"
          onClick={onClear}
          title="Clear transcription"
          type="button"
        >
          ×
        </button>
      </div>
    );
  }

  // Fallback to simple text display
  return (
    <div className="transcription-display">
      <div className="transcription-label">
        <svg width="16" height="16" viewBox="0 0 24 24" fill="none">
          <circle
            cx="12"
            cy="12"
            r="3"
            fill="currentColor"
            className="pulse-dot"
          />
          <circle
            cx="12"
            cy="12"
            r="8"
            stroke="currentColor"
            strokeWidth="1.5"
            opacity="0.5"
          />
          <circle
            cx="12"
            cy="12"
            r="11"
            stroke="currentColor"
            strokeWidth="1"
            opacity="0.3"
          />
          <path
            d="M12 3v2M12 19v2M3 12h2M19 12h2"
            stroke="currentColor"
            strokeWidth="1.5"
            opacity="0.4"
          />
        </svg>
        Live Transcription:
      </div>
      <div
        className="transcription-text transcription-scrollable"
        ref={scrollRef}
      >
        {text}
      </div>
      <button
        className="transcription-clear-btn"
        onClick={onClear}
        title="Clear transcription"
        type="button"
      >
        ×
      </button>
    </div>
  );
};
import { MutableRefObject, useEffect, useRef } from "react";

/**
 * Custom hook for auto-scrolling to bottom when content changes
 * Based on chat scroll pattern from https://davelage.com/posts/chat-scroll-react/
 *
 * @param deps - Dependencies that trigger scroll when changed
 * @param options - Scroll behavior options
 * @returns ref to attach to the scrollable element
 */
export function useAutoScroll<T extends HTMLElement>(
  deps: any[],
  options: ScrollToOptions = { behavior: "smooth" }
): MutableRefObject<T | null> {
  const ref = useRef<T>(null);

  useEffect(() => {
    if (ref.current) {
      // Small delay to ensure DOM is updated
      const scrollTimer = setTimeout(() => {
        if (ref.current) {
          ref.current.scrollTo({
            top: ref.current.scrollHeight,
            left: 0,
            ...options,
          });
        }
      }, 50);

      return () => clearTimeout(scrollTimer);
    }
  }, deps);

  return ref;
}

/**
 * Alternative version that uses scrollIntoView
 * Useful when you want to scroll a specific element into view
 */
export function useScrollIntoView<T extends HTMLElement>(
  deps: any[],
  alignToTop: boolean = false
): MutableRefObject<T | null> {
  const ref = useRef<T>(null);

  useEffect(() => {
    if (ref.current) {
      const scrollTimer = setTimeout(() => {
        if (ref.current) {
          ref.current.scrollIntoView(alignToTop);
        }
      }, 50);

      return () => clearTimeout(scrollTimer);
    }
  }, deps);

  return ref;
}
import { nanoid } from "nanoid";
import { useCallback, useEffect, useState } from "react";
import {
  ChatConversation,
  UseChatHistoryReturn,
} from "../types/ChatHistoryTypes";
import { migrateOldChatMessages } from "../utils/chatHistoryMigration";
import { ChatMessage } from "./usePersistentMessages";

const STORAGE_KEY = "orch-chat-history";
const MAX_TITLE_LENGTH = 50;

// Helper to generate a title from the first message
const generateTitleFromMessage = (message: string): string => {
  const cleaned = message.trim();
  if (cleaned.length <= MAX_TITLE_LENGTH) return cleaned;
  return cleaned.substring(0, MAX_TITLE_LENGTH) + "...";
};

// Helper to safely load from localStorage
const loadFromStorage = (): {
  conversations: ChatConversation[];
  currentId: string | null;
} => {
  try {
    const data = localStorage.getItem(STORAGE_KEY);
    if (data) {
      const parsed = JSON.parse(data);
      // Convert date strings back to Date objects
      const conversations = parsed.conversations.map((conv: any) => ({
        ...conv,
        lastMessageTime: new Date(conv.lastMessageTime),
        createdAt: new Date(conv.createdAt),
        messages: conv.messages.map((msg: any) => ({
          ...msg,
          timestamp: new Date(msg.timestamp),
        })),
      }));
      return { conversations, currentId: parsed.currentId };
    }
  } catch (error) {
    console.error("Error loading chat history:", error);
  }
  return { conversations: [], currentId: null };
};

// Helper to save to localStorage
const saveToStorage = (
  conversations: ChatConversation[],
  currentId: string | null
) => {
  try {
    console.log("[CHAT_HISTORY] Saving to storage:", {
      conversationCount: conversations.length,
      currentId,
      firstConvId: conversations[0]?.id,
    });
    const data = JSON.stringify({ conversations, currentId });
    localStorage.setItem(STORAGE_KEY, data);
  } catch (error) {
    console.error("Error saving chat history:", error);
  }
};

export const useChatHistory = (): UseChatHistoryReturn => {
  const [conversations, setConversations] = useState<ChatConversation[]>([]);
  const [currentConversationId, setCurrentConversationId] = useState<
    string | null
  >(null);

  // Helper to create a new conversation object - moved up before useEffect
  const createNewConversationObject = (): ChatConversation => {
    const now = new Date();
    return {
      id: nanoid(),
      title: "Nova Conversa",
      lastMessage: "",
      lastMessageTime: now,
      createdAt: now,
      messages: [],
      isActive: true,
    };
  };

  // Load from storage on mount
  useEffect(() => {
    // Try to migrate old messages first
    const migrationPerformed = migrateOldChatMessages();
    if (migrationPerformed) {
      console.log("[CHAT_HISTORY] Migration completed, reloading data...");
    }

    const { conversations: loadedConvs, currentId } = loadFromStorage();
    if (loadedConvs.length > 0) {
      setConversations(loadedConvs);
      setCurrentConversationId(currentId || loadedConvs[0].id);
    } else {
      // Create initial conversation if none exist
      const initialConv = createNewConversationObject();
      setConversations([initialConv]);
      setCurrentConversationId(initialConv.id);
    }
  }, []);

  // Save to storage whenever conversations or currentId changes
  useEffect(() => {
    if (conversations.length > 0) {
      saveToStorage(conversations, currentConversationId);
    }
  }, [conversations, currentConversationId]);

  // Create a new conversation
  const createNewConversation = useCallback((): string => {
    const newConv = createNewConversationObject();
    console.log("[CHAT_HISTORY] Creating new conversation:", newConv.id);
    setConversations((prev) => {
      // Mark all previous conversations as inactive
      const updatedPrev = prev.map((conv) => ({
        ...conv,
        isActive: false,
      }));
      return [newConv, ...updatedPrev];
    });
    setCurrentConversationId(newConv.id);
    return newConv.id;
  }, []);

  // Select a conversation
  const selectConversation = useCallback((id: string) => {
    console.log("[CHAT_HISTORY] Selecting conversation:", id);
    // Update isActive status for all conversations
    setConversations((prev) =>
      prev.map((conv) => ({
        ...conv,
        isActive: conv.id === id,
      }))
    );
    setCurrentConversationId(id);
  }, []);

  // Delete a conversation
  const deleteConversation = useCallback(
    (id: string) => {
      console.log("[CHAT_HISTORY] Deleting conversation:", id);
      setConversations((prev) => {
        const filtered = prev.filter((conv) => conv.id !== id);

        // If we're deleting the current conversation, switch to another
        if (currentConversationId === id && filtered.length > 0) {
          console.log(
            "[CHAT_HISTORY] Switching to conversation:",
            filtered[0].id
          );
          setCurrentConversationId(filtered[0].id);
        } else if (filtered.length === 0) {
          // If no conversations left, create a new one
          const newConv = createNewConversationObject();
          console.log(
            "[CHAT_HISTORY] No conversations left, creating new:",
            newConv.id
          );
          setCurrentConversationId(newConv.id);
          return [newConv];
        }

        return filtered;
      });
    },
    [currentConversationId]
  );

  // Update conversation title
  const updateConversationTitle = useCallback((id: string, title: string) => {
    setConversations((prev) =>
      prev.map((conv) => (conv.id === id ? { ...conv, title } : conv))
    );
  }, []);

  // Add message to a conversation
  const addMessageToConversation = useCallback(
    (conversationId: string, message: ChatMessage) => {
      setConversations((prev) =>
        prev.map((conv) => {
          if (conv.id === conversationId) {
            const updatedMessages = [...conv.messages, message];
            const isFirstUserMessage =
              message.type === "user" &&
              conv.title === "Nova Conversa" &&
              updatedMessages.filter((m) => m.type === "user").length === 1;

            return {
              ...conv,
              messages: updatedMessages,
              lastMessage: message.content,
              lastMessageTime: message.timestamp,
              // Auto-generate title from first user message
              title: isFirstUserMessage
                ? generateTitleFromMessage(message.content)
                : conv.title,
            };
          }
          return conv;
        })
      );
    },
    []
  );

  // Search conversations
  const searchConversations = useCallback(
    (query: string): ChatConversation[] => {
      const lowerQuery = query.toLowerCase();
      return conversations.filter(
        (conv) =>
          conv.title.toLowerCase().includes(lowerQuery) ||
          conv.messages.some((msg) =>
            msg.content.toLowerCase().includes(lowerQuery)
          )
      );
    },
    [conversations]
  );

  // Clear messages from a conversation
  const clearConversationMessages = useCallback((conversationId: string) => {
    setConversations((prev) =>
      prev.map((conv) => {
        if (conv.id === conversationId) {
          return {
            ...conv,
            messages: [],
            lastMessage: "",
            lastMessageTime: new Date(),
          };
        }
        return conv;
      })
    );
  }, []);

  // Get current conversation
  const currentConversation =
    conversations.find((conv) => conv.id === currentConversationId) || null;

  return {
    conversations,
    currentConversation,
    currentConversationId,
    createNewConversation,
    selectConversation,
    deleteConversation,
    updateConversationTitle,
    addMessageToConversation,
    searchConversations,
    clearConversationMessages,
  };
};
import { useCallback, useEffect, useRef, useState } from "react";
import { ChatMessage } from "../types/ChatTypes";

interface UseChatScrollProps {
  messages: ChatMessage[];
  messagesContainerRef: React.RefObject<HTMLDivElement>;
}

/**
 * Custom hook to manage chat scroll behavior
 * Follows SOLID principle - Single responsibility for scroll management
 */
export const useChatScroll = ({
  messages,
  messagesContainerRef,
}: UseChatScrollProps) => {
  const isUserScrollingRef = useRef(false);
  const programmaticScrollRef = useRef(false);
  const userScrollTimeoutRef = useRef<NodeJS.Timeout | null>(null);
  const hasInitialScrolledRef = useRef(false);

  // State to track if scroll button should be shown
  const [showScrollButton, setShowScrollButton] = useState(false);

  /**
   * Scroll to bottom of messages
   * DRY principle - reusable scroll logic
   */
  const scrollToBottom = useCallback(
    (smooth = true) => {
      if (!messagesContainerRef.current) return;

      // Set programmatic scroll flag
      programmaticScrollRef.current = true;

      // Scroll the messages container to absolute bottom
      const container = messagesContainerRef.current;
      container.scrollTop = container.scrollHeight;

      // Reset programmatic scroll flag after animation
      setTimeout(
        () => {
          programmaticScrollRef.current = false;
        },
        smooth ? 500 : 100
      );
    },
    [messagesContainerRef]
  );

  /**
   * Check if user is at bottom of scroll
   * KISS principle - simple bottom detection
   */
  const isAtBottom = useCallback(() => {
    if (!messagesContainerRef.current) return true;

    const { scrollTop, scrollHeight, clientHeight } =
      messagesContainerRef.current;
    // Reduced threshold for more accurate detection
    return scrollHeight - scrollTop - clientHeight < 5;
  }, [messagesContainerRef]);

  /**
   * Handle scroll events to detect manual scrolling
   */
  const handleScroll = useCallback(() => {
    if (!messagesContainerRef.current) return;

    // Check if at bottom and update button visibility
    const atBottom = isAtBottom();
    setShowScrollButton(!atBottom);

    // Skip if this is a programmatic scroll
    if (programmaticScrollRef.current) return;

    if (!atBottom && !isUserScrollingRef.current) {
      // User started scrolling up
      isUserScrollingRef.current = true;

      // Clear any existing timeout
      if (userScrollTimeoutRef.current) {
        clearTimeout(userScrollTimeoutRef.current);
      }

      // Set timeout to re-enable auto-scroll after 3 seconds
      userScrollTimeoutRef.current = setTimeout(() => {
        isUserScrollingRef.current = false;
      }, 3000);
    } else if (atBottom && isUserScrollingRef.current) {
      // User scrolled back to bottom
      isUserScrollingRef.current = false;

      // Clear the timeout since user is back at bottom
      if (userScrollTimeoutRef.current) {
        clearTimeout(userScrollTimeoutRef.current);
        userScrollTimeoutRef.current = null;
      }
    }
  }, [isAtBottom, messagesContainerRef]);

  /**
   * Initial scroll to bottom on mount
   */
  useEffect(() => {
    if (!hasInitialScrolledRef.current && messages.length > 0) {
      // Use instant scroll for initial load
      scrollToBottom(false);
      hasInitialScrolledRef.current = true;
    }
  }, [messages.length, scrollToBottom]);

  /**
   * Auto-scroll when new messages arrive (if user hasn't scrolled up)
   */
  useEffect(() => {
    if (messages.length > 0 && !isUserScrollingRef.current) {
      scrollToBottom();
    }
  }, [messages, scrollToBottom]);

  /**
   * Setup scroll event listener
   */
  useEffect(() => {
    const container = messagesContainerRef.current;
    if (!container) return;

    container.addEventListener("scroll", handleScroll, { passive: true });

    // Check initial scroll position
    const atBottom = isAtBottom();
    setShowScrollButton(!atBottom);

    return () => {
      container.removeEventListener("scroll", handleScroll);

      // Cleanup timeouts
      if (userScrollTimeoutRef.current) {
        clearTimeout(userScrollTimeoutRef.current);
      }
    };
  }, [handleScroll, messagesContainerRef, isAtBottom]);

  return {
    scrollToBottom,
    isAtBottom,
    showScrollButton,
  };
};
import { useRef, useState } from "react";
import { ChatState } from "../types/ChatTypes";

/**
 * Custom hook for managing chat state
 * Follows Single Responsibility Principle - only manages chat state
 */
export const useChatState = (): ChatState & {
  resetState: () => void;
} => {
  const [inputMessage, setInputMessage] = useState("");
  const [currentContext, setCurrentContext] = useState("");
  const [showContextField, setShowContextField] = useState(false);
  const [isProcessing, setIsProcessing] = useState(false);

  const processingTimeoutRef = useRef<NodeJS.Timeout | null>(null);

  const resetState = () => {
    setInputMessage("");
    setCurrentContext("");
    setShowContextField(false);
    setIsProcessing(false);
    if (processingTimeoutRef.current) {
      clearTimeout(processingTimeoutRef.current);
      processingTimeoutRef.current = null;
    }
  };

  return {
    inputMessage,
    setInputMessage,
    currentContext,
    setCurrentContext,
    showContextField,
    setShowContextField,
    isProcessing,
    setIsProcessing,
    processingTimeoutRef,
    resetState,
  };
};
import { useCallback, useEffect } from "react";
import { ChatConversation } from "../types/ChatHistoryTypes";
import { ChatMessage } from "./usePersistentMessages";

interface AddMessageParams {
  type: "user" | "system" | "error";
  content: string;
  hasContext?: boolean;
  contextContent?: string;
}

interface UseConversationMessagesReturn {
  messages: ChatMessage[];
  addMessage: (params: AddMessageParams) => void;
  clearMessages: () => void;
}

interface UseConversationMessagesProps {
  currentConversation: ChatConversation | null;
  onAddMessage: (conversationId: string, message: ChatMessage) => void;
  onClearConversation: (conversationId: string) => void;
}

export const useConversationMessages = ({
  currentConversation,
  onAddMessage,
  onClearConversation,
}: UseConversationMessagesProps): UseConversationMessagesReturn => {
  // Get messages from current conversation
  const messages = currentConversation?.messages || [];

  // Add message to current conversation
  const addMessage = useCallback(
    (params: AddMessageParams) => {
      if (!currentConversation) return;

      const newMessage: ChatMessage = {
        id: `${currentConversation.id}-${Date.now()}-${Math.random()}`,
        timestamp: new Date(),
        ...params,
      };

      onAddMessage(currentConversation.id, newMessage);
    },
    [currentConversation, onAddMessage]
  );

  // Clear messages from current conversation
  const clearMessages = useCallback(() => {
    if (!currentConversation) return;

    if (onClearConversation) {
      onClearConversation(currentConversation.id);
    }
  }, [currentConversation, onClearConversation]);

  // Log conversation changes for debugging
  useEffect(() => {
    if (currentConversation) {
      console.log(`[CONVERSATION] Switched to conversation:`, {
        id: currentConversation.id,
        title: currentConversation.title,
        messageCount: messages.length,
      });
    } else {
      console.log(`[CONVERSATION] No current conversation`);
    }
  }, [currentConversation?.id, messages.length]);

  return {
    messages,
    addMessage,
    clearMessages,
  };
};
import { nanoid } from "nanoid";
import { useCallback, useEffect, useRef, useState } from "react";

export interface ChatMessage {
  id: string;
  type: "user" | "system" | "error";
  content: string;
  timestamp: Date;
  hasContext?: boolean;
  contextContent?: string;
}

interface AddMessageParams {
  type: "user" | "system" | "error";
  content: string;
  hasContext?: boolean;
  contextContent?: string;
}

interface UsePersistentMessagesReturn {
  messages: ChatMessage[];
  addMessage: (params: AddMessageParams) => void;
  clearMessages: () => void;
  recovery: {
    hasBackup: boolean;
    restoreFromBackup: () => void;
    clearBackup: () => void;
    integrityCheck: () => boolean;
    lastSaveTime: number;
  };
}

const STORAGE_KEY = "orch-chat-messages";
const BACKUP_KEY = "orch-chat-backup";
const REDUNDANT_KEY = "orch-chat-redundant";
const COMPONENT_ID_KEY = "orch-chat-component-id";

// Enhanced logging with detailed timestamps
const logWithDetails = (level: string, message: string, data?: any) => {
  const timestamp = new Date().toISOString();
  const logData = {
    timestamp,
    level,
    message,
    data,
  };

  console.log(`${level} [PERSISTENT_MESSAGES] ${message}`, logData);

  // Store critical logs in localStorage for debugging
  try {
    const logs = JSON.parse(localStorage.getItem("orch-chat-logs") || "[]");
    logs.push(logData);
    if (logs.length > 50) logs.splice(0, logs.length - 50);
    localStorage.setItem("orch-chat-logs", JSON.stringify(logs));
  } catch (e) {
    // Ignore logging errors
  }
};

// Helper function to safely parse and restore messages from a storage key
const loadMessagesFromKey = (key: string, logLabel: string): ChatMessage[] => {
  try {
    const data = localStorage.getItem(key);
    if (data) {
      const parsed = JSON.parse(data);
      const messagesArray = Array.isArray(parsed) ? parsed : parsed.messages;
      if (Array.isArray(messagesArray) && messagesArray.length > 0) {
        logWithDetails("💾", `Loaded ${messagesArray.length} messages from ${logLabel}`);
        return messagesArray.map((m: any) => ({ ...m, timestamp: new Date(m.timestamp) }));
      }
    }
  } catch (error) {
    logWithDetails("❌", `Error loading from ${logLabel}`, { key, error });
  }
  return [];
};

export const usePersistentMessages = (): UsePersistentMessagesReturn => {
  const componentId = useRef<string>(nanoid());

  const [messages, setMessages] = useState<ChatMessage[]>(() => {
    logWithDetails("🚀", "Initializing persistent messages state (lazy)");
    let initialMessages = loadMessagesFromKey(STORAGE_KEY, "primary storage");
    if (initialMessages.length > 0) return initialMessages;

    initialMessages = loadMessagesFromKey(BACKUP_KEY, "backup storage");
    if (initialMessages.length > 0) {
      localStorage.setItem(STORAGE_KEY, JSON.stringify(initialMessages));
      return initialMessages;
    }
    
    initialMessages = loadMessagesFromKey(REDUNDANT_KEY, "redundant storage");
    if (initialMessages.length > 0) {
        localStorage.setItem(STORAGE_KEY, JSON.stringify(initialMessages));
        return initialMessages;
    }

    logWithDetails("ℹ️", "No messages found in any storage for lazy init");
    return [];
  });

  const [lastSaveTime, setLastSaveTime] = useState<number>(0);

  useEffect(() => {
    logWithDetails("✅", "Persistent messages hook mounted", {
      componentId: componentId.current,
      initialMessageCount: messages.length,
    });
    try {
      localStorage.setItem(COMPONENT_ID_KEY, componentId.current);
    } catch (error) {
      logWithDetails("❌", "Error setting component ID", error);
    }
  }, []);

  const saveToStorage = useCallback((currentMessages: ChatMessage[]) => {
    try {
      const dataToSave = JSON.stringify(currentMessages);
      localStorage.setItem(STORAGE_KEY, dataToSave);
      
      const backupData = JSON.stringify({
        timestamp: Date.now(),
        count: currentMessages.length,
        messages: currentMessages,
      });
      localStorage.setItem(BACKUP_KEY, backupData);
      localStorage.setItem(REDUNDANT_KEY, dataToSave);

      setLastSaveTime(Date.now());
    } catch (error) {
      logWithDetails("❌", "Error saving messages to storage", error);
    }
  }, []);

  const debouncedSave = useRef(
    ((callback: (msgs: ChatMessage[]) => void, delay: number) => {
      let timeout: NodeJS.Timeout;
      return (msgs: ChatMessage[]) => {
        clearTimeout(timeout);
        timeout = setTimeout(() => callback(msgs), delay);
      };
    })(saveToStorage, 500)
  ).current;

  useEffect(() => {
    debouncedSave(messages);
  }, [messages, debouncedSave]);

  const addMessage = useCallback(
    (params: AddMessageParams) => {
      const newMessage: ChatMessage = {
        id: nanoid(),
        timestamp: new Date(),
        ...params,
      };
      setMessages((prevMessages) => [...prevMessages, newMessage]);
    },
    []
  );

  const clearMessages = useCallback(() => {
    logWithDetails("🗑️", "Clearing all messages");
    setMessages([]);
    try {
      localStorage.removeItem(STORAGE_KEY);
      localStorage.removeItem(BACKUP_KEY);
      localStorage.removeItem(REDUNDANT_KEY);
    } catch (error) {
      logWithDetails("❌", "Error clearing storage", error);
    }
  }, []);

  const hasBackup = useCallback(() => {
    try {
      return !!(localStorage.getItem(BACKUP_KEY) || localStorage.getItem(REDUNDANT_KEY));
    } catch {
      return false;
    }
  }, []);

  const restoreFromBackup = useCallback(() => {
    logWithDetails("🔄", "Manual restore requested");
    const backupMessages = loadMessagesFromKey(BACKUP_KEY, "manual backup restore");
    if (backupMessages.length > 0) {
      setMessages(backupMessages);
      logWithDetails("✅", "Manual restore completed", { recoveredCount: backupMessages.length });
      return true;
    }

    const redundantMessages = loadMessagesFromKey(REDUNDANT_KEY, "manual redundant restore");
    if (redundantMessages.length > 0) {
        setMessages(redundantMessages);
        logWithDetails("✅", "Manual restore completed", { recoveredCount: redundantMessages.length });
        return true;
    }

    logWithDetails("⚠️", "No backup data found for manual restore");
    return false;
  }, []);

  const clearBackup = useCallback(() => {
    try {
      localStorage.removeItem(BACKUP_KEY);
      localStorage.removeItem(REDUNDANT_KEY);
      logWithDetails("🗑️", "Backup cleared");
    } catch (error) {
      logWithDetails("❌", "Error clearing backup", error);
    }
  }, []);
  
  const performIntegrityCheck = useCallback(() => {
      try {
        const primaryCount = (loadMessagesFromKey(STORAGE_KEY, "integrity check")).length;
        const backupCount = (loadMessagesFromKey(BACKUP_KEY, "integrity check")).length;
        const isHealthy = primaryCount >= backupCount;
        logWithDetails("🩺", "Performed integrity check", { isHealthy, primaryCount, backupCount });
        return isHealthy;
      } catch (e) {
        return false;
      }
  }, []);

  return {
    messages,
    addMessage,
    clearMessages,
    recovery: {
      hasBackup: hasBackup(),
      restoreFromBackup,
      clearBackup,
      integrityCheck: performIntegrityCheck,
      lastSaveTime,
    },
  };
};
/* ================================================================
 * ANIMATIONS - Keyframes & Transitions
 * ================================================================
 * Contains all animation definitions, keyframes, and transition
 * effects used throughout the chat interface
 */

/* ===== KEYFRAME ANIMATIONS ===== */

/* Message Animation */
@keyframes messageSlideIn {
  from {
    opacity: 0;
    transform: translateY(10px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
}

@keyframes messageAppear {
  from {
    opacity: 0;
    transform: translateY(10px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
}

/* Context Input Slide Down */
@keyframes slideDown {
  from {
    opacity: 0;
    transform: translateY(-10px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
}

/* Microphone Recording Pulse */
@keyframes pulse {
  0% {
    box-shadow: 0 0 0 0 rgba(255, 68, 85, 0.4);
  }
  70% {
    box-shadow: 0 0 0 10px rgba(255, 68, 85, 0);
  }
  100% {
    box-shadow: 0 0 0 0 rgba(255, 68, 85, 0);
  }
}

/* Settings Popup Slide In */
@keyframes popupSlideIn {
  from {
    opacity: 0;
    transform: translateY(-10px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
}

/* Typing Indicator Animation */
@keyframes typingDot {
  0%,
  60%,
  100% {
    transform: scale(1);
    opacity: 0.5;
  }
  30% {
    transform: scale(1.2);
    opacity: 1;
  }
}

/* Neural Quantum Scroll Button Animations */
@keyframes fadeInScale {
  from {
    opacity: 0;
    transform: scale(0.8);
  }
  to {
    opacity: 1;
    transform: scale(1);
  }
}

@keyframes neuralPulse {
  0%,
  100% {
    transform: scale(1) translateY(0);
    box-shadow: 
      0 0 16px rgba(0, 250, 255, 0.4),
      0 6px 20px rgba(0, 0, 0, 0.25),
      inset 0 0 12px rgba(255, 255, 255, 0.1);
  }
  50% {
    transform: scale(1.02) translateY(-0.5px); /* Pulsação mais sutil */
    box-shadow: 
      0 0 24px rgba(0, 250, 255, 0.5),
      0 8px 24px rgba(0, 0, 0, 0.3),
      inset 0 0 16px rgba(255, 255, 255, 0.12);
  }
}

@keyframes pulseScale {
  0% {
    transform: scale(0);
    opacity: 0;
  }
  50% {
    transform: scale(1.2);
    opacity: 1;
  }
  100% {
    transform: scale(1);
    opacity: 1;
  }
}

/* ===== APPLIED ANIMATIONS ===== */

/* Message Animation Application */
.message {
  animation: messageSlideIn 0.3s ease-out;
}

/* Context Input Animation */
.context-input-wrapper {
  animation: slideDown 0.3s ease-out;
}

/* Transcription Display Animation */
.transcription-display {
  animation: slideDown 0.3s ease-out;
}

/* Settings Popup Animation */
.settings-popup {
  animation: popupSlideIn 0.2s ease-out;
}

/* Microphone Recording Animation */
.mic-btn.recording {
  animation: pulse 1.5s infinite;
}

/* Typing Animation Application */
.typing-animation span {
  animation: typingDot 1.4s infinite ease-in-out;
}

.typing-animation span:nth-child(1) {
  animation-delay: 0s;
}

.typing-animation span:nth-child(2) {
  animation-delay: 0.2s;
}

.typing-animation span:nth-child(3) {
  animation-delay: 0.4s;
}

/* ===== REDUCED MOTION SUPPORT ===== */
@media (prefers-reduced-motion: reduce) {
  /* Disable animations for users who prefer reduced motion */
  .message,
  .context-input-wrapper,
  .transcription-display,
  .settings-popup {
    animation: none !important;
  }
  
  .mic-btn.recording {
    animation: none !important;
  }
  
  .typing-animation span {
    animation: none !important;
  }
  
  /* Keep only opacity transitions for reduced motion */
  .message,
  .context-input-wrapper,
  .transcription-display {
    transition: opacity 0.2s ease !important;
  }
} /* ================================================================
 * BASE STYLES - Core Layout & Containers
 * ================================================================
 * Contém a estrutura de layout definitiva para o chat.
 * Esta abordagem usa uma cadeia de flexbox para garantir que
 * a área de mensagens ocupe o espaço correto.
 */

/* Container principal do chat */
.conversational-chat {
  display: flex;
  flex-direction: column;
  height: 100%;
  width: 100%;
  overflow: hidden;
  position: relative;
  /* Isolamento do background do painel */
  isolation: isolate;
  /* Background sólido para evitar vazamentos */
  background: #0a0f1a;
}

/* Nível 1: Container de Mensagens (Filho do .conversational-chat) */
.chat-messages-container {
  flex: 1; /* ESSENCIAL: Faz este container crescer e ocupar o espaço disponível */
  min-height: 0; /* PREVENÇÃO DE BUG FLEXBOX: Impede que o container exceda o pai */
  position: relative; /* Contexto para o botão absoluto */
  display: flex; /* Cria um novo contexto flex para seu filho */
  flex-direction: column;
  overflow: hidden; /* IMPORTANTE: Contém o overflow no container */
}

/* Nível 2: A Área de Scroll (Filho do .chat-messages-container) */
.chat-messages {
  flex: 1; /* ESSENCIAL: Faz a área de scroll preencher o .chat-messages-container */
  min-height: 0; /* PREVENÇÃO DE BUG FLEXBOX */
  height: 0; /* TRUQUE: Força o container a respeitar o flex: 1 */
  overflow-y: auto;
  overflow-x: hidden;
  padding: 16px 12px 32px 12px; /* Aumentado padding-bottom para garantir espaço de scroll */
  display: flex;
  flex-direction: column;
  scroll-behavior: smooth;
}

/* Pseudo-elemento para garantir espaço extra de scroll */
.chat-messages::after {
  content: "";
  display: block;
  height: 2px;
  min-height: 2px;
  visibility: hidden;
  flex-shrink: 0;
}

/* Nível 3: O Wrapper das Mensagens */
.messages-wrapper {
  display: flex;
  flex-direction: column;
  gap: 16px;
  width: 100%;
  margin-top: auto;
}

/* Scrollbar Styling */
.chat-messages::-webkit-scrollbar {
  width: 6px;
}

.chat-messages::-webkit-scrollbar-track {
  background: rgba(0, 0, 0, 0.2);
  border-radius: 3px;
}

.chat-messages::-webkit-scrollbar-thumb {
  background: linear-gradient(135deg, #00faff 0%, #7c4dff 100%);
  border-radius: 3px;
}

/* Welcome Message */
.welcome-message {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  text-align: center;
  padding: 40px 20px;
  color: rgba(255, 255, 255, 0.7);
  width: 100%;
  /* flex-grow permite que ele ocupe o espaço vertical quando for o único elemento */
  flex-grow: 1;
}

.welcome-icon {
  margin-bottom: 20px;
  opacity: 0.8;
}

.welcome-message h3 {
  font-size: 24px;
  font-weight: 600;
  margin-bottom: 12px;
  background: linear-gradient(135deg, #00faff 0%, #7c4dff 100%);
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
  background-clip: text;
}

.welcome-message p {
  font-size: 16px;
  line-height: 1.5;
  opacity: 0.8;
}

/* Debug button styles removed for cleaner UI */ /* ================================================================
 * COMPONENT STYLES - Unique UI Elements
 * ================================================================
 * Contains styles for specialized components like scroll buttons
 * and other unique interface elements
 */

/* ===== SCROLL TO BOTTOM BUTTON - Quantum Neural Design ===== */

/* Botão de scroll direto sem wrapper */
.scroll-to-bottom-btn {
  /* Posicionamento */
  position: absolute;
  bottom: 24px;
  right: 24px;
  z-index: 15;
  
  /* Dimensões */
  width: 48px;
  height: 48px;
  border-radius: 50%;
  
  /* Layout */
  display: flex;
  align-items: center;
  justify-content: center;
  cursor: pointer;
  
  /* Remove default button styles and focus */
  outline: none;
  -webkit-tap-highlight-color: transparent;
  -webkit-focus-ring-color: transparent;
  
  /* Quantum glass effect with enhanced glow */
  background: linear-gradient(
    135deg, 
    rgba(0, 250, 255, 0.95) 0%, 
    rgba(124, 77, 255, 0.85) 100%
  );
  
  /* Neural border with glow */
  border: 2px solid rgba(255, 255, 255, 0.2);
  
  /* Multi-layer shadow for depth */
  box-shadow: 
    /* Outer glow */
    0 0 20px rgba(0, 250, 255, 0.4),
    /* Drop shadow */
    0 4px 15px rgba(0, 0, 0, 0.3),
    /* Inner light */
    inset 0 0 15px rgba(255, 255, 255, 0.1);
  
  /* Backdrop filter for glass effect */
  -webkit-backdrop-filter: blur(10px) saturate(150%); /* Safari support */
  backdrop-filter: blur(10px) saturate(150%);
  
  /* Smooth transitions */
  transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
  
  /* Estado inicial oculto */
  opacity: 0;
  transform: scale(0.8) translateY(10px);
  pointer-events: none;
}

/* Estado visível */
.scroll-to-bottom-btn.visible {
  opacity: 1;
  transform: scale(1) translateY(0);
  pointer-events: auto;
}

/* Hover state - enhanced glow and slight scale */
.scroll-to-bottom-btn:hover {
  transform: scale(1.05);
  box-shadow: 
    0 0 30px rgba(0, 250, 255, 0.6),
    0 6px 20px rgba(0, 0, 0, 0.4),
    inset 0 0 20px rgba(255, 255, 255, 0.2);
  
  /* Brighten background slightly */
  background: linear-gradient(
    135deg, 
    rgba(0, 250, 255, 1) 0%, 
    rgba(124, 77, 255, 0.9) 100%
  );
}

/* Active/Pressed state */
.scroll-to-bottom-btn:active,
.scroll-to-bottom-btn.pressed {
  transform: scale(0.95);
  box-shadow: 
    0 0 15px rgba(0, 250, 255, 0.3),
    0 2px 10px rgba(0, 0, 0, 0.3),
    inset 0 0 10px rgba(0, 0, 0, 0.2);
}

/* Focus state - remove outline */
.scroll-to-bottom-btn:focus {
  outline: none;
}

/* Focus visible - para acessibilidade via teclado */
.scroll-to-bottom-btn:focus-visible {
  outline: none;
  box-shadow: 
    0 0 0 3px rgba(0, 250, 255, 0.5),
    0 0 30px rgba(0, 250, 255, 0.6),
    0 6px 20px rgba(0, 0, 0, 0.4);
}

/* Icon styling within button */
.scroll-to-bottom-btn svg {
  width: 24px;
  height: 24px;
  filter: drop-shadow(0 1px 2px rgba(0, 0, 0, 0.2));
}

/* Pulse animation for attention */
@keyframes scrollButtonPulse {
  0% {
    box-shadow: 
      0 0 20px rgba(0, 250, 255, 0.4),
      0 4px 15px rgba(0, 0, 0, 0.3);
  }
  50% {
    box-shadow: 
      0 0 35px rgba(0, 250, 255, 0.6),
      0 4px 15px rgba(0, 0, 0, 0.3);
  }
  100% {
    box-shadow: 
      0 0 20px rgba(0, 250, 255, 0.4),
      0 4px 15px rgba(0, 0, 0, 0.3);
  }
}

/* Apply pulse animation when needed */
.scroll-to-bottom-btn.pulse {
  animation: scrollButtonPulse 2s ease-in-out infinite;
}

/* ===== NEW MESSAGE BADGE - Otimizado para FAB 48px ===== */
.scroll-to-bottom-btn .new-messages-badge {
  position: absolute;
  top: -6px;
  right: -6px;
  background-color: #ff4757;
  color: white;
  border-radius: 50%;
  width: 18px;    /* Menor para proporção com botão 48px */
  height: 18px;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 9px;  /* Fonte menor */
  font-weight: bold;
  font-family: Inter, sans-serif;
  border: 2px solid rgba(255, 255, 255, 0.3);
  box-shadow: 0 2px 6px rgba(255, 71, 87, 0.4);
  animation: pulseScale 0.5s ease-out;
  z-index: 20;
}

/* ===== REDUCED MOTION SUPPORT ===== */
@media (prefers-reduced-motion: reduce) {
  .scroll-to-bottom-btn {
    animation: none !important;
    transition: opacity 0.2s ease !important;
  }

  @keyframes neuralPulse {
    0%,
    100% {
      opacity: 1;
    }
  }
} /* ================================================================
 * INPUT STYLES - Chat Input Area & Controls
 * ================================================================
 * Contains all styles related to the chat input area,
 * context input, transcription display, and input controls
 */

/* Input Area - ALTURA FIXA */
.chat-input-area {
  flex-shrink: 0; /* Não encolhe */
  border-top: 1px solid rgba(0, 250, 255, 0.2);
  background: rgba(0, 0, 0, 0.3);
  -webkit-backdrop-filter: blur(10px);
  backdrop-filter: blur(10px);
}

/* Context Input */
.context-input-wrapper {
  background: rgba(0, 250, 255, 0.08);
  -webkit-backdrop-filter: blur(12px);
  backdrop-filter: blur(12px);
  border: 1px solid rgba(0, 250, 255, 0.2);
  border-radius: 16px;
  padding: 16px 20px;
  margin-bottom: 16px;
  position: relative;
  box-shadow: 
    0 8px 32px rgba(0, 250, 255, 0.1),
    inset 0 1px 0 rgba(255, 255, 255, 0.1);
  transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
}

.context-label {
  display: flex;
  align-items: center;
  justify-content: space-between;
  gap: 8px;
  color: #00faff;
  font-size: 14px;
  font-weight: 500;
  margin-bottom: 8px;
}

.context-close-btn {
  background: none;
  border: none;
  color: #ff4455;
  font-size: 18px;
  font-weight: bold;
  cursor: pointer;
  padding: 0;
  width: 20px;
  height: 20px;
  display: flex;
  align-items: center;
  justify-content: center;
  border-radius: 50%;
  transition: all 0.2s ease;
}

.context-close-btn:hover {
  background: rgba(255, 68, 85, 0.2);
  transform: scale(1.1);
}

.context-input {
  background: transparent;
  border: none;
  color: rgba(255, 255, 255, 0.9);
  font-size: 14px;
  line-height: 1.6;
  outline: none;
  padding: 0;
  width: 100%;
  min-height: 60px;
  resize: none;
  font-family: inherit;
}

.context-input::placeholder {
  color: rgba(255, 255, 255, 0.4);
}

/* Main Input Area */
.main-input-wrapper {
  padding: 16px 24px 20px 24px; /* Increased padding for better breathing room */
  background: linear-gradient(
    180deg,
    rgba(0, 0, 0, 0.2) 0%,
    rgba(0, 0, 0, 0.4) 100%
  );
  position: relative;
}

/* Subtle glow effect for depth */
.main-input-wrapper::before {
  content: '';
  position: absolute;
  bottom: 0;
  left: 50%;
  transform: translateX(-50%);
  width: 80%;
  height: 1px;
  background: linear-gradient(
    90deg,
    transparent 0%,
    rgba(0, 250, 255, 0.5) 50%,
    transparent 100%
  );
  opacity: 0.8;
}

.input-row {
  display: flex;
  flex-direction: column;
  gap: 16px; /* Increased gap for better separation */
}

/* Input bottom row - Enhanced layout */
.input-bottom-row {
  display: flex;
  align-items: center;
  gap: 12px; /* Add gap between input and controls */
  position: relative;
}

/* Transcription Display - Modern glassmorphism */
.transcription-display {
  background: rgba(0, 250, 255, 0.08);
  -webkit-backdrop-filter: blur(12px);
  backdrop-filter: blur(12px);
  border: 1px solid rgba(0, 250, 255, 0.2);
  border-radius: 16px;
  padding: 16px 20px;
  position: relative;
  max-height: 120px;
  overflow: hidden;
  box-shadow: 
    0 8px 32px rgba(0, 250, 255, 0.1),
    inset 0 1px 0 rgba(255, 255, 255, 0.1);
  transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
}

.transcription-display:hover {
  border-color: rgba(0, 250, 255, 0.3);
  box-shadow: 
    0 12px 40px rgba(0, 250, 255, 0.15),
    inset 0 1px 0 rgba(255, 255, 255, 0.15);
}

.transcription-label {
  display: flex;
  align-items: center;
  gap: 10px;
  color: #00faff;
  font-size: 11px;
  font-weight: 700;
  margin-bottom: 10px;
  text-transform: uppercase;
  letter-spacing: 1.2px;
  opacity: 0.9;
}

.transcription-label svg {
  width: 18px;
  height: 18px;
  animation: pulse 2s cubic-bezier(0.4, 0, 0.6, 1) infinite;
}

.transcription-text {
  color: #ffffff;
  font-size: 14px;
  line-height: 1.6;
  padding-right: 32px;
  max-height: 80px;
  overflow-y: auto;
  overflow-x: hidden;
}

.transcription-clear-btn {
  position: absolute;
  top: 12px;
  right: 12px;
  background: rgba(255, 68, 85, 0.1);
  border: 1px solid rgba(255, 68, 85, 0.3);
  color: #ff4455;
  font-size: 14px;
  font-weight: 600;
  cursor: pointer;
  padding: 0;
  width: 28px;
  height: 28px;
  display: flex;
  align-items: center;
  justify-content: center;
  border-radius: 8px;
  transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
}

.transcription-clear-btn:hover {
  background: rgba(255, 68, 85, 0.2);
  border-color: rgba(255, 68, 85, 0.5);
  transform: scale(1.05);
}

/* Message Input */
.message-input-wrapper {
  flex: 1;
  background: rgba(0, 0, 0, 0.3);
  -webkit-backdrop-filter: blur(20px);
  backdrop-filter: blur(20px);
  border: 1px solid rgba(0, 250, 255, 0.2);
  border-radius: 20px;
  padding: 0 20px;
  transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
  position: relative;
  overflow: hidden;
  min-height: 52px;
  box-shadow: 
    0 4px 24px rgba(0, 0, 0, 0.2),
    inset 0 1px 0 rgba(255, 255, 255, 0.05);
}

/* Animated border glow effect */
.message-input-wrapper::before {
  content: '';
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: linear-gradient(
    45deg,
    transparent 30%,
    rgba(0, 250, 255, 0.1) 50%,
    transparent 70%
  );
  transform: translateX(-100%);
  transition: transform 0.6s;
}

.message-input-wrapper:focus-within::before {
  transform: translateX(100%);
}

.message-input-wrapper:focus-within {
  border-color: rgba(0, 250, 255, 0.4);
  box-shadow: 
    0 0 0 3px rgba(0, 250, 255, 0.1),
    0 4px 24px rgba(0, 0, 0, 0.3),
    0 0 40px rgba(0, 250, 255, 0.1),
    inset 0 1px 0 rgba(255, 255, 255, 0.1);
  background: rgba(0, 0, 0, 0.4);
}

/* Message Input - Clean and modern */
.message-input {
  background: transparent;
  border: none;
  color: rgba(255, 255, 255, 0.95);
  font-size: 15px;
  outline: none;
  padding: 14px 0;
  line-height: 1.6;
  font-family: inherit;
  width: 100%;
  transition: color 0.2s ease;
}

.message-input::placeholder {
  color: rgba(255, 255, 255, 0.35);
  transition: color 0.2s ease;
}

.message-input:focus::placeholder {
  color: rgba(255, 255, 255, 0.25);
}

/* Typing indicator animation */
.message-input-wrapper.typing {
  animation: typingPulse 1.5s ease-in-out infinite;
}

@keyframes typingPulse {
  0%, 100% {
    box-shadow: 
      0 4px 24px rgba(0, 0, 0, 0.2),
      inset 0 1px 0 rgba(255, 255, 255, 0.05);
  }
  50% {
    box-shadow: 
      0 4px 24px rgba(0, 250, 255, 0.1),
      inset 0 1px 0 rgba(255, 255, 255, 0.1);
  }
}

/* Input Controls - Modern button design */
.input-controls {
  display: flex;
  align-items: center;
  gap: 8px;
  flex-shrink: 0;
}

/* Control Buttons - Futuristic design */
.control-btn {
  background: rgba(0, 0, 0, 0.3);
  -webkit-backdrop-filter: blur(10px);
  backdrop-filter: blur(10px);
  border: 1px solid rgba(0, 250, 255, 0.2);
  border-radius: 14px;
  width: 44px;
  height: 44px;
  display: flex;
  align-items: center;
  justify-content: center;
  cursor: pointer;
  transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
  position: relative;
  overflow: hidden;
}

.control-btn svg {
  width: 22px;
  height: 22px;
  color: rgba(255, 255, 255, 0.7);
  transition: all 0.2s ease;
  z-index: 1;
}

.control-btn:hover {
  background: rgba(0, 250, 255, 0.1);
  border-color: rgba(0, 250, 255, 0.4);
  transform: translateY(-1px);
  box-shadow: 
    0 4px 20px rgba(0, 250, 255, 0.2),
    0 0 0 1px rgba(0, 250, 255, 0.2);
}

.control-btn:hover svg {
  color: #00faff;
  transform: scale(1.1);
}

.control-btn:active {
  transform: translateY(0);
  box-shadow: 
    0 2px 10px rgba(0, 250, 255, 0.2),
    inset 0 1px 0 rgba(0, 0, 0, 0.2);
}

.control-btn:disabled {
  opacity: 0.4;
  cursor: not-allowed;
  background: rgba(0, 0, 0, 0.2);
}

.control-btn:disabled:hover {
  transform: none;
  border-color: rgba(0, 250, 255, 0.2);
  box-shadow: none;
}

/* Specific button states */
.control-btn.active {
  background: rgba(0, 250, 255, 0.15);
  border-color: rgba(0, 250, 255, 0.5);
  box-shadow: 
    0 0 0 2px rgba(0, 250, 255, 0.2),
    0 4px 20px rgba(0, 250, 255, 0.3);
}

.control-btn.active svg {
  color: #00faff;
}

/* Microphone button recording state */
.control-btn.mic-btn.recording {
  background: rgba(255, 68, 85, 0.15);
  border-color: rgba(255, 68, 85, 0.5);
  animation: recordingPulse 1.5s ease-in-out infinite;
}

@keyframes recordingPulse {
  0%, 100% {
    box-shadow: 
      0 0 0 0 rgba(255, 68, 85, 0.4),
      0 4px 20px rgba(255, 68, 85, 0.3);
  }
  50% {
    box-shadow: 
      0 0 0 8px rgba(255, 68, 85, 0.1),
      0 4px 20px rgba(255, 68, 85, 0.4);
  }
}

.control-btn.mic-btn.recording svg {
  color: #ff4455;
}

/* Send button ready state */
.control-btn.send-btn.ready {
  background: rgba(0, 250, 255, 0.15);
  border-color: rgba(0, 250, 255, 0.5);
}

.control-btn.send-btn.ready svg {
  color: #00faff;
}

.control-btn.send-btn.ready:hover {
  background: rgba(0, 250, 255, 0.25);
  border-color: rgba(0, 250, 255, 0.7);
  box-shadow: 
    0 0 0 3px rgba(0, 250, 255, 0.2),
    0 4px 24px rgba(0, 250, 255, 0.4);
}

/* Focus states for accessibility */
.control-btn:focus {
  outline: none;
  box-shadow: 
    0 0 0 3px rgba(0, 250, 255, 0.4),
    0 4px 20px rgba(0, 250, 255, 0.2);
}

/* Remove outline on mouse click but keep for keyboard navigation */
.control-btn:focus:not(:focus-visible) {
  outline: none;
  box-shadow: none;
}

/* Show focus ring only for keyboard navigation */
.control-btn:focus-visible {
  outline: none;
  box-shadow: 
    0 0 0 3px rgba(0, 250, 255, 0.4),
    0 4px 20px rgba(0, 250, 255, 0.2);
}

/* Remove default button focus for all browsers */
.control-btn::-moz-focus-inner {
  border: 0;
  padding: 0;
}

/* Ensure no outline on active state (when clicking) */
.control-btn:active {
  outline: none;
  transform: translateY(0);
  box-shadow: 
    0 2px 10px rgba(0, 250, 255, 0.2),
    inset 0 1px 0 rgba(0, 0, 0, 0.2);
}

.message-input:focus {
  outline: none;
}

/* Also remove outline from message input */
.message-input:focus:not(:focus-visible) {
  outline: none;
}

/* Remove outline from transcription clear button */
.transcription-clear-btn:focus {
  outline: none;
}

.transcription-clear-btn:focus:not(:focus-visible) {
  outline: none;
}

.transcription-clear-btn:focus-visible {
  outline: none;
  box-shadow: 0 0 0 2px rgba(255, 68, 85, 0.4);
}

/* Ripple effect for buttons */
.control-btn::after {
  content: '';
  position: absolute;
  top: 50%;
  left: 50%;
  width: 0;
  height: 0;
  border-radius: 50%;
  background: rgba(255, 255, 255, 0.3);
  transform: translate(-50%, -50%);
  transition: width 0.4s, height 0.4s;
  pointer-events: none;
}

.control-btn:active::after {
  width: 100%;
  height: 100%;
}

/* Input separator - DEPRECATED */
.input-separator {
  display: none;
}

/* Specific button styles */
.context-btn {
  color: #00faff;
}

.mic-btn {
  color: #ff4dd2;
}

.mic-btn.recording {
  background: rgba(255, 68, 85, 0.2);
  border-color: #ff4455;
  color: #ff4455;
}

.settings-btn.active {
  background: rgba(124, 77, 255, 0.2);
  color: #7c4dff;
}

.send-btn {
  background: linear-gradient(135deg, #00faff 0%, #7c4dff 100%);
  color: white;
}

.send-btn:hover:not(:disabled) {
  background: linear-gradient(135deg, #00faff 10%, #7c4dff 90%);
  transform: translateY(-2px);
  box-shadow: 0 4px 12px rgba(0, 250, 255, 0.3);
}

/* Settings Popup */
.settings-popup {
  background: rgba(0, 10, 20, 0.95);
  border: 1px solid rgba(0, 250, 255, 0.3);
  border-radius: 12px;
  -webkit-backdrop-filter: blur(20px);
  backdrop-filter: blur(20px);
  box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
  max-width: 350px;
}

/* Context Button Active State */
.context-btn.active {
  background: rgba(0, 250, 255, 0.2);
  border-color: #00faff;
  color: #00faff;
  box-shadow: 0 0 12px rgba(0, 250, 255, 0.3);
}

/* Send Button States */
.send-btn.ready {
  background: rgba(0, 250, 255, 0.2);
  border-color: #00faff;
  color: #00faff;
  box-shadow: 0 0 12px rgba(0, 250, 255, 0.3);
}

.send-btn.ready:hover {
  background: rgba(0, 250, 255, 0.3);
  transform: scale(1.1);
}

.send-btn.disabled {
  background: rgba(0, 0, 0, 0.2);
  border-color: rgba(255, 255, 255, 0.1);
  color: rgba(255, 255, 255, 0.3);
}

/* Accessibility Improvements */
.control-btn:focus {
  outline: 2px solid #00faff;
  outline-offset: 2px;
}

.context-input:focus,
.message-input:focus {
  outline: none;
  border-color: #00faff;
  box-shadow: 0 0 0 2px rgba(0, 250, 255, 0.2);
}

/* Audio Settings Button */
.audio-settings-btn {
  color: #00faff;
  transition: all 0.2s ease;
}

.audio-settings-btn:hover {
  color: #ffffff;
  background: rgba(0, 250, 255, 0.2);
}

.audio-settings-btn.active {
  background: rgba(0, 250, 255, 0.2);
  border-color: #00faff;
  color: #00faff;
  box-shadow: 0 0 12px rgba(0, 250, 255, 0.3);
}

/* Audio Settings Popover */
.audio-settings-popover-container {
  position: absolute;
  bottom: 80px;
  right: 80px;
  z-index: 1000;
}

.audio-settings-popover {
  animation: popover-appear 0.2s ease-out;
}

@keyframes popover-appear {
  0% {
    opacity: 0;
    transform: translateY(10px) scale(0.95);
  }
  100% {
    opacity: 1;
    transform: translateY(0) scale(1);
  }
}

/* Popover arrow pointing to button */
.audio-settings-popover::after {
  content: '';
  position: absolute;
  bottom: -8px;
  right: 40px;
  width: 16px;
  height: 16px;
  background: rgba(17, 24, 39, 0.95);
  border-right: 1px solid rgba(0, 250, 255, 0.3);
  border-bottom: 1px solid rgba(0, 250, 255, 0.3);
  transform: rotate(45deg);
}

/* Mobile responsiveness for popover */
@media (max-width: 640px) {
  .audio-settings-popover-container {
    position: fixed;
    bottom: 0;
    left: 0;
    right: 0;
    padding: 16px;
  }
  
  .audio-settings-popover {
    width: 100%;
    max-width: none;
    border-radius: 16px 16px 0 0;
  }
  
  .audio-settings-popover::after {
    display: none;
  }
}

/* Fade in animation for device selectors */
@keyframes fadeIn {
  from {
    opacity: 0;
    transform: translateY(-10px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
}

.animate-fadeIn {
  animation: fadeIn 0.3s ease-out forwards;
}

/* Add pulse animation for transcription icon */
.pulse-dot {
  animation: pulseDot 2s cubic-bezier(0.4, 0, 0.6, 1) infinite;
}

@keyframes pulseDot {
  0%, 100% {
    opacity: 1;
    transform: scale(1);
  }
  50% {
    opacity: 0.6;
    transform: scale(0.8);
  }
}

/* Mobile Responsive Improvements */
@media (max-width: 768px) {
  .main-input-wrapper {
    padding: 12px 16px 16px 16px;
  }

  .input-row {
    gap: 12px;
  }

  .control-btn {
    width: 40px;
    height: 40px;
  }

  .control-btn svg {
    width: 20px;
    height: 20px;
  }

  .message-input-wrapper {
    border-radius: 16px;
    padding: 0 16px;
    min-height: 48px;
  }

  .message-input {
    font-size: 14px;
    padding: 12px 0;
  }

  .transcription-display {
    padding: 12px 16px;
    border-radius: 12px;
  }

  .transcription-label {
    font-size: 10px;
  }

  .transcription-clear-btn {
    width: 24px;
    height: 24px;
    font-size: 12px;
  }
}

@media (max-width: 480px) {
  .main-input-wrapper {
    padding: 8px 12px 12px 12px;
  }

  .input-bottom-row {
    gap: 8px;
  }

  .input-controls {
    gap: 4px;
  }

  .control-btn {
    width: 36px;
    height: 36px;
  }

  .control-btn svg {
    width: 18px;
    height: 18px;
  }

  .message-input-wrapper {
    min-height: 44px;
  }
}

/* Dark mode enhancements */
@media (prefers-color-scheme: dark) {
  .message-input-wrapper {
    background: rgba(0, 0, 0, 0.4);
  }

  .control-btn {
    background: rgba(0, 0, 0, 0.4);
  }

  .transcription-display {
    background: rgba(0, 250, 255, 0.06);
  }
}

/* Smooth transitions for all interactive elements */
* {
  -webkit-tap-highlight-color: transparent;
}

/* Improve touch targets on mobile */
@media (hover: none) and (pointer: coarse) {
  .control-btn {
    min-width: 44px;
    min-height: 44px;
  }
}

/* Accessibility improvements */
@media (prefers-reduced-motion: reduce) {
  * {
    animation-duration: 0.01ms !important;
    animation-iteration-count: 1 !important;
    transition-duration: 0.01ms !important;
  }
}

/* Additional focus management for all interactive elements */
button:focus:not(:focus-visible),
input:focus:not(:focus-visible),
textarea:focus:not(:focus-visible) {
  outline: none;
}

/* Ensure context input also follows the same pattern */
.context-input:focus {
  outline: none;
}

.context-input:focus:not(:focus-visible) {
  outline: none;
}

/* Message input wrapper focus states */
.message-input-wrapper:focus-within {
  outline: none;
}

/* Ensure all buttons in the app follow the same pattern */
button {
  -webkit-tap-highlight-color: transparent;
  -webkit-touch-callout: none;
  -webkit-user-select: none;
  -moz-user-select: none;
  -ms-user-select: none;
  user-select: none;
}

/* Remove blue highlight on touch devices */
* {
  -webkit-tap-highlight-color: transparent;
  -webkit-touch-callout: none;
} /* ================================================================
 * MESSAGE STYLES - WhatsApp-style Layout
 * ================================================================
 * Contains all styles related to message display, avatars,
 * bubbles, timestamps, and context information
 */

/* Message Styles - Layout estilo WhatsApp */
.message {
  display: flex;
  gap: 8px;
  margin: 0; /* Remove margin padrão - será controlado individualmente */
  min-height: 40px;
  width: 100%;
  position: relative;
  padding: 0; /* Remove qualquer padding que possa estar causando diferença */
}

.message-avatar {
  flex-shrink: 0;
  width: 32px;
  height: 32px;
  border-radius: 50%;
  display: flex;
  align-items: center;
  justify-content: center;
  margin-top: 4px; /* Alinha com o topo do bubble */
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
  overflow: hidden; /* Garante que o SVG não saia do círculo */
}

.message-avatar svg {
  width: 24px;
  height: 24px;
  display: block; /* Remove espaço em branco abaixo do SVG */
  margin: auto; /* Centraliza o SVG dentro do container */
}

/* Garantir que os ícones do usuário e AI sejam bem visíveis */
.user-message .message-avatar svg path {
  filter: drop-shadow(0 1px 2px rgba(0, 0, 0, 0.3));
}

.system-message .message-avatar svg rect,
.system-message .message-avatar svg circle:last-child {
  filter: drop-shadow(0 1px 2px rgba(0, 0, 0, 0.2));
}

/* Wrapper para bubble + timestamp */
.message-bubble-wrapper {
  display: flex;
  flex-direction: column;
  gap: 4px;
  max-width: 70%;
  flex: 1;
  margin: 0; /* Remove qualquer margem padrão */
}

/* Mensagens do usuário - lado direito */
.user-message {
  flex-direction: row-reverse;
  justify-content: flex-start;
  padding: 0; /* Remove qualquer padding */
  margin: 0 0 16px 0; /* Apenas margin-bottom */
}

.user-message .message-avatar {
  margin-left: 8px;
  margin-right: 0;
}

.system-message .message-avatar {
  margin-left: 0;
  margin-right: 8px; /* Adiciona margem igual ao avatar do usuário */
}

.user-message .message-bubble-wrapper {
  align-items: flex-end; /* Alinha bubble e timestamp à direita */
  margin: 0; /* Remove todas as margens */
}

/* Mensagens do sistema - lado esquerdo */
.system-message {
  justify-content: flex-start;
  padding: 0; /* Remove qualquer padding */
  margin: 0 0 16px 0; /* Apenas margin-bottom, igual ao usuário */
}

.system-message .message-bubble-wrapper {
  align-items: flex-start; /* Alinha bubble e timestamp à esquerda */
  margin: 0; /* Remove todas as margens */
}

/* Bubble das mensagens do usuário */
.user-message .message-content {
  background: linear-gradient(
    135deg,
    rgba(0, 250, 255, 0.3) 0%,
    rgba(0, 102, 204, 0.3) 100%
  );
  border: 1px solid rgba(0, 250, 255, 0.3);
  border-radius: 18px 18px 4px 18px;
}

/* Bubble das mensagens do sistema */
.system-message .message-content {
  background: linear-gradient(
    135deg,
    rgba(255, 77, 210, 0.15) 0%,
    rgba(124, 77, 255, 0.15) 100%
  );
  border: 1px solid rgba(255, 77, 210, 0.3);
  border-radius: 18px 18px 18px 4px;
}

/* Conteúdo da mensagem - padronizado */
.message-content {
  padding: 12px 16px;
  position: relative;
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
  word-wrap: break-word;
  overflow-wrap: break-word;
}

.message-context {
  margin-bottom: 12px;
  padding: 8px 12px;
  background: rgba(0, 0, 0, 0.3);
  border-radius: 8px;
  border-left: 3px solid #00faff;
}

.context-label {
  font-size: 12px;
  font-weight: 600;
  color: #00faff;
  margin-bottom: 4px;
  text-transform: uppercase;
  letter-spacing: 0.5px;
}

.context-content {
  font-size: 13px;
  color: rgba(255, 255, 255, 0.8);
  line-height: 1.4;
}

.message-text {
  font-size: 15px;
  line-height: 1.6;
  color: rgba(255, 255, 255, 0.9);
  word-wrap: break-word;
  margin: 0; /* Remove margem para eliminar espaço extra */
}

/* Timestamp - estilo WhatsApp (fora do bubble) */
.message-timestamp {
  font-size: 11px;
  color: rgba(255, 255, 255, 0.4);
  font-weight: 400;
  padding: 0 4px;
  white-space: nowrap;
  margin-top: 2px;
}

/* Alinhamento do timestamp para mensagens do usuário */
.user-message .message-timestamp {
  text-align: right;
  align-self: flex-end;
}

/* Alinhamento do timestamp para mensagens do sistema */
.system-message .message-timestamp {
  text-align: left;
  align-self: flex-start;
}

/* Message Context Improvements */
.message-context {
  background: rgba(0, 250, 255, 0.1);
  border-left: 3px solid #00faff;
  padding: 8px 12px;
  margin-bottom: 8px;
  border-radius: 0 8px 8px 0;
}

.context-label {
  color: #00faff;
  font-size: 12px;
  font-weight: 600;
  margin-bottom: 4px;
}

.context-content {
  color: rgba(255, 255, 255, 0.8);
  font-size: 13px;
  line-height: 1.4;
}

/* Typing Indicator */
.typing-indicator {
  /* Herda todos os estilos da classe .message e .system-message */
  /* Removido estilos que estavam sobrescrevendo o layout padrão */
}

.typing-animation {
  display: flex;
  align-items: center;
  justify-content: flex-start;
  gap: 4px;
  height: 24px;
  padding: 0; /* Removido padding extra que estava desalinhando */
}

.typing-animation span {
  width: 8px;
  height: 8px;
  border-radius: 50%;
  background: linear-gradient(135deg, #ff4dd2 0%, #7c4dff 100%);
}

/* Messages container styles */
.chat-messages {
  flex: 1;
  overflow-y: auto;
  padding: 16px;
  padding-bottom: 24px; /* Extra padding to ensure scroll space */
  display: flex;
  flex-direction: column;
  min-height: 0;
  position: relative;
  /* Background sólido para cobrir qualquer transparência */
  background: #0a0f1a;
}

/* Add a pseudo-element for extra scroll space */
.chat-messages::after {
  content: "";
  display: block;
  height: 1px;
  min-height: 1px;
  visibility: hidden;
}

.messages-wrapper {
  display: flex;
  flex-direction: column;
  gap: 12px;
  min-height: min-content;
  /* Background sólido para evitar vazamentos */
  background: #0a0f1a;
  position: relative;
  z-index: 1;
}

/* ================================================================
 * MESSAGE STYLES - Message Display & Layout
 * ================================================================
 */

/* Message item base */
.message-item {
  display: flex;
  align-items: flex-start;
  gap: 12px;
  animation: messageSlideIn 0.3s ease-out;
  width: 100%;
}

/* Message avatar */
.message-avatar {
  width: 32px;
  height: 32px;
  border-radius: 50%;
  display: flex;
  align-items: center;
  justify-content: center;
  flex-shrink: 0;
  font-size: 16px;
}

.message-avatar.user {
  background: linear-gradient(135deg, #00faff 0%, #7c4dff 100%);
}

.message-avatar.system {
  background: linear-gradient(135deg, #ff4dd2 0%, #7c4dff 100%);
}

.message-avatar.error {
  background: linear-gradient(135deg, #ff4757 0%, #ff6348 100%);
}

/* Message content */
.message-content {
  flex: 1;
  display: flex;
  flex-direction: column;
  gap: 4px;
  min-width: 0;
}

.message-header {
  display: flex;
  align-items: center;
  gap: 8px;
  font-size: 12px;
  opacity: 0.7;
}

.message-type {
  font-weight: 600;
  text-transform: capitalize;
}

.message-time {
  font-size: 11px;
}

.message-text {
  color: rgba(255, 255, 255, 0.9);
  line-height: 1.5;
  word-wrap: break-word;
  white-space: pre-wrap;
}

/* Context indicator */
.context-indicator {
  display: inline-flex;
  align-items: center;
  gap: 4px;
  padding: 2px 8px;
  background: rgba(124, 77, 255, 0.2);
  border-radius: 12px;
  font-size: 11px;
  color: #7c4dff;
  margin-top: 4px;
}/* ================================================================
 * RESPONSIVE STYLES - Media Queries & Screen Adaptations
 * ================================================================
 * Contains all responsive design adjustments for different
 * screen sizes and device types
 */

/* ===== HIGH RESOLUTION / LARGE SCREENS ===== */
@media (min-width: 1200px) {
  .chat-messages {
    padding: 20px 16px;
  }
  
  .main-input-wrapper {
    padding: 20px 32px;
  }
  
  .message-bubble-wrapper {
    max-width: 65%; /* Slightly smaller on large screens */
  }
}

/* ===== MEDIUM HEIGHT SCREENS ===== */
@media (max-height: 800px) {
  .message-content {
    padding: 10px 14px;
  }

  .message {
    gap: 6px;
    margin: 0;
  }

  /* Espaçamento específico para telas baixas */
  .user-message,
  .system-message {
    margin: 0 0 12px 0;
  }

  .message-timestamp {
    font-size: 10px;
    margin-top: 2px;
  }

  .chat-messages {
    padding: 16px;
  }
}

/* ===== SMALL HEIGHT SCREENS ===== */
@media (max-height: 600px) {
  .chat-messages {
    padding: 12px;
  }
  
  .welcome-message {
    padding: 20px 16px;
  }
  
  .welcome-message h3 {
    font-size: 20px;
    margin-bottom: 8px;
  }
  
  .welcome-message p {
    font-size: 14px;
  }
}

/* ===== TABLET LANDSCAPE ===== */
@media (max-width: 1024px) and (orientation: landscape) {
  .message-bubble-wrapper {
    max-width: 75%;
  }
}

/* ===== TABLET PORTRAIT ===== */
@media (max-width: 768px) {
  .chat-messages {
    padding: 16px;
  }

  .main-input-wrapper {
    padding: 12px 16px;
  }

  /* Aumenta a largura máxima das mensagens em telas menores */
  .message-bubble-wrapper {
    max-width: 85%;
  }

  /* Reduz gap entre avatar e mensagem no tablet */
  .message {
    gap: 6px;
    margin: 0;
  }

  /* Espaçamento específico para mensagens no tablet */
  .user-message,
  .system-message {
    margin: 0 0 14px 0;
  }

  /* Ajusta padding das mensagens para tablet */
  .message-content {
    padding: 10px 14px;
  }

  /* Ajusta tamanho do timestamp para tablet */
  .message-timestamp {
    font-size: 10px;
    margin-top: 3px;
  }

  .input-controls {
    gap: 6px;
  }

  .control-btn {
    width: 40px;
    height: 40px;
  }

  .context-input-wrapper,
  .transcription-display {
    padding: 12px;
  }
}

/* ===== MOBILE LANDSCAPE ===== */
@media (max-width: 768px) and (orientation: landscape) {
  .chat-messages {
    padding: 12px;
  }
  
  .main-input-wrapper {
    padding: 8px 12px;
  }
  
  .message-bubble-wrapper {
    max-width: 80%;
  }
}

/* ===== MOBILE PORTRAIT ===== */
@media (max-width: 480px) {
  .conversational-chat {
    border-radius: 12px;
  }
  
  .chat-messages {
    padding: 12px 8px;
  }

  .main-input-wrapper {
    padding: 8px 12px;
  }

  /* Mobile specific message styling */
  .message-bubble-wrapper {
    max-width: 90%;
  }

  .message {
    gap: 4px;
  }

  .user-message,
  .system-message {
    margin: 0 0 12px 0;
  }

  .message-content {
    padding: 8px 12px;
    font-size: 14px;
  }

  .message-text {
    font-size: 14px;
    line-height: 1.5;
  }

  .message-timestamp {
    font-size: 9px;
    margin-top: 2px;
  }

  /* Avatar adjustments for mobile */
  .message-avatar {
    width: 28px;
    height: 28px;
  }

  .message-avatar svg {
    width: 20px;
    height: 20px;
  }

  /* Control buttons for mobile */
  .input-controls {
    gap: 4px;
    margin-left: 8px;
  }

  .control-btn {
    width: 36px;
    height: 36px;
  }

  /* Context and transcription for mobile */
  .context-input-wrapper,
  .transcription-display {
    padding: 8px;
    margin-bottom: 8px;
  }

  .context-input {
    padding: 8px;
    min-height: 50px;
    font-size: 13px;
  }

  .transcription-text {
    font-size: 13px;
  }

  /* Welcome message adjustments */
  .welcome-message {
    padding: 20px 12px;
  }

  .welcome-message h3 {
    font-size: 18px;
  }

  .welcome-message p {
    font-size: 13px;
  }

  /* Scroll button for mobile */
  .scroll-to-bottom-btn {
    width: 40px;
    height: 40px;
    bottom: 16px;
    margin-right: 8px;
  }
}

/* ===== VERY SMALL SCREENS ===== */
@media (max-width: 320px) {
  .chat-messages {
    padding: 8px 6px;
  }
  
  .main-input-wrapper {
    padding: 6px 8px;
  }
  
  .message-bubble-wrapper {
    max-width: 95%;
  }
  
  .message-content {
    padding: 6px 10px;
  }
  
  .control-btn {
    width: 32px;
    height: 32px;
  }
  
  .input-controls {
    gap: 2px;
    margin-left: 4px;
  }
}

/* ===== PRINT STYLES ===== */
@media print {
  .conversational-chat {
    background: white !important;
    border: 1px solid #000 !important;
    box-shadow: none !important;
  }
  
  .chat-input-area,
  .input-controls,
  .scroll-to-bottom-btn {
    display: none !important;
  }
  
  .message-content {
    background: #f5f5f5 !important;
    border: 1px solid #ddd !important;
    color: #000 !important;
  }
  
  .message-timestamp {
    color: #666 !important;
  }
} import { ChatMessage } from "../hooks/usePersistentMessages";

export interface ChatConversation {
  id: string;
  title: string;
  lastMessage: string;
  lastMessageTime: Date;
  createdAt: Date;
  messages: ChatMessage[];
  isActive: boolean;
}

export interface ChatHistoryState {
  conversations: ChatConversation[];
  currentConversationId: string | null;
}

export interface UseChatHistoryReturn {
  conversations: ChatConversation[];
  currentConversation: ChatConversation | null;
  currentConversationId: string | null;
  createNewConversation: () => string;
  selectConversation: (id: string) => void;
  deleteConversation: (id: string) => void;
  updateConversationTitle: (id: string, title: string) => void;
  addMessageToConversation: (
    conversationId: string,
    message: ChatMessage
  ) => void;
  searchConversations: (query: string) => ChatConversation[];
  clearConversationMessages: (conversationId: string) => void;
}
import { MicrophoneState, SelectedDevices } from "../../../../../context";
import { ChatMessage as PersistentChatMessage } from "../hooks/usePersistentMessages";
import { ChatConversation } from "./ChatHistoryTypes";

/**
 * Core chat message interface representing a single message in the chat
 */
export interface ChatMessage {
  /** Unique identifier for the message */
  id: string;
  /** Type of message - user input, system message, or error */
  type: "user" | "system" | "error";
  /** The actual message content */
  content: string;
  /** When the message was created */
  timestamp: Date;
  /** Whether this message has additional context */
  hasContext?: boolean;
  /** The context content if hasContext is true */
  contextContent?: string;
}

// Component props interfaces following Interface Segregation Principle
export interface ChatInputProps {
  value: string;
  onChange: (value: string) => void;
  onSend: () => void;
  onKeyPress: (e: React.KeyboardEvent) => void;
  disabled?: boolean;
  placeholder?: string;
}

export interface ContextInputProps {
  value: string;
  onChange: (value: string) => void;
  onClose: () => void;
  show: boolean;
}

export interface TranscriptionDisplayProps {
  text: string;
  onClear: () => void;
  transcriptions?: Array<{
    text: string;
    timestamp: string;
    speaker: string;
    sent?: boolean;
  }>;
}

export interface ChatControlsProps {
  microphoneState: MicrophoneState;
  onToggleRecording: () => void;
  onSend: () => void;
  onToggleContext: () => void;
  canSend: boolean;
  showContext: boolean;
  onToggleAudioSettings?: () => void;
  showAudioSettings?: boolean;
  audioSettingsButtonRef?: React.RefObject<HTMLElement>;
}

export interface DebugControlsProps {
  onAddTestMessage: () => void;
  onAddTestAI: () => void;
  onRestore: () => void;
  onClearAll: () => void;
  hasBackup: boolean;
}

export interface ScrollButtonProps {
  show: boolean;
  onClick: () => void;
}

export interface ChatMessagesContainerProps {
  messages: ChatMessage[];
  isProcessing: boolean;
  onScrollChange: (isNearBottom: boolean) => void;
  scrollRef: React.RefObject<HTMLDivElement | null>;
  showScrollButton: boolean;
  onScrollToBottom: () => void;
  newMessageCount?: number;
  hasNewMessages?: boolean;
  onAddTestMessage?: () => void;
  onResetState?: () => void;
  onClearMessages?: () => void;
}

/**
 * Main props interface for the ConversationalChat component
 */
export interface ConversationalChatProps {
  // Transcription handling
  /** Current transcription text from speech-to-text */
  transcriptionText: string;
  /** Handler for transcription text changes */
  onTranscriptionChange: (value: string) => void;
  /** Handler to clear transcription */
  onClearTranscription: () => void;

  // AI Response handling
  /** Current AI response text */
  aiResponseText: string;
  /** Handler for AI response text changes */
  onAiResponseChange: (value: string) => void;
  /** Handler to clear AI response */
  onClearAiResponse: () => void;

  // Context handling
  /** Temporary context for the current conversation */
  temporaryContext: string;
  /** Handler for temporary context changes */
  onTemporaryContextChange: (value: string) => void;

  // Recording controls
  /** Current microphone state */
  microphoneState: MicrophoneState;
  /** Handler to toggle recording on/off */
  onToggleRecording: () => void;
  /** Handler to send a prompt to the AI */
  onSendPrompt: (messageContent?: string, contextContent?: string) => void;

  // Audio settings props (optional)
  /** Current selected language */
  language?: string;
  /** Handler to change language */
  setLanguage?: (value: string) => void;
  /** Whether microphone is enabled */
  isMicrophoneOn?: boolean;
  /** Handler to toggle microphone */
  setIsMicrophoneOn?: (value: boolean) => void;
  /** Whether system audio is enabled */
  isSystemAudioOn?: boolean;
  /** Handler to toggle system audio */
  setIsSystemAudioOn?: (value: boolean) => void;
  /** Available audio devices */
  audioDevices?: MediaDeviceInfo[];
  /** Currently selected audio devices */
  selectedDevices?: SelectedDevices;
  /** Handler for audio device changes */
  handleDeviceChange?: (deviceId: string, isSystemAudio: boolean) => void;

  // Chat History props (optional)
  /** Current active conversation */
  currentConversation?: ChatConversation | null;
  /** Handler to add a message to a conversation */
  onAddMessageToConversation?: (
    conversationId: string,
    message: PersistentChatMessage
  ) => void;

  // Processing state callback (optional)
  /** Handler called when processing state changes */
  onProcessingChange?: (isProcessing: boolean) => void;
}

/**
 * Chat state management interface used by internal hooks
 */
export interface ChatState {
  /** Current input message being typed */
  inputMessage: string;
  /** Setter for input message */
  setInputMessage: (value: string) => void;
  /** Current context text */
  currentContext: string;
  /** Setter for context text */
  setCurrentContext: (value: string) => void;
  /** Whether to show the context input field */
  showContextField: boolean;
  /** Toggle context field visibility */
  setShowContextField: (show: boolean) => void;
  /** Whether a message is currently being processed */
  isProcessing: boolean;
  /** Set processing state */
  setIsProcessing: (processing: boolean) => void;
  /** Reference to processing timeout for cleanup */
  processingTimeoutRef: React.MutableRefObject<NodeJS.Timeout | null>;
}

/**
 * Scroll state management interface for chat messages container
 */
export interface ScrollState {
  /** Whether to show the scroll-to-bottom button */
  showScrollButton: boolean;
  /** Function to scroll to the bottom of messages */
  scrollToBottom: () => void;
  /** Handler for scroll events */
  handleScroll: () => void;
  /** Reference to the messages container element */
  messagesRef: React.RefObject<HTMLDivElement | null>;
  /** Count of new messages since last scroll */
  newMessageCount: number;
  /** Whether there are new messages to notify about */
  hasNewMessages: boolean;
  /** Clear new message notification */
  clearNotification: () => void;
}

// Add new interface for ChatInputAreaProps
export interface ChatInputAreaProps extends ConversationalChatProps {
  chatState: ChatState;
  onSendMessage: () => void;
  onKeyPress: (e: React.KeyboardEvent) => void;
  onToggleContext: () => void;
  onAddTestMessage: () => void;
  onAddTestAI: () => void;
  onRestore: () => void;
  onClearAll: () => void;
  hasBackup: boolean;
  onToggleAudioSettings?: () => void;
  showAudioSettings?: boolean;
  audioSettingsButtonRef?: React.RefObject<HTMLElement>;
}
import { nanoid } from "nanoid";
import { ChatMessage } from "../hooks/usePersistentMessages";
import { ChatConversation } from "../types/ChatHistoryTypes";

const OLD_STORAGE_KEY = "orch-chat-messages";
const NEW_STORAGE_KEY = "orch-chat-history";
const MIGRATION_FLAG_KEY = "orch-chat-migration-completed";

/**
 * Migrates old chat messages to the new conversation format
 */
export const migrateOldChatMessages = (): boolean => {
  try {
    // Check if migration has already been completed
    const migrationCompleted = localStorage.getItem(MIGRATION_FLAG_KEY);
    if (migrationCompleted === "true") {
      return false;
    }

    // Check if there's already data in the new format
    const newData = localStorage.getItem(NEW_STORAGE_KEY);
    if (newData) {
      // Mark migration as completed if new data exists
      localStorage.setItem(MIGRATION_FLAG_KEY, "true");
      return false;
    }

    // Try to load old messages
    const oldData = localStorage.getItem(OLD_STORAGE_KEY);
    if (!oldData) {
      // No old data to migrate
      localStorage.setItem(MIGRATION_FLAG_KEY, "true");
      return false;
    }

    console.log("[MIGRATION] Starting chat history migration...");

    // Parse old messages
    const oldMessages: ChatMessage[] = JSON.parse(oldData).map((msg: any) => ({
      ...msg,
      timestamp: new Date(msg.timestamp),
    }));

    if (oldMessages.length === 0) {
      localStorage.setItem(MIGRATION_FLAG_KEY, "true");
      return false;
    }

    // Create a new conversation with the old messages
    const now = new Date();
    const migrationConversation: ChatConversation = {
      id: nanoid(),
      title: "Conversas Anteriores (Migradas)",
      lastMessage: oldMessages[oldMessages.length - 1]?.content || "",
      lastMessageTime: oldMessages[oldMessages.length - 1]?.timestamp || now,
      createdAt: oldMessages[0]?.timestamp || now,
      messages: oldMessages,
      isActive: true,
    };

    // Save in new format
    const newHistoryData = {
      conversations: [migrationConversation],
      currentId: migrationConversation.id,
    };

    localStorage.setItem(NEW_STORAGE_KEY, JSON.stringify(newHistoryData));

    // Mark migration as completed
    localStorage.setItem(MIGRATION_FLAG_KEY, "true");

    console.log(
      `[MIGRATION] Successfully migrated ${oldMessages.length} messages to new format`
    );

    // Optionally backup old data before removing
    localStorage.setItem(OLD_STORAGE_KEY + "-backup", oldData);

    return true;
  } catch (error) {
    console.error("[MIGRATION] Error during chat history migration:", error);
    return false;
  }
};

/**
 * Clears migration flag (useful for testing)
 */
export const resetMigration = () => {
  localStorage.removeItem(MIGRATION_FLAG_KEY);
  console.log("[MIGRATION] Migration flag reset");
};

/**
 * Checks if migration is needed
 */
export const isMigrationNeeded = (): boolean => {
  const migrationCompleted = localStorage.getItem(MIGRATION_FLAG_KEY);
  const hasOldData = !!localStorage.getItem(OLD_STORAGE_KEY);
  const hasNewData = !!localStorage.getItem(NEW_STORAGE_KEY);

  return !migrationCompleted && hasOldData && !hasNewData;
};
/* ================================================================
 * CONVERSATIONAL CHAT - MAIN STYLES
 * ================================================================
 * Modular CSS organization for better maintainability
 * Each module handles a specific aspect of the chat interface
 */

/* Import all CSS modules */
@import './styles/ConversationalChat.base.css';
@import './styles/ConversationalChat.messages.css';
@import './styles/ConversationalChat.input.css';
@import './styles/ConversationalChat.animations.css';
@import './styles/ConversationalChat.components.css';
@import './styles/ConversationalChat.responsive.css';

/* Main Container - Core Layout */
.conversational-chat {
  display: flex;
  flex-direction: column;
  height: 100%;
  width: 100%;
  background: linear-gradient(
    135deg,
    rgba(0, 10, 20, 0.95) 0%,
    rgba(10, 0, 20, 0.95) 100%
  );
  border-radius: 16px;
  -webkit-backdrop-filter: blur(20px);
  backdrop-filter: blur(20px);
  border: 1px solid rgba(0, 250, 255, 0.2);
  overflow: hidden; /* Garante que os cantos arredondados cortem o conteúdo */
  position: relative;
}

/* Welcome Message */
.welcome-message {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  text-align: center;
  padding: 40px 20px;
  color: rgba(255, 255, 255, 0.7);
  height: 100%;
}

/* Message Styles */
.message {
  display: flex;
  gap: 8px;
  max-width: 100%;
  animation: messageSlideIn 0.3s ease-out;
}

@keyframes messageSlideIn {
  from {
    opacity: 0;
    transform: translateY(10px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
}

.message-avatar {
  flex-shrink: 0;
  width: 32px;
  height: 32px;
  border-radius: 50%;
  margin-top: 4px;
}

.message-bubble-wrapper {
  display: flex;
  flex-direction: column;
  gap: 4px;
  max-width: 75%;
}

.user-message {
  flex-direction: row-reverse;
}

.user-message .message-bubble-wrapper {
  align-items: flex-end;
}

.system-message {
  justify-content: flex-start;
}

.system-message .message-bubble-wrapper {
  align-items: flex-start;
}

.message-content {
  padding: 12px 16px;
  word-wrap: break-word;
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
}

.user-message .message-content {
  background: linear-gradient(135deg, rgba(0, 250, 255, 0.3) 0%, rgba(0, 102, 204, 0.3) 100%);
  border: 1px solid rgba(0, 250, 255, 0.3);
  border-radius: 18px 18px 4px 18px;
}

.system-message .message-content {
  background: linear-gradient(135deg, rgba(255, 77, 210, 0.15) 0%, rgba(124, 77, 255, 0.15) 100%);
  border: 1px solid rgba(255, 77, 210, 0.3);
  border-radius: 18px 18px 18px 4px;
}

.message-text {
  font-size: 15px;
  line-height: 1.6;
  color: rgba(255, 255, 255, 0.9);
}

.message-timestamp {
  font-size: 11px;
  color: rgba(255, 255, 255, 0.4);
  padding: 0 4px;
}import React, { useCallback, useEffect, useRef, useState } from "react";
import { useSettingsState } from "../settings/useSettingsState";
import { AudioSettingsPopover } from "./components/AudioSettingsPopover";
import { ChatInputArea } from "./components/ChatInputArea";
import { ChatMessagesContainer } from "./components/ChatMessagesContainer";
import "./ConversationalChat.css";
import { useChatScroll } from "./hooks/useChatScroll";
import { useChatState } from "./hooks/useChatState";
import { useConversationMessages } from "./hooks/useConversationMessages";
import { usePersistentMessages } from "./hooks/usePersistentMessages";
import { ConversationalChatProps } from "./types/ChatTypes";

/**
 * Refactored Conversational Chat Component
 *
 * Applies SOLID, DRY, KISS, and YAGNI principles:
 *
 * SOLID:
 * - Single Responsibility: Each component has one clear purpose
 * - Open/Closed: Components are open for extension, closed for modification
 * - Liskov Substitution: Components can be replaced with compatible implementations
 * - Interface Segregation: Components only depend on interfaces they use
 * - Dependency Inversion: Depends on abstractions (hooks) not concrete implementations
 *
 * DRY: Shared logic in hooks, reusable components, no code duplication
 * KISS: Simple, focused components that are easy to understand
 * YAGNI: Debug functionality separated and only included in development
 */
const ConversationalChatRefactored: React.FC<ConversationalChatProps> = ({
  transcriptionText,
  onTranscriptionChange,
  onClearTranscription,
  aiResponseText,
  onAiResponseChange,
  onClearAiResponse,
  temporaryContext,
  onTemporaryContextChange,
  microphoneState,
  onToggleRecording,
  onSendPrompt,
  // Audio settings props
  language,
  setLanguage,
  isMicrophoneOn,
  setIsMicrophoneOn,
  isSystemAudioOn,
  setIsSystemAudioOn,
  audioDevices,
  selectedDevices,
  handleDeviceChange,
  // Chat History props
  currentConversation,
  onAddMessageToConversation,
  onProcessingChange,
}) => {
  // Component lifecycle tracking
  const componentId = useRef(
    `chat-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`
  );
  const mountTime = useRef(Date.now());

  // Log prop changes
  useEffect(() => {
    console.log("[CHAT_PROPS] Conversation prop changed:", {
      conversationId: currentConversation?.id,
      title: currentConversation?.title,
      messageCount: currentConversation?.messages.length,
    });
  }, [currentConversation]);

  // Custom hooks for state management (Dependency Inversion Principle)
  // Use conversation messages if available, otherwise fall back to persistent messages
  const persistentMessagesHook = usePersistentMessages();
  const conversationMessagesHook = useConversationMessages({
    currentConversation: currentConversation || null,
    onAddMessage: onAddMessageToConversation || (() => {}),
    onClearConversation: () => {}, // Will be implemented later
  });

  // Clear input state when conversation changes
  useEffect(() => {
    if (currentConversation) {
      // Clear any input state when switching conversations
      chatState.setInputMessage("");
      chatState.setCurrentContext("");
      chatState.setShowContextField(false);
      chatState.setIsProcessing(false);

      // Clear any ongoing processing timeouts
      if (chatState.processingTimeoutRef.current) {
        clearTimeout(chatState.processingTimeoutRef.current);
        chatState.processingTimeoutRef.current = null;
      }

      // Clear any pending AI responses
      if (
        aiResponseText &&
        (aiResponseText === "Processing..." ||
          aiResponseText === "Processando...")
      ) {
        onClearAiResponse();
      }

      // Reset response tracking
      isReceivingResponse.current = false;
      lastProcessedResponse.current = "";

      console.log("[CHAT] Conversation changed, clearing all state");
    }
  }, [currentConversation?.id]); // chatState and other deps intentionally omitted to prevent infinite loops

  // Select the appropriate hook based on whether we have a conversation system
  const useConversationSystem = !!(
    currentConversation && onAddMessageToConversation
  );
  const {
    messages: chatMessages,
    addMessage,
    clearMessages,
  } = useConversationSystem ? conversationMessagesHook : persistentMessagesHook;

  // Recovery is only available with persistent messages
  const recovery = useConversationSystem
    ? {
        hasBackup: false,
        restoreFromBackup: () => {},
        clearBackup: () => {},
        integrityCheck: () => false,
        lastSaveTime: 0,
      }
    : persistentMessagesHook.recovery;

  const chatState = useChatState();

  // Notify parent when processing state changes
  useEffect(() => {
    if (onProcessingChange) {
      onProcessingChange(chatState.isProcessing);
    }
  }, [chatState.isProcessing, onProcessingChange]);

  // Audio settings state
  const [showAudioSettings, setShowAudioSettings] = useState(false);
  const audioSettingsButtonRef = useRef<HTMLElement>(null!);
  const audioSettings = useSettingsState(showAudioSettings);

  // Refs for scroll management
  const messagesContainerRef = useRef<HTMLDivElement>(null!);

  // Use the updated scroll hook
  const scrollState = useChatScroll({
    messages: chatMessages,
    messagesContainerRef,
  });

  // Log component lifecycle (only in development)
  useEffect(() => {
    // Clear state on mount
    chatState.setInputMessage("");
    chatState.setCurrentContext("");
    chatState.setShowContextField(false);
    chatState.setIsProcessing(false);

    if (process.env.NODE_ENV !== "production") {
      console.log("🔄 [CHAT_LIFECYCLE] Component MOUNTED:", {
        componentId: componentId.current,
        mountTime: new Date(mountTime.current).toISOString(),
        conversationId: currentConversation?.id,
      });

      return () => {
        console.log("🔄 [CHAT_LIFECYCLE] Component UNMOUNTING:", {
          componentId: componentId.current,
          lifespan: Date.now() - mountTime.current,
        });
      };
    }
  }, []); // chatState omitted intentionally - we want this to run only on mount

  // Track if we're currently receiving a response
  const isReceivingResponse = useRef(false);
  const lastProcessedResponse = useRef<string>("");
  const responseDebounceTimer = useRef<NodeJS.Timeout | null>(null);

  // Handle AI response processing with debounce and better state management
  useEffect(() => {
    if (!aiResponseText || aiResponseText.trim() === "") {
      return;
    }

    // Handle processing state
    if (
      aiResponseText === "Processing..." ||
      aiResponseText === "Processando..."
    ) {
      chatState.setIsProcessing(true);
      isReceivingResponse.current = true;
      return;
    }

    // Clear any existing debounce timer
    if (responseDebounceTimer.current) {
      clearTimeout(responseDebounceTimer.current);
    }

    // Debounce the response processing to avoid rapid updates
    responseDebounceTimer.current = setTimeout(() => {
      // Check if this is truly a new response
      if (aiResponseText === lastProcessedResponse.current) {
        console.log("⚠️ [CHAT] Same response, skipping");
        return;
      }

      // Check for duplicates in existing messages
      const isDuplicate = chatMessages.some(
        (msg) => msg.type === "system" && msg.content === aiResponseText
      );

      if (isDuplicate) {
        console.log("⚠️ [CHAT] Duplicate AI response in messages, skipping");
        return;
      }

      // Check if this looks like a final response (not partial)
      // A final response typically doesn't end with "..." and has reasonable length
      const looksLikeFinalResponse =
        !aiResponseText.endsWith("...") &&
        aiResponseText.length > 10 &&
        !aiResponseText.includes("Processando") &&
        !aiResponseText.includes("Processing");

      if (looksLikeFinalResponse) {
        console.log(
          "✅ [CHAT] Adding final AI response:",
          aiResponseText.substring(0, 50)
        );

        // Add AI response
        addMessage({
          type: "system",
          content: aiResponseText,
        });

        // Update last processed response
        lastProcessedResponse.current = aiResponseText;

        // Clear processing state
        chatState.setIsProcessing(false);
        isReceivingResponse.current = false;

        if (chatState.processingTimeoutRef.current) {
          clearTimeout(chatState.processingTimeoutRef.current);
          chatState.processingTimeoutRef.current = null;
        }

        // Only clear AI response after successfully adding the message
        // Add a small delay to ensure the message is properly saved
        setTimeout(() => {
          onClearAiResponse();
        }, 100);
      } else {
        console.log("🔄 [CHAT] Partial response detected, waiting for more...");
        // For partial responses, just update the processing state
        isReceivingResponse.current = true;
      }
    }, 300); // 300ms debounce

    // Cleanup function
    return () => {
      if (responseDebounceTimer.current) {
        clearTimeout(responseDebounceTimer.current);
      }
    };
  }, [aiResponseText, chatMessages, addMessage, onClearAiResponse, chatState]);

  // Handle send message (KISS principle - simple and clear)
  const handleSendMessage = useCallback(() => {
    const messageContent = chatState.inputMessage.trim();

    if (!messageContent && !transcriptionText.trim()) {
      return;
    }

    const finalContent = messageContent || transcriptionText.trim();

    // Add user message with context info
    addMessage({
      type: "user",
      content: finalContent,
      hasContext: !!chatState.currentContext,
      contextContent: chatState.currentContext || undefined,
    });

    // Clear inputs
    chatState.setInputMessage("");
    chatState.setCurrentContext("");
    chatState.setShowContextField(false);
    onTemporaryContextChange("");

    // IMPORTANT: Clear transcription after sending
    if (transcriptionText.trim()) {
      onClearTranscription();
    }

    // Set processing state with timeout
    chatState.setIsProcessing(true);
    if (chatState.processingTimeoutRef.current) {
      clearTimeout(chatState.processingTimeoutRef.current);
    }

    // Send prompt - pass message and context separately
    setTimeout(() => {
      // Pass the message as first parameter and context as second
      onSendPrompt(finalContent, chatState.currentContext || undefined);
    }, 0);
  }, [
    chatState,
    transcriptionText,
    addMessage,
    onTemporaryContextChange,
    onSendPrompt,
    onClearTranscription,
  ]);

  // Handle key press (Enter to send, Shift+Enter for new line)
  const handleKeyPress = useCallback(
    (e: React.KeyboardEvent) => {
      if (e.key === "Enter" && !e.shiftKey) {
        e.preventDefault();
        handleSendMessage();
      }
    },
    [handleSendMessage]
  );

  // Handle context toggle
  const handleToggleContext = useCallback(() => {
    if (chatState.showContextField) {
      chatState.setCurrentContext("");
      chatState.setShowContextField(false);
    } else {
      chatState.setShowContextField(true);
    }
  }, [chatState]);

  // Handle audio settings toggle
  const handleToggleAudioSettings = useCallback(() => {
    setShowAudioSettings(!showAudioSettings);
  }, [showAudioSettings]);

  // Debug functions (YAGNI principle - only in development)
  const debugFunctions = React.useMemo(() => {
    if (process.env.NODE_ENV === "production") {
      return {};
    }

    return {
      addTestMessage: () => {
        addMessage({
          type: "user",
          content: "Test message",
        });
      },
      addTestAIResponse: () => {
        addMessage({
          type: "system",
          content:
            "This is a test AI response to verify the chat is working correctly.",
        });
      },
      resetChatState: () => {
        chatState.setIsProcessing(false);
        if (chatState.processingTimeoutRef.current) {
          clearTimeout(chatState.processingTimeoutRef.current);
          chatState.processingTimeoutRef.current = null;
        }
      },
    };
  }, [addMessage, chatState]);

  // Force scroll to bottom on mount and when messages are loaded
  useEffect(() => {
    // Small delay to ensure DOM is fully rendered
    const scrollTimer = setTimeout(() => {
      if (messagesContainerRef.current && chatMessages.length > 0) {
        // Force multiple scroll attempts to ensure we reach the absolute bottom
        const forceScroll = () => {
          if (!messagesContainerRef.current) return;

          const element = messagesContainerRef.current;
          const maxScroll = element.scrollHeight - element.clientHeight;

          // Try different methods to ensure scroll
          element.scrollTop = element.scrollHeight;
          element.scrollTo(0, element.scrollHeight);

          // Verify and retry if needed
          requestAnimationFrame(() => {
            if (element.scrollTop < maxScroll - 2) {
              element.scrollTop = maxScroll + 100; // Overshoot to ensure bottom
            }
          });
        };

        // Execute multiple times with delays
        forceScroll();
        setTimeout(forceScroll, 100);
        setTimeout(forceScroll, 300);
      }
    }, 50);

    return () => clearTimeout(scrollTimer);
  }, []); // Only run once on mount

  return (
    <div className="conversational-chat">
      {/* Chat Messages Container */}
      <ChatMessagesContainer
        messages={chatMessages}
        isProcessing={chatState.isProcessing}
        onScrollChange={() => {}} // Not needed anymore
        scrollRef={messagesContainerRef}
        showScrollButton={scrollState.showScrollButton}
        onScrollToBottom={scrollState.scrollToBottom}
        onAddTestMessage={debugFunctions.addTestMessage}
        onResetState={debugFunctions.resetChatState}
        onClearMessages={clearMessages}
      />

      {/* Chat Input Area */}
      <ChatInputArea
        transcriptionText={transcriptionText}
        onTranscriptionChange={onTranscriptionChange}
        onClearTranscription={onClearTranscription}
        aiResponseText={aiResponseText}
        onAiResponseChange={onAiResponseChange}
        onClearAiResponse={onClearAiResponse}
        temporaryContext={temporaryContext}
        onTemporaryContextChange={onTemporaryContextChange}
        microphoneState={microphoneState}
        onToggleRecording={onToggleRecording}
        onSendPrompt={onSendPrompt}
        chatState={chatState}
        onSendMessage={handleSendMessage}
        onKeyPress={handleKeyPress}
        onToggleContext={handleToggleContext}
        onAddTestMessage={debugFunctions.addTestMessage || (() => {})}
        onAddTestAI={debugFunctions.addTestAIResponse || (() => {})}
        onRestore={recovery.restoreFromBackup}
        onClearAll={() => {
          clearMessages();
          recovery.clearBackup();
        }}
        hasBackup={recovery.hasBackup}
        onToggleAudioSettings={handleToggleAudioSettings}
        showAudioSettings={showAudioSettings}
        audioSettingsButtonRef={audioSettingsButtonRef}
      />

      {/* Audio Settings Popover */}
      <AudioSettingsPopover
        show={showAudioSettings}
        onClose={() => setShowAudioSettings(false)}
        anchorRef={audioSettingsButtonRef}
        settings={{
          // Language
          language: language || "pt-BR",
          setLanguage: setLanguage || (() => {}),

          // Device selection
          isMicrophoneOn: isMicrophoneOn || false,
          setIsMicrophoneOn: setIsMicrophoneOn || (() => {}),
          isSystemAudioOn: isSystemAudioOn || false,
          setIsSystemAudioOn: setIsSystemAudioOn || (() => {}),
          audioDevices: audioDevices || [],
          selectedDevices: selectedDevices || {
            microphone: null,
            systemAudio: null,
          },
          handleDeviceChange: handleDeviceChange || (() => {}),
        }}
      />
    </div>
  );
};

// Custom comparison to ignore frequent transcriptionText updates
function areEqual(
  prev: ConversationalChatProps,
  next: ConversationalChatProps
) {
  const isEqual =
    prev.aiResponseText === next.aiResponseText &&
    prev.temporaryContext === next.temporaryContext &&
    prev.microphoneState === next.microphoneState &&
    prev.onAiResponseChange === next.onAiResponseChange &&
    prev.onClearAiResponse === next.onClearAiResponse &&
    prev.onClearTranscription === next.onClearTranscription &&
    prev.onSendPrompt === next.onSendPrompt &&
    prev.onToggleRecording === next.onToggleRecording &&
    prev.onTranscriptionChange === next.onTranscriptionChange &&
    // Audio settings comparisons (only check if props changed, not device arrays)
    prev.language === next.language &&
    prev.setLanguage === next.setLanguage &&
    prev.isMicrophoneOn === next.isMicrophoneOn &&
    prev.setIsMicrophoneOn === next.setIsMicrophoneOn &&
    prev.isSystemAudioOn === next.isSystemAudioOn &&
    prev.setIsSystemAudioOn === next.setIsSystemAudioOn &&
    prev.handleDeviceChange === next.handleDeviceChange;
  // transcriptionText, audioDevices and selectedDevices deliberately ignored

  if (!isEqual && process.env.NODE_ENV !== "production") {
    console.log(
      "🔄 [CHAT_RERENDER] ConversationalChat re-rendering due to prop change:",
      {
        aiResponseChanged: prev.aiResponseText !== next.aiResponseText,
        aiResponseText: {
          prev: prev.aiResponseText?.substring(0, 50),
          next: next.aiResponseText?.substring(0, 50),
        },
        temporaryContextChanged:
          prev.temporaryContext !== next.temporaryContext,
        microphoneStateChanged: prev.microphoneState !== next.microphoneState,
      }
    );
  }

  return isEqual;
}

// Export component with memo to prevent unnecessary re-renders
export const ConversationalChat = React.memo(
  ConversationalChatRefactored,
  areEqual
);
// Export main component
export { ConversationalChat } from "./ConversationalChat";

// Export types
export * from "./types/ChatTypes";

// Export hooks
export { useChatScroll } from "./hooks/useChatScroll";
export { useChatState } from "./hooks/useChatState";
export { usePersistentMessages } from "./hooks/usePersistentMessages";

// Individual components (for potential reuse)
export { ChatInputArea } from "./components/ChatInputArea";
export { ChatMessagesContainer } from "./components/ChatMessagesContainer";
export { ContextInput } from "./components/ContextInput";
export { MessageInput } from "./components/MessageInput";
export { ScrollToBottomButton } from "./components/ScrollToBottomButton";
export { TranscriptionDisplay } from "./components/TranscriptionDisplay";
# ConversationalChat - Refatoração SOLID, DRY, KISS, YAGNI

Esta refatoração aplica os princípios fundamentais de desenvolvimento de software conforme descrito nos artigos de referência sobre [SOLID, Clean Code, DRY, KISS, YAGNI](https://medium.com/javascript-render/solid-clean-code-dry-kiss-yagni-principles-react-97fe92da25cd) e [Common Sense Refactoring](https://alexkondov.com/refactoring-a-messy-react-component/).

## 🎯 Princípios Aplicados

### SOLID

#### **S - Single Responsibility Principle (SRP)**
- **Antes**: Um componente monolítico com 964 linhas fazendo tudo
- **Depois**: Componentes focados com responsabilidades únicas:
  - `MessageInput` - apenas input de mensagem
  - `ContextInput` - apenas input de contexto  
  - `ChatControls` - apenas controles do chat
  - `ChatMessagesContainer` - apenas exibição de mensagens
  - `useChatState` - apenas gerenciamento de estado
  - `useChatScroll` - apenas gerenciamento de scroll

#### **O - Open/Closed Principle (OCP)**
- Componentes são **abertos para extensão** através de props
- **Fechados para modificação** - funcionalidade core protegida
- Novos tipos de mensagem podem ser adicionados sem modificar componentes existentes

#### **L - Liskov Substitution Principle (LSP)**
- Componentes podem ser substituídos por implementações compatíveis
- Interfaces bem definidas garantem substituibilidade

#### **I - Interface Segregation Principle (ISP)**
- Cada componente recebe **apenas as props que precisa**
- Interfaces específicas para cada responsabilidade
- Exemplo: `ChatInputProps` vs `ChatControlsProps`

#### **D - Dependency Inversion Principle (DIP)**
- Componentes dependem de **abstrações** (hooks) não implementações
- `usePersistentMessages`, `useChatState`, `useChatScroll` são abstrações
- Facilita testes e substituição de implementações

### DRY (Don't Repeat Yourself)

- **Hooks customizados** eliminam duplicação de lógica
- **Componentes reutilizáveis** evitam código repetido
- **Tipos compartilhados** em `ChatTypes.ts`
- **Estilos consistentes** através de classes CSS

### KISS (Keep It Simple, Stupid)

- **Componentes pequenos** e focados (< 100 linhas cada)
- **Lógica clara** e fácil de entender
- **Nomes descritivos** para funções e variáveis
- **Estrutura simples** de arquivos

### YAGNI (You Aren't Gonna Need It)

- **Funcionalidades de debug** separadas em `DebugControls`
- **Removidas automaticamente** em produção (`process.env.NODE_ENV`)
- **Fácil remoção** sem afetar código principal

## 📁 Estrutura de Arquivos

```
ConversationalChat/
├── README.md                           # Esta documentação
├── index.ts                           # Exports centralizados
├── ConversationalChatRefactored.tsx   # Componente principal
├── types/
│   └── ChatTypes.ts                   # Tipos compartilhados
├── hooks/
│   ├── usePersistentMessages.ts       # Gerenciamento de mensagens
│   ├── useChatState.ts               # Estado do chat
│   └── useChatScroll.ts              # Comportamento de scroll
└── components/
    ├── MessageInput.tsx              # Input de mensagem
    ├── ContextInput.tsx              # Input de contexto
    ├── TranscriptionDisplay.tsx      # Exibição de transcrição
    ├── ChatControls.tsx              # Controles principais
    ├── DebugControls.tsx             # Controles de debug
    ├── ScrollToBottomButton.tsx      # Botão de scroll
    ├── ChatInputArea.tsx             # Área de input completa
    └── ChatMessagesContainer.tsx     # Container de mensagens
```

## 🔄 Comparação: Antes vs Depois

### Antes (Monolítico)
```typescript
// 964 linhas em um arquivo
// Múltiplas responsabilidades
// Lógica misturada
// Difícil de testar
// Difícil de manter
```

### Depois (Modular)
```typescript
// 12 arquivos focados
// Responsabilidade única por arquivo
// Lógica separada em hooks
// Fácil de testar individualmente
// Fácil de manter e estender
```

## 🚀 Benefícios da Refatoração

### **Manutenibilidade**
- Código mais fácil de entender e modificar
- Mudanças isoladas não afetam outros componentes
- Debugging mais simples

### **Testabilidade**
- Componentes pequenos são mais fáceis de testar
- Hooks podem ser testados independentemente
- Mocking mais simples

### **Reutilização**
- Componentes podem ser reutilizados em outros contextos
- Hooks podem ser compartilhados entre componentes
- Lógica não duplicada

### **Performance**
- `React.memo` aplicado estrategicamente
- Re-renders minimizados
- Componentes otimizados individualmente

### **Desenvolvimento**
- Funcionalidades de debug separadas
- Fácil adição de novas funcionalidades
- Onboarding mais rápido para novos desenvolvedores

## 🛠️ Como Usar

### Importação Simples
```typescript
import { ConversationalChat } from './ConversationalChat';
```

### Importação de Componentes Individuais
```typescript
import { 
  MessageInput, 
  ChatControls, 
  useChatState 
} from './ConversationalChat';
```

### Uso em Produção
```typescript
// Debug controls são automaticamente removidos em produção
// Logs de desenvolvimento não aparecem em produção
```

## 🔧 Extensibilidade

### Adicionando Novo Tipo de Mensagem
1. Atualizar `ChatTypes.ts`
2. Modificar `MessageItem` em `ChatMessagesContainer.tsx`
3. Nenhuma outra mudança necessária

### Adicionando Nova Funcionalidade
1. Criar novo hook se necessário
2. Criar novo componente focado
3. Compor no componente principal

### Customizando Comportamento
1. Substituir hooks por implementações customizadas
2. Manter interfaces compatíveis
3. Funcionalidade mantida

## 📚 Referências

- [SOLID, Clean Code, DRY, KISS, YAGNI Principles + React](https://medium.com/javascript-render/solid-clean-code-dry-kiss-yagni-principles-react-97fe92da25cd)
- [Common Sense Refactoring of a Messy React Component](https://alexkondov.com/refactoring-a-messy-react-component/)
- [SOLID, YAGNI, DRY, KISS principles in React](https://www.it-justice.com/blog/tech/solid-yagni-dry-kiss-principles-in-react/)

---

**Resultado**: Código mais limpo, manutenível, testável e extensível seguindo as melhores práticas da indústria. // SPDX-License-Identifier: MIT OR Apache-2.0
// Copyright (c) 2025 Guilherme Ferrari Brescia

/**
 * Hook para gerenciar compatibilidade entre modelos Deepgram e idiomas
 * Aplica princípios de Responsabilidade Única e extrai lógica de negócio do componente
 * Otimizado para evitar cálculos repetidos e logs excessivos
 */
export const useDeepgramLanguageCompatibility = () => {
  // Cache de resultados para evitar recálculos desnecessários
  const modelLanguageCache = new Map<string, string[]>();
  // Dicionário de idiomas disponíveis por família de modelo
  const modelLanguageCompatibility: { [key: string]: string[] } = {
    // Nova-3 suporta apenas inglês na versão inicial
    'nova-3': ['en', 'en-US', 'en-GB', 'en-AU', 'en-IN', 'en-NZ'],
    'nova-3-medical': ['en', 'en-US', 'en-GB', 'en-AU', 'en-IN', 'en-NZ'],
    
    // Nova-2 tem suporte extenso a idiomas
    'nova-2': [
      'multi', 
      'en', 'en-US', 'en-GB', 'en-AU', 'en-IN', 'en-NZ',
      'pt', 'pt-BR', 'pt-PT',
      'es', 'es-419',
      'fr', 'fr-CA',
      'de', 'de-CH',
      'it', 'ja', 'ko', 'ko-KR',
      'zh-CN', 'zh-TW', 'zh-HK',
      'ru', 'hi', 'nl', 'nl-BE',
      'bg', 'ca', 'cs', 'da', 'da-DK',
      'el', 'et', 'fi', 'hu', 'id',
      'lv', 'lt', 'ms', 'no', 'pl', 'ro',
      'sk', 'sv', 'sv-SE', 'th', 'th-TH',
      'tr', 'uk', 'vi'
    ],
    'nova-2-meeting': [
      'multi', 
      'en', 'en-US', 'en-GB', 'en-AU', 'en-IN', 'en-NZ',
      'pt', 'pt-BR', 'pt-PT',
      'es', 'es-419', 'fr', 'de', 'it', 'ja'
    ],
    'nova-2-phonecall': [
      'multi', 
      'en', 'en-US', 'en-GB', 'en-AU', 'en-IN', 'en-NZ',
      'pt', 'pt-BR', 'pt-PT',
      'es', 'es-419', 'fr', 'de', 'it', 'ja'
    ],
    'nova-2-video': [
      'multi', 
      'en', 'en-US', 'en-GB', 'en-AU', 'en-IN', 'en-NZ',
      'pt', 'pt-BR', 'pt-PT',
      'es', 'es-419', 'fr', 'de', 'it', 'ja'
    ],
    
    // Nova modelos padrão
    'nova': ['en', 'en-US', 'en-GB', 'en-AU', 'en-IN', 'en-NZ', 'pt', 'pt-BR', 'es', 'fr', 'de', 'it', 'ja', 'ko', 'nl', 'pl', 'ru'],
    'nova-phonecall': ['en', 'en-US', 'en-GB', 'pt', 'pt-BR', 'es', 'fr', 'de', 'it', 'ja'],
    
    // Enhanced models
    'enhanced': ['en', 'en-US', 'en-GB', 'en-AU', 'pt', 'pt-BR', 'es', 'es-419', 'fr', 'de', 'it', 'ja', 'hi', 'nl', 'id', 'zh-CN', 'ko', 'ru'],
    'enhanced-meeting': ['en', 'en-US', 'en-GB', 'pt', 'pt-BR', 'es', 'fr', 'de', 'it', 'ja'],
    'enhanced-phonecall': ['en', 'en-US', 'en-GB', 'pt', 'pt-BR', 'es', 'fr', 'de', 'it', 'ja', 'ko'],
    'enhanced-finance': ['en', 'en-US', 'en-GB'],
    
    // Base models
    'base': ['en', 'en-US', 'en-GB', 'pt', 'pt-BR', 'es', 'fr', 'de', 'it', 'ja', 'hi', 'nl', 'id', 'zh-CN', 'ko'],
    'base-meeting': ['en', 'en-US', 'en-GB', 'pt', 'pt-BR', 'es', 'fr', 'de', 'it', 'ja'],
    'base-phonecall': ['en', 'en-US', 'en-GB', 'pt', 'pt-BR', 'es', 'fr', 'de', 'it', 'ja', 'ko'],
    'base-finance': ['en', 'en-US', 'en-GB']
  };

  // Definições de idiomas para exibição
  const languageDisplay: { [key: string]: string } = {
    'multi': 'Multilingual (Auto-detect)',
    'en': 'English (Global)',
    'en-US': 'English (US)',
    'en-GB': 'English (UK)',
    'en-AU': 'English (Australia)',
    'en-IN': 'English (India)',
    'en-NZ': 'English (New Zealand)',
    'pt': 'Portuguese',
    'pt-BR': 'Portuguese (Brazil)',
    'pt-PT': 'Portuguese (Portugal)',
    'es': 'Spanish',
    'es-419': 'Spanish (Latin America)',
    'fr': 'French',
    'fr-CA': 'French (Canada)',
    'de': 'German',
    'de-CH': 'German (Switzerland)',
    'it': 'Italian',
    'ja': 'Japanese',
    'ko': 'Korean',
    'ko-KR': 'Korean',
    'zh-CN': 'Chinese (Simplified)',
    'zh-TW': 'Chinese (Traditional)',
    'zh-HK': 'Chinese (Cantonese)',
    'ru': 'Russian',
    'hi': 'Hindi',
    'nl': 'Dutch',
    'nl-BE': 'Dutch (Belgium)/Flemish',
    'bg': 'Bulgarian',
    'ca': 'Catalan',
    'cs': 'Czech',
    'da': 'Danish',
    'da-DK': 'Danish',
    'el': 'Greek',
    'et': 'Estonian',
    'fi': 'Finnish',
    'hu': 'Hungarian',
    'id': 'Indonesian',
    'lv': 'Latvian',
    'lt': 'Lithuanian',
    'ms': 'Malay',
    'no': 'Norwegian',
    'pl': 'Polish',
    'ro': 'Romanian',
    'sk': 'Slovak',
    'sv': 'Swedish',
    'sv-SE': 'Swedish',
    'th': 'Thai',
    'th-TH': 'Thai',
    'tr': 'Turkish',
    'uk': 'Ukrainian',
    'vi': 'Vietnamese'
  };

  /**
   * Retorna os idiomas compatíveis para um determinado modelo
   * Com tratamento robusto para variações na forma como o modelo está salvo
   * Otimizado com cache e logs reduzidos
   */
  const getCompatibleLanguages = (model: string): string[] => {
    // Tratamento para casos undefined/null
    if (!model) {
      return ['en', 'en-US'];
    }
    
    // Verificar cache primeiro
    if (modelLanguageCache.has(model)) {
      return modelLanguageCache.get(model)!;
    }
    
    // Criar cópia normalizada para consulta (lowercase)
    const normalizedModel = model.toLowerCase();
    
    // Estratégia de resolução:
    let result: string[];
    
    // 1. Tentar encontrar o modelo exato ou normalizado
    if (modelLanguageCompatibility[model]) {
      result = modelLanguageCompatibility[model];
    } else {
      // 2. Tentar encontrar o modelo normalizado (case insensitive)
      const exactMatchKey = Object.keys(modelLanguageCompatibility).find(
        key => key.toLowerCase() === normalizedModel
      );
      
      if (exactMatchKey) {
        result = modelLanguageCompatibility[exactMatchKey];
      } else {
        // 3. Tentar extrair família do modelo (ex: 'nova-2-meeting' -> 'nova-2')
        const modelFamily = model.split('-').slice(0, 2).join('-');
        
        if (modelLanguageCompatibility[modelFamily]) {
          result = modelLanguageCompatibility[modelFamily];
        } else {
          // 4. Tentar obter o modelo base (ex: 'nova-2-meeting' -> 'nova')
          const modelPrefix = model.split('-')[0];
          
          if (modelLanguageCompatibility[modelPrefix]) {
            result = modelLanguageCompatibility[modelPrefix];
          } else {
            // 5. Fallback para inglês (sempre disponível)
            console.warn(`⚠️ [Deepgram] Modelo não reconhecido: '${model}', usando fallback para inglês`);
            result = ['en', 'en-US'];
          }
        }
      }
    }
    
    // Salvar no cache
    modelLanguageCache.set(model, result);
    return result;
  };

  /**
   * Retorna o nome de exibição para um código de idioma
   */
  const getLanguageDisplay = (code: string): string => {
    return languageDisplay[code] || code;
  };

  return {
    getCompatibleLanguages,
    getLanguageDisplay,
    languageDisplay,
    modelLanguageCompatibility
  };
};

export default useDeepgramLanguageCompatibility;
// SPDX-License-Identifier: MIT OR Apache-2.0
// Copyright (c) 2025 Guilherme Ferrari Brescia

import React from "react";
