
export default WifiStatusConnection;
// SPDX-License-Identifier: MIT OR Apache-2.0
// Copyright (c) 2025 Guilherme Ferrari Brescia

import { useState } from 'react';
import { ModeService } from '../../../../services/ModeService';
import { ToastVariant } from '../../../ui/toast';
import { ImportMode } from '../types/interfaces';

// Custom hook following Single Responsibility and Open/Closed principles
export const useChatGptImport = (
  showToast: (title: string, description: string, variant: ToastVariant) => void
) => {
  const [importFile, setImportFile] = useState<File | null>(null);
  const [importUserName, setImportUserName] = useState<string>("");
  const [importMode, setImportMode] = useState<ImportMode>('increment');
  const [importProgress, setImportProgress] = useState<number>(0);
  const [importStage, setImportStage] = useState<string>("");
  const [importSummary, setImportSummary] = useState<string>("");
  const [isImporting, setIsImporting] = useState(false);
  const [showImportModal, setShowImportModal] = useState(false);

  // Handler for file selection
  const handleFileChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    if (e.target.files && e.target.files.length > 0) {
      setImportFile(e.target.files[0]);
      setImportSummary("");
    }
  };

  // Handler for starting the import process
  const handleStartImport = async (userName: string) => {
    console.log('[useChatGptImport] handleStartImport chamado. importMode:', importMode, '| importUserName:', userName, '| importFile:', !!importFile);

    if (!importFile) return;
    
    setIsImporting(true);
    setImportProgress(0);
    setImportStage(""); // Clear stage on new import
    setImportSummary("");
    
    try {
      // Read file as buffer
      const fileBuffer = await importFile.arrayBuffer();
      
      type ProgressData = { processed: number; total: number; percentage?: number; stage?: string };

      // Vamos usar a solu√ß√£o original com uma pequena modifica√ß√£o
      // para evitar pulos bruscos
      
      // Armazenar o √∫ltimo percentual para evitar regress√£o
      let lastPercent = 0;
      
      // Get current application mode to pass to import process
      const applicationMode = ModeService.getMode();
      console.log('[useChatGptImport] Using applicationMode:', applicationMode);
      
      const result = await window.electronAPI.importChatHistory({
        fileBuffer,
        mode: importMode,
        user: userName,
        applicationMode,
        onProgress: (data: ProgressData) => {
          // Usar o percentual enviado ou calcular
          let percent = data.percentage !== undefined 
            ? data.percentage 
            : Math.round((data.processed / Math.max(1, data.total)) * 100);
          
          // Garantir que o progresso nunca regride
          if (percent < lastPercent && lastPercent < 95) {
            percent = lastPercent;
          } else {
            lastPercent = percent;
          }
          
          // Atualizar o estado
          setImportProgress(percent);
          if (data.stage) setImportStage(data.stage);
          
          // Atualizar o t√≠tulo e log
          document.title = `Importing... ${percent}%`;
          console.log(`[RENDERER] Progress: ${percent}% (${data.processed}/${data.total}) | Stage: ${data.stage || ''}`);
        },
      });
      
      // Ensure progress bar is visible for at least a minimum duration
      const minDisplay = process.env.NODE_ENV === 'test' ? 1000 : 200;
      await new Promise(res => setTimeout(res, minDisplay));
      
      setIsImporting(false);
      setImportProgress(100);
      
      // Update summary based on result
      if (result?.imported !== undefined && result?.skipped !== undefined) {
        setImportSummary(`Import complete! Imported: ${result.imported}, Skipped: ${result.skipped}`);
        showToast("Import complete", `Imported: ${result.imported}, Ignored: ${result.skipped}`, "success");
      } else if (result?.success) {
        setImportSummary('Import complete!');
        showToast("Import complete", "Process completed successfully", "success");
      } else {
        setImportSummary(`Error: ${result?.error || "Unknown failure"}`);
        showToast("Error", result?.error || "Unknown failure", "error");
      }
    } catch (err: unknown) {
      setIsImporting(false);
      let errorMsg = "Import failed";
      if (err instanceof Error) {
        errorMsg = err.message;
      } else if (typeof err === "string") {
        errorMsg = err;
      }
      setImportSummary(`Error: ${errorMsg}`);
      showToast("Error", errorMsg, "error");
    }
  };

  // Handler to close import modal
  const handleCloseImportModal = () => {
    setShowImportModal(false);
    setImportFile(null);
    setImportProgress(0);
    setImportSummary("");
    setIsImporting(false);
  };

  return {
    // State
    importFile,
    setImportFile,
    importUserName,
    setImportUserName,
    importMode,
    setImportMode,
    importProgress,
    importStage,
    importSummary,
    isImporting,
    showImportModal,
    setShowImportModal,
    
    // Methods
    handleFileChange,
    handleStartImport,
    handleCloseImportModal
  };
};
// SPDX-License-Identifier: MIT OR Apache-2.0
// Copyright (c) 2025 Guilherme Ferrari Brescia

import { useCallback, useContext, useEffect, useRef, useState } from "react";
import { useToast } from "../../../../App";
import {
  ConnectionState,
  MicrophoneState,
  useDeepgram,
  useMicrophone,
  useTranscription,
} from "../../../context";
import { LanguageContext } from "../../../context/LanguageContext";
// We're directly using the transcription context's texts object
// so no need to import the TranscriptionTextsState interface

export const useTranscriptionManager = () => {
  const transcriptionContext = useTranscription();
  if (!transcriptionContext) return null;

  const { texts, setTexts } = transcriptionContext;

  // Always use LanguageContext, which now syncs with storage
  const { language, setLanguage } = useContext(LanguageContext);
  const { showToast } = useToast();

  const {
    microphoneState,
    getCurrentMicrophoneState,
    startMicrophone,
    stopMicrophone,
    audioDevices,
    selectedDevices,
    handleDeviceChange,
    isMicrophoneOn,
    isSystemAudioOn,
    setIsMicrophoneOn,
    setIsSystemAudioOn,
  } = useMicrophone();

  const {
    connectionState,
    sendTranscriptionPrompt,
    sendDirectMessage,
    connectToDeepgram,
    disconnectFromDeepgram,
    waitForConnectionState,
    getConnectionStatus,
    hasActiveConnection,
    flushTranscriptionsToUI,
    clearTranscriptionData,
    transcriptionService,
  } = useDeepgram();

  // Memoized utility functions to prevent recreating on every render
  const clearTranscription = useCallback(() => {
    console.log("üßπ [CLEAR_TRANSCRIPTION] Clearing all transcription data");

    // Clear UI state
    setTexts((prev) => ({ ...prev, transcription: "" }));

    // Clear service-level data if available
    if (clearTranscriptionData) {
      clearTranscriptionData();
    }

    // Also clear the TranscriptionStorageService data
    if (transcriptionService?.clearTranscriptionData) {
      console.log("üßπ Clearing TranscriptionStorageService data");
      transcriptionService.clearTranscriptionData();
    }
  }, [setTexts, clearTranscriptionData, transcriptionService]);

  const clearAiResponse = useCallback(
    () => setTexts((prev) => ({ ...prev, aiResponse: "" })),
    [setTexts]
  );

  const [showDetailedDiagnostics, setShowDetailedDiagnostics] = useState(false);
  const [connectionDetails, setConnectionDetails] = useState<Record<
    string,
    unknown
  > | null>(null);
  const [temporaryContext, setTemporaryContext] = useState<string>("");
  const [isExpanded, setIsExpanded] = useState<boolean>(false);
  const [isLocalProcessing, setIsLocalProcessing] = useState<boolean>(false);
  const temporaryContextRef = useRef<string>("");
  const transcriptionRef = useRef<HTMLTextAreaElement>(null);

  useEffect(() => {
    temporaryContextRef.current = temporaryContext;
  }, [temporaryContext]);

  useEffect(() => {
    if (transcriptionRef.current) {
      transcriptionRef.current.scrollTop =
        transcriptionRef.current.scrollHeight;
    }
  }, [texts.transcription]);

  useEffect(() => {
    if (!showDetailedDiagnostics) return;

    const intervalId = setInterval(() => {
      if (getConnectionStatus) {
        setConnectionDetails(getConnectionStatus());
      }
    }, 1000);

    return () => clearInterval(intervalId);
  }, [showDetailedDiagnostics, getConnectionStatus]);

  // Setup electron listeners for transcription events
  useEffect(() => {
    if (typeof window !== "undefined" && window.electronAPI) {
      const removeListener = window.electronAPI.onRealtimeTranscription(
        (text) => {
          setTexts((prev) => {
            const newTranscription = prev.transcription
              ? `${prev.transcription}\n${text}`
              : text;

            return {
              ...prev,
              transcription: newTranscription,
            };
          });
        }
      );

      return () => {
        removeListener();
      };
    }
  }, []);

  // Memoized toggleRecording to prevent recreating on every render
  const toggleRecording = useCallback(async () => {
    const currentState = getCurrentMicrophoneState();
    console.log("üîä Button clicked! Microphone state:", currentState);

    if (currentState === MicrophoneState.Open) {
      console.log("üö´ Stopping recording via button...");
      stopMicrophone();

      // Clear transcriptions when stopping recording
      console.log("üßπ Clearing transcriptions after stopping recording");
      clearTranscription();

      // Also clear the TranscriptionStorageService data
      if (transcriptionService?.clearTranscriptionData) {
        console.log("üßπ Clearing TranscriptionStorageService data");
        transcriptionService.clearTranscriptionData();
      }
    } else {
      console.log("üé§ Starting recording via button...");

      // Clear both UI and service data before starting a new recording
      console.log(
        "üßπ Clearing all previous transcription data for a fresh start."
      );
      clearTranscription(); // Clears UI state from TranscriptionContext
      if (clearTranscriptionData) {
        clearTranscriptionData(); // Clears service-level data from DeepgramContext
      }

      // Also clear the TranscriptionStorageService data
      if (transcriptionService?.clearTranscriptionData) {
        console.log(
          "üßπ Clearing TranscriptionStorageService data before starting"
        );
        transcriptionService.clearTranscriptionData();
      }

      // If no audio source is active, enable system audio by default before recording
      if (!isMicrophoneOn && !isSystemAudioOn) {
        setIsSystemAudioOn(true);
        setTimeout(() => startMicrophone(), 100);
      } else {
        startMicrophone();
      }
    }
  }, [
    getCurrentMicrophoneState,
    stopMicrophone,
    startMicrophone,
    isMicrophoneOn,
    isSystemAudioOn,
    setIsSystemAudioOn,
    clearTranscriptionData,
    clearTranscription,
    transcriptionService,
  ]);

  // Memoize handleSendPrompt to prevent recreating on every render
  const handleSendPrompt = useCallback(
    async (messageContent?: string, contextContent?: string) => {
      // Prote√ß√£o de duplica√ß√£o agora √© feita no DeepgramContext (global)

      try {
        // Set state for UI updates (e.g., disabling button visually)
        setIsLocalProcessing(true);

        // Check if there's any content to send
        const currentTranscription = texts.transcription?.trim();
        if (!messageContent && !currentTranscription) {
          console.warn("‚ö†Ô∏è [SEND_PROMPT] No content to send");
          showToast("Aviso", "Nenhuma mensagem para enviar", "neutral");
          setIsLocalProcessing(false);
          return;
        }

        console.log("üöÄ [SEND_PROMPT] Starting prompt send:", {
          messageContent,
          contextContent,
          temporaryContext: temporaryContextRef.current,
          hasDirectMessage: !!messageContent,
          hasTranscription: !!currentTranscription,
          timestamp: new Date().toISOString(),
        });

        // If it's a direct message (from chat input), use sendDirectMessage
        if (messageContent) {
          console.log("üí¨ [SEND_PROMPT] Sending as direct message");
          await sendDirectMessage(
            messageContent,
            contextContent || temporaryContextRef.current
          );
        } else {
          // Otherwise, use the transcription-based prompt
          // Only flush transcriptions when we have actual transcriptions
          if (flushTranscriptionsToUI && currentTranscription) {
            console.log("üì§ [SEND_PROMPT] Flushing transcriptions before send");
            flushTranscriptionsToUI();
          }

          console.log("üéØ [SEND_PROMPT] Sending as transcription prompt");
          await sendTranscriptionPrompt(temporaryContextRef.current);
        }

        console.log("‚úÖ [SEND_PROMPT] Prompt send completed successfully");
      } catch (error) {
        const errorMessage =
          error instanceof Error
            ? error.message === "PROCESSING_IN_PROGRESS"
              ? "Um processamento j√° est√° em andamento. Aguarde a conclus√£o."
              : error.message
            : "Erro desconhecido ao processar o prompt";

        console.error("‚ùå [SEND_PROMPT] Error sending prompt:", error);
        showToast("Erro", errorMessage, "error");
      } finally {
        // Always clear state
        setIsLocalProcessing(false);
      }
    },
    [
      sendTranscriptionPrompt,
      sendDirectMessage,
      showToast,
      flushTranscriptionsToUI,
      texts.transcription,
      clearTranscriptionData,
      clearTranscription,
    ]
  );

  // Setup electron listeners for AI prompt responses (FIXED: No dependencies)
  useEffect(() => {
    if (typeof window !== "undefined" && window.electronAPI) {
      // Track response accumulation
      let responseBuffer = "";
      let isAccumulatingResponse = false;

      // Create stable callbacks that don't depend on changing state
      const handlePartialResponse = (partialResponse: string) => {
        console.log("üîÑ [IPC] Partial response received:", {
          response: partialResponse.substring(0, 50),
          length: partialResponse.length,
          timestamp: new Date().toISOString(),
        });

        // Mark that we're accumulating a response
        isAccumulatingResponse = true;
        responseBuffer = partialResponse;

        // Update with the partial response
        // Don't clear it - let the component decide when to clear
        setTexts((prev) => ({
          ...prev,
          aiResponse: partialResponse,
        }));
      };

      const handleSuccessResponse = (finalResponse: string) => {
        console.log("‚úÖ [IPC] Final response received:", {
          response: finalResponse.substring(0, 50),
          length: finalResponse.length,
          timestamp: new Date().toISOString(),
        });

        // Clear accumulation state
        isAccumulatingResponse = false;
        responseBuffer = "";

        // Set the final response WITHOUT clearing transcription
        // This allows new transcriptions to continue appearing
        setTexts((prev) => ({
          ...prev,
          aiResponse: finalResponse,
        }));
      };

      const handleErrorResponse = (error: string) => {
        console.log("‚ùå [IPC] Error response received:", {
          error,
          timestamp: new Date().toISOString(),
        });

        // Clear accumulation state
        isAccumulatingResponse = false;
        responseBuffer = "";

        setTexts((prev) => ({
          ...prev,
          aiResponse: `Erro: ${error}`,
        }));
        showToast("Erro", error, "error");
      };

      const handleSendingState = () => {
        console.log("üîÑ [IPC] Sending state received:", {
          timestamp: new Date().toISOString(),
        });

        // Reset accumulation state when starting a new request
        isAccumulatingResponse = false;
        responseBuffer = "";

        setTexts((prev) => ({
          ...prev,
          aiResponse: "Processando...",
        }));
      };

      const removePartialListener = window.electronAPI.onPromptPartialResponse(
        handlePartialResponse
      );
      const removeSuccessListener = window.electronAPI.onPromptSuccess(
        handleSuccessResponse
      );
      const removeErrorListener =
        window.electronAPI.onPromptError(handleErrorResponse);
      const removeSendingListener =
        window.electronAPI.onPromptSending(handleSendingState);

      return () => {
        removePartialListener();
        removeSuccessListener();
        removeErrorListener();
        removeSendingListener();
      };
    }
  }, [setTexts, showToast]);

  // Update Deepgram language when UI language changes
  useEffect(() => {
    if (language) {
      console.log(
        `üåê Language changed to ${language}, will use on next connection`
      );
    }
  }, [language]);

  useEffect(() => {
    if (microphoneState === MicrophoneState.Error) {
      showToast(
        "Error",
        "Failed to access audio. Check your microphone and permissions.",
        "error"
      );
    }
  }, [microphoneState]);

  const toggleExpand = useCallback(() => {
    setIsExpanded(!isExpanded);
  }, [isExpanded, setIsExpanded]);

  return {
    language,
    setLanguage,
    microphoneState,
    connectionState,
    toggleRecording,
    handleSendPrompt,
    clearTranscription,
    clearAiResponse,
    toggleExpand,
    isExpanded,
    temporaryContext,
    setTemporaryContext,
    texts,
    setTexts,
    audioDevices,
    selectedDevices,
    handleDeviceChange,
    isMicrophoneOn,
    isSystemAudioOn,
    setIsMicrophoneOn,
    setIsSystemAudioOn,
    showDetailedDiagnostics,
    setShowDetailedDiagnostics,
    connectionDetails,
    setConnectionDetails,
    transcriptionRef,
    getConnectionStatus,
    disconnectFromDeepgram,
    connectToDeepgram,
    waitForConnectionState,
    hasActiveConnection,
    ConnectionState,
    clearTranscriptionData,
    isLocalProcessing,
  };
};
// SPDX-License-Identifier: MIT OR Apache-2.0
// Copyright (c) 2025 Guilherme Ferrari Brescia

import { EventEmitter } from 'events';
import { ModeService } from '../../../../services/ModeService';
import { IChatGptImportService, ImportMode, ImportProgressData } from '../types/interfaces';

// Implementation of the import service (Single Responsibility Principle)
export class ChatGptImportService implements IChatGptImportService {
  private progressEmitter: EventEmitter;

  constructor() {
    this.progressEmitter = new EventEmitter();
  }

  async importChatHistory(options: {
    fileBuffer: ArrayBuffer | Buffer;
    mode: ImportMode;
    user: string;
    onProgress?: (data: ImportProgressData) => void;
  }): Promise<{ success: boolean; error?: string; imported?: number; skipped?: number }> {
    try {
      // Call the actual electronAPI import method
      if (typeof window !== 'undefined' && window.electronAPI) {
        // Get current application mode from ModeService
        const currentApplicationMode = ModeService.getMode();
        
        // Debug logging for mode detection
        console.log('üîç [ChatGptImportService] Raw ModeService.getMode():', currentApplicationMode);
        console.log('üîç [ChatGptImportService] typeof currentApplicationMode:', typeof currentApplicationMode);
        
        // Convert enum to string if needed
        const applicationModeString = currentApplicationMode === 'basic' ? 'basic' : 
                                      currentApplicationMode === 'advanced' ? 'advanced' :
                                      String(currentApplicationMode);
        
        console.log('üîç [ChatGptImportService] Final applicationMode string:', applicationModeString);
        
        const result = await window.electronAPI.importChatHistory({
          fileBuffer: options.fileBuffer,
          mode: options.mode,
          user: options.user,
          applicationMode: currentApplicationMode,
          onProgress: options.onProgress,
        });
        
        // Return the result obtained from the API
        return {
          success: result.success ?? false,
          imported: result.imported ?? 0,
          skipped: result.skipped ?? 0,
          error: result.error
        };
      } else {
        throw new Error("Electron API not available");
      }
    } catch (error) {
      console.error("Error in ChatGptImportService:", error);
      let errorMsg = "Import failed";
      if (error instanceof Error) {
        errorMsg = error.message;
      } else if (typeof error === "string") {
        errorMsg = error;
      }
      // Return object with basic fields
      return { 
        error: errorMsg, 
        success: false,
        imported: 0,
        skipped: 0
      };
    }
  }
}

// Singleton instance for the service (Single Responsibility Principle)
const chatGptImportService = new ChatGptImportService();
export default chatGptImportService;
/* SPDX-License-Identifier: MIT OR Apache-2.0
 * Copyright (c) 2025 Guilherme Ferrari Brescia
 */

.orchos-quantum-dashboard::before {
  content: '';
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background-image: 
    radial-gradient(circle at 20% 50%, rgba(0, 250, 255, 0.1) 0%, transparent 2%),
    radial-gradient(circle at 80% 80%, rgba(255, 0, 128, 0.08) 0%, transparent 2%),
    radial-gradient(circle at 40% 80%, rgba(120, 119, 198, 0.1) 0%, transparent 2%);
  background-size: 400px 400px;
  animation: quantumDrift 20s ease-in-out infinite;
  pointer-events: none;
  opacity: 0.4;
}

@keyframes quantumDrift {
  0%, 100% { transform: translate(0, 0) scale(1); opacity: 0.4; }
  25% { transform: translate(30px, -20px) scale(1.1); opacity: 0.5; }
  50% { transform: translate(-20px, 30px) scale(0.9); opacity: 0.3; }
  75% { transform: translate(-30px, -10px) scale(1.05); opacity: 0.45; }
}

.quantum-visualization-zone::after {
  content: '';
  position: absolute;
  top: -50%;
  left: -50%;
  width: 200%;
  height: 200%;
  background: linear-gradient(
    45deg,
    transparent 30%,
    rgba(0, 250, 255, 0.03) 50%,
    transparent 70%
  );
  animation: holographicShimmer 8s linear infinite;
  pointer-events: none;
}

@keyframes holographicShimmer {
  0% { transform: translateX(-100%) translateY(-100%) rotate(0deg); }
  100% { transform: translateX(100%) translateY(100%) rotate(360deg); }
}

.quantum-visualization-zone::before {
  content: '';
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  width: 300px;
  height: 300px;
  background: radial-gradient(circle, rgba(0,250,255,0.15) 0%, transparent 70%);
  filter: blur(60px);
  animation: quantumPulse 4s ease-in-out infinite;
  pointer-events: none;
}

@keyframes quantumPulse {
  0%, 100% { opacity: 0.3; transform: translate(-50%, -50%) scale(1); }
  50% { opacity: 0.6; transform: translate(-50%, -50%) scale(1.2); }
}

@keyframes recordingPulse {
  0%, 100% { transform: scale(1); }
  50% { transform: scale(1.1); }
}

.ripple {
  position: absolute;
  border-radius: 50%;
  background: radial-gradient(circle, rgba(0, 250, 255, 0.3) 0%, transparent 70%);
  transform: scale(0);
  animation: rippleEffect 0.6s ease-out;
  pointer-events: none;
}

@keyframes rippleEffect {
  to {
    transform: scale(4);
    opacity: 0;
  }
}

.orchos-tooltip::after {
  content: '';
  position: absolute;
  width: 100%;
  height: 100%;
  left: 0;
  top: 0;
  border-radius: inherit;
  background: linear-gradient(135deg, 
    rgba(255, 77, 210, 0.1) 0%, 
    rgba(0, 250, 255, 0.1) 50%,
    rgba(124, 77, 255, 0.1) 100%);
  opacity: 0;
  z-index: -1;
  animation: neuralGradient 8s ease-in-out infinite;
}

@keyframes neuralGradient {
  0%, 100% { opacity: 0.1; transform: rotate(0deg); }
  50% { opacity: 0.3; transform: rotate(180deg); }
}

.orchos-quantum-btn {
  position: relative;
  width: 48px;
  height: 48px;
  min-width: 48px;
  min-height: 48px;
  padding: 0;
  background: var(--quantum-bg-dark);
  border: 2px solid transparent;
  border-radius: 50%;
  cursor: pointer;
  overflow: hidden;
  transition: all 0.3s var(--quantum-cubic);
  -webkit-backdrop-filter: blur(20px) saturate(180%);
  backdrop-filter: blur(20px) saturate(180%);
  box-shadow: 
    0 0 30px rgba(0, 250, 255, 0.2),
    inset 0 0 20px rgba(0, 250, 255, 0.1),
    0 4px 20px rgba(0, 0, 0, 0.5);
  animation: neuralBreathing 6s ease-in-out infinite;
}

@keyframes neuralBreathing {
  0%, 100% { transform: scale(0.98); }
  50% { transform: scale(1.02); }
}

.orchos-quantum-btn:hover {
  animation: none;
  transform: scale(1.08) translateZ(var(--quantum-depth-2));
  box-shadow: 
    0 0 50px rgba(0, 250, 255, 0.4),
    inset 0 0 30px rgba(0, 250, 255, 0.2),
    0 8px 30px rgba(0, 0, 0, 0.6);
}

.orchos-quantum-btn::before {
  content: '';
  position: absolute;
  inset: -2px;
  border-radius: 50%;
  padding: 2px;
  background: linear-gradient(135deg, 
    #ff4dd2 0%, 
    #00faff 33%, 
    #7c4dff 66%, 
    #ff4dd2 100%
  );
  

/* Cross-browser mask support */


  -webkit-mask: linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);
  -webkit-mask-composite: xor;
  mask: linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);
  mask-composite: exclude;
  opacity: 0.7;
  animation: quantumBorderRotate 4s linear infinite;
}

@keyframes quantumBorderRotate {
  0% { transform: rotate(0deg); }
  100% { transform: rotate(360deg); }
}

.orchos-quantum-particles::before,
.orchos-quantum-particles::after {
  content: '';
  position: absolute;
  width: 2px;
  height: 2px;
  background: var(--active-color, #00faff);
  border-radius: 50%;
  box-shadow: 
    0 0 4px var(--active-color, #00faff),
    0 0 8px var(--active-color, #00faff);
  animation: quantumFloat 4s ease-in-out infinite;
  opacity: 0.7;
}

.orchos-quantum-particles::before {
  top: 25%;
  left: 30%;
  animation-delay: 0s;
}

.orchos-quantum-particles::after {
  bottom: 30%;
  right: 25%;
  animation-delay: 2s;
}

.orchos-quantum-btn::after {
  content: '';
  position: absolute;
  top: 60%;
  left: 15%;
  width: 2px;
  height: 2px;
  background: var(--active-color, #00faff);
  border-radius: 50%;
  box-shadow: 
    0 0 4px var(--active-color, #00faff),
    0 0 8px var(--active-color, #00faff);
  animation: quantumFloat 4.5s ease-in-out infinite;
  animation-delay: 1s;
  z-index: 2;
  opacity: 0.7;
}

.orchos-quantum-btn::before {
  content: '';
  position: absolute;
  top: 20%;
  right: 25%;
  width: 2px;
  height: 2px;
  background: var(--active-color, #00faff);
  border-radius: 50%;
  box-shadow: 
    0 0 4px var(--active-color, #00faff),
    0 0 8px var(--active-color, #00faff);
  animation: quantumFloat 5s ease-in-out infinite;
  animation-delay: 2.5s;
  z-index: 2;
  opacity: 0.7;
}

@keyframes quantumFloat {
  0%, 100% {
    transform: translate(0, 0) scale(1);
    opacity: 0.3;
  }
  50% {
    transform: translate(10px, -10px) scale(1.5);
    opacity: 1;
  }
}

@keyframes neuralParticleActive {
  0%, 100% {
    transform: translate(0, 0) scale(1);
    opacity: 0.6;
  }
  25% {
    transform: translate(15px, -5px) scale(2);
    opacity: 1;
  }
  50% {
    transform: translate(5px, -15px) scale(1.2);
    opacity: 0.8;
  }
  75% {
    transform: translate(-10px, -8px) scale(1.8);
    opacity: 0.9;
  }
}

.orchos-neural-ring {
  position: absolute;
  inset: 3px;
  border-radius: 50%;
  background: radial-gradient(circle at center,
    transparent 0%,
    transparent 40%,
    rgba(0, 250, 255, 0.1) 50%,
    transparent 60%
  );
  animation: neuralPulse 2s ease-in-out infinite;
}

@keyframes neuralPulse {
  0%, 100% {
    transform: scale(1);
    opacity: 0.5;
  }
  50% {
    transform: scale(1.2);
    opacity: 1;
  }
}

@keyframes recordingPulse {
  0%, 100% {
    box-shadow: 
      0 0 30px rgba(255, 77, 210, 0.4),
      inset 0 0 20px rgba(255, 77, 210, 0.2),
      0 4px 20px rgba(0, 0, 0, 0.5);
  }
  50% {
    box-shadow: 
      0 0 50px rgba(255, 77, 210, 0.8),
      inset 0 0 30px rgba(255, 77, 210, 0.5),
      0 4px 20px rgba(0, 0, 0, 0.5);
    transform: scale(1.05);
  }
}

.orchos-quantum-btn:active::after,
.orchos-quantum-btn:active::before {
  animation: synapticBurst 0.5s ease-out forwards;
}

@keyframes synapticBurst {
  0% { transform: scale(1); opacity: 0.7; }
  100% { transform: scale(6); opacity: 0; }
}

.orchos-btn-record:hover .neural-wave {
  animation-duration: 4s;
  opacity: 0.9;
}

.orchos-btn-send:hover .neural-send-wave {
  animation-duration: 3s;
  opacity: 0.9;
}

.orchos-btn-send:hover .neural-send-arrow {
  animation-duration: 1.5s;
  opacity: 1;
}

.settings-btn:hover svg circle:nth-of-type(1) {
  animation: qNodePulse 2s infinite alternate ease-in-out;
}

.settings-btn:hover svg circle:nth-of-type(2) {
  animation: orbitalSpin 8s infinite linear;
}

.settings-btn:hover svg circle:nth-of-type(3),
.settings-btn:hover svg circle:nth-of-type(4),
.settings-btn:hover svg circle:nth-of-type(5),
.settings-btn:hover svg circle:nth-of-type(6) {
  animation: connectionPulse 3s infinite alternate ease-in-out;
}

@keyframes qNodePulse {
  0% { r: 3; fill: rgba(0, 250, 255, 0.2); }
  100% { r: 3.5; fill: rgba(0, 250, 255, 0.4); }
}

@keyframes orbitalSpin {
  0% { transform: rotate(0deg) translate(10px, 10px); }
  100% { transform: rotate(360deg) translate(10px, 10px); }
}

@keyframes connectionPulse {
  0% { r: 1.5; fill: rgba(0, 250, 255, 0.7); }
  100% { r: 1.8; fill: #00faff; }
}

.neural-settings-popup {
  animation: settingsPopupReveal 0.3s ease-out forwards;
  transform-origin: top right;
}

@keyframes settingsPopupReveal {
  0% { opacity: 0; transform: scale(0.9); }
  100% { opacity: 1; transform: scale(1); }
}

.neural-wave {
  opacity: 0.7;
  stroke-dasharray: 10;
  animation: neuralWaveConverge 6s ease-in-out infinite;
}

.wave-1 { animation-delay: 0s; }

.wave-2 { animation-delay: 0.7s; }

.wave-3 { animation-delay: 1.4s; }

.wave-4 { animation-delay: 2.1s; }

.wave-5 { animation-delay: 2.8s; }

.wave-6 { animation-delay: 3.5s; }

.wave-7 { animation-delay: 4.2s; }

.wave-8 { animation-delay: 4.9s; }

@keyframes neuralWaveConverge {
  0% {
    stroke-dashoffset: 40;
    opacity: 0.3;
    stroke-width: 1px;
  }
  50% {
    opacity: 0.9;
    stroke-width: 1.75px;
  }
  100% {
    stroke-dashoffset: 0;
    opacity: 0.3;
    stroke-width: 1px;
  }
}

.neural-send-wave {
  opacity: 0.7;
  stroke-dasharray: 12;
  animation: neuralWaveDiverge 5s ease-in-out infinite;
}

.neural-send-arrow {
  opacity: 0.8;
  animation: neuralSendPulse 3s ease-in-out infinite;
}

@keyframes neuralWaveDiverge {
  0% {
    stroke-dashoffset: 0;
    opacity: 0.3;
    stroke-width: 1px;
  }
  50% {
    opacity: 0.9;
    stroke-width: 1.75px;
  }
  100% {
    stroke-dashoffset: 40;
    opacity: 0.3;
    stroke-width: 1px;
  }
}

@keyframes neuralSendPulse {
  0%, 100% {
    opacity: 0.6;
    transform: translateX(0);
  }
  50% {
    opacity: 1;
    transform: translateX(2px);
  }
}

.neural-core-record {
  animation: coreRecordPulse 4s ease-in-out infinite;
}

.neural-core-send {
  animation: coreSendPulse 4s ease-in-out infinite;
}

@keyframes coreRecordPulse {
  0%, 100% {
    r: 5;
    opacity: 0.8;
  }
  50% {
    r: 5.5;
    opacity: 1;
  }
}

@keyframes coreSendPulse {
  0%, 100% {
    r: 3;
    opacity: 0.8;
  }
  50% {
    r: 3.3;
    opacity: 1;
  }
}

@keyframes activeRecordPulse {
  0%, 100% {
    r: 5;
    opacity: 0.9;
  }
  50% {
    r: 6;
    opacity: 1;
    filter: drop-shadow(0 0 8px var(--quantum-record-active));
  }
}

.orchos-quantum-ripple {
  position: absolute;
  border-radius: 50%;
  transform: translate(-50%, -50%);
  background: radial-gradient(circle, 
    rgba(0, 250, 255, 0.4) 0%, 
    rgba(124, 77, 255, 0.2) 50%, 
    transparent 70%
  );
  pointer-events: none;
  animation: quantumRippleExpand 1s ease-out forwards;
}

@keyframes quantumRippleExpand {
  0% {
    width: 0;
    height: 0;
    opacity: 1;
  }
  100% {
    width: 200px;
    height: 200px;
    opacity: 0;
  }
}

@media (prefers-reduced-motion: reduce) {
  .orchos-quantum-btn,
  .orchos-quantum-btn::before,
  .orchos-neural-ring,
  .orchos-quantum-particles::before,
  .orchos-quantum-particles::after {
    animation: none !important;
    transition: none !important;
  }
  
  .orchos-quantum-btn {
    transition: transform 0.2s ease;
  }
}

/* Card entrance animation */
@keyframes slideInUp {
  from {
    opacity: 0;
    transform: translateY(20px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
}

/* Transcription display animation */
@keyframes transcriptionFadeIn {
  from {
    opacity: 0;
    transform: translateY(-10px);
    max-height: 0;
  }
  to {
    opacity: 1;
    transform: translateY(0);
    max-height: 150px;
  }
}

@keyframes transcriptionFadeOut {
  from {
    opacity: 1;
    transform: translateY(0);
    max-height: 150px;
  }
  to {
    opacity: 0;
    transform: translateY(-10px);
    max-height: 0;
  }
}

.transcription-display {
  animation: transcriptionFadeIn 0.3s ease-out forwards;
}

.transcription-display.hiding {
  animation: transcriptionFadeOut 0.3s ease-out forwards;
}

/* Quantum glow effect */
@keyframes quantumGlow {
  0%, 100% {
    filter: drop-shadow(0 0 20px rgba(0, 250, 255, 0.5));
  }
  50% {
    filter: drop-shadow(0 0 40px rgba(0, 250, 255, 0.8));
  }
}

/* Button hover animations */
@keyframes buttonPulse {
  0% {
    box-shadow: 0 0 0 0 rgba(0, 250, 255, 0.7);
  }
  70% {
    box-shadow: 0 0 0 10px rgba(0, 250, 255, 0);
  }
  100% {
    box-shadow: 0 0 0 0 rgba(0, 250, 255, 0);
  }
}

/* Loading spinner */
@keyframes spin {
  to {
    transform: rotate(360deg);
  }
}

/* Text shimmer effect */
@keyframes shimmer {
  0% {
    background-position: -200% center;
  }
  100% {
    background-position: 200% center;
  }
}

/* Connection state animations */
@keyframes connectionPulse {
  0%, 100% {
    opacity: 1;
  }
  50% {
    opacity: 0.5;
  }
}

/* Card glow animation */
.neural-card {
  animation: slideInUp 0.3s ease-out;
}

/* Button active state */
.control-btn:active {
  animation: buttonPulse 0.3s ease-out;
}

/* Loading state */
.loading {
  animation: spin 1s linear infinite;
}

/* Connection indicator */
.connection-indicator {
  animation: connectionPulse 2s ease-in-out infinite;
}

/* Quantum visualization container animation */
.quantum-visualization-zone {
  animation: quantumGlow 3s ease-in-out infinite;
}

/* Text animation for AI responses */
.ai-response-text {
  background: linear-gradient(
    90deg,
    #00faff 0%,
    #7c4dff 50%,
    #00faff 100%
  );
  background-size: 200% auto;
  -webkit-background-clip: text;
  background-clip: text;
  -webkit-text-fill-color: transparent;
  animation: shimmer 3s linear infinite;
}

/* Smooth transitions for all interactive elements */
.control-btn,
.neural-card,
.transcription-display,
.settings-popup {
  transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
}

/* Hover lift effect */
.neural-card:hover {
  transform: translateY(-2px);
  box-shadow: 
    0 12px 24px rgba(0, 250, 255, 0.15),
    0 0 0 1px rgba(0, 250, 255, 0.3);
}

/* Recording animation */
@keyframes recordingPulse {
  0%, 100% {
    box-shadow: 0 0 0 0 rgba(255, 68, 85, 0.7);
  }
  50% {
    box-shadow: 0 0 0 20px rgba(255, 68, 85, 0);
  }
}

.mic-btn.recording {
  animation: recordingPulse 1.5s ease-in-out infinite;
}

/* Settings popup animation */
@keyframes settingsSlideIn {
  from {
    opacity: 0;
    transform: translateX(20px);
  }
  to {
    opacity: 1;
    transform: translateX(0);
  }
}

.settings-popup {
  animation: settingsSlideIn 0.2s ease-out;
}

/* Tooltip animation */
@keyframes tooltipFadeIn {
  from {
    opacity: 0;
    transform: translateY(5px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
}

.tooltip {
  animation: tooltipFadeIn 0.2s ease-out;
}
/* SPDX-License-Identifier: MIT OR Apache-2.0
 * Copyright (c) 2025 Guilherme Ferrari Brescia
 */

.orchos-btn-circular, .orchos-btn-fab, .orchos-btn-glass {
  border-radius: 999px !important;
}

.orchos-btn-fab {
  background: rgba(24,24,40,0.82);
  border: 3px solid #00faff;
  box-shadow: 0 0 24px 8px #00faff33, 0 0 0 0 #fff0;
  color: #00faff;
  font-weight: 600;
  font-size: 1.1rem;
  transition: box-shadow 0.22s, background 0.22s, border-color 0.22s;
}

.orchos-btn-fab:focus, .orchos-btn-fab:hover {
  background: rgba(0, 245, 255, 0.12);
  box-shadow: 0 0 36px 12px #00faff77, 0 0 0 3px #00faff55;
  border-color: #00faff;
}

.orchos-btn-circular {
  background: rgba(24, 24, 40, 0.60);
  border: 2px solid #00faff;
  box-shadow: 0 2px 16px 0 rgba(0,245,255,0.12);
  color: #00faff;
  min-width: 48px;
  min-height: 48px;
  display: flex;
  align-items: center;
  justify-content: center;
  transition: box-shadow 0.18s, background 0.18s, border-color 0.18s;
}

.orchos-btn-circular:focus, .orchos-btn-circular:hover {
  background: rgba(0, 245, 255, 0.12);
  box-shadow: 0 0 16px 4px #00faff77;
  border-color: #00faff;
}

/* Header button styling */

/* Enhanced Button Styles - Quantum Theme */

.neural-control-grid button {
  padding: 0.32rem 0.9rem !important;
  font-size: 0.74rem !important;
  min-height: 1.7rem !important;
  height: auto !important;
  background: 
    linear-gradient(
      135deg, 
      rgba(255, 255, 255, 0.03) 0%, 
      rgba(255, 255, 255, 0.01) 100%
    );
  border: 1px solid rgba(255, 255, 255, 0.07);
  color: rgba(255, 255, 255, 0.88);
  font-weight: 500;
  letter-spacing: 0.02em;
  transition: all 0.3s cubic-bezier(0.23, 1, 0.32, 1);
  position: relative;
  overflow: hidden;
  border-radius: 0.6rem;
  -webkit-backdrop-filter: blur(16px);
  backdrop-filter: blur(16px);
  transform-style: preserve-3d;
}

.neural-control-grid button::before {
  content: '';
  position: absolute;
  top: 0;
  left: -100%;
  width: 100%;
  height: 100%;
  background: linear-gradient(90deg, transparent, rgba(0, 250, 255, 0.2), transparent);
  transition: left 0.5s ease;
}

.neural-control-grid button:hover {
  background: linear-gradient(135deg, rgba(0, 250, 255, 0.2) 0%, rgba(0, 250, 255, 0.1) 100%);
  border-color: rgba(0, 250, 255, 0.5);
  box-shadow: 0 0 20px rgba(0, 250, 255, 0.3);
  transform: translateY(-1px);
}

.neural-control-grid button:hover::before {
  left: 100%;
}

/* Recording button special styling */

/* Transcription card button layout */

/* Microinteractions - Click Ripple Effect */

.neural-control-grid button {
  position: relative;
  overflow: hidden;
}

.ripple {
  position: absolute;
  border-radius: 50%;
  background: radial-gradient(circle, rgba(0, 250, 255, 0.3) 0%, transparent 70%);
  transform: scale(0);
  animation: rippleEffect 0.6s ease-out;
  pointer-events: none;
}

.neural-control-grid button:focus,
.neural-control-grid input:focus,
.neural-control-grid textarea:focus {
  outline: none;
  box-shadow: 
    0 0 0 2px rgba(0, 250, 255, 0.3),
    0 0 20px rgba(0, 250, 255, 0.2);
}

@media (max-height: 800px) {
  .orchos-quantum-dashboard {
    padding: 0.2rem;
    gap: 0.2rem;
    height: calc(100vh - 2.5rem);
    padding-top: 2.5rem;
  }
  
  .neural-control-grid {
    gap: 0.2rem;
  }
  
  .neural-control-grid button {
    padding: 0.15rem 0.4rem !important;
    font-size: 0.65rem !important;
    min-height: 1.4rem !important;
  }
}

/* Quantum Action Buttons - LEGENDARY */

.orchos-quantum-btn:hover .orchos-tooltip,
.orchos-quantum-btn:focus .orchos-tooltip,
.orchos-quantum-btn:focus-visible .orchos-tooltip {
  opacity: 1;
  transform: translateX(-50%) scale(1);
  pointer-events: auto;
  box-shadow: 
    0 8px 32px 0 rgba(0,250,255,0.15), 
    0 2px 8px 0 rgba(124,77,255,0.15),
    inset 0 0 8px 0 rgba(0,250,255,0.1);
}

.orchos-quantum-btn {
  margin-top: -5px; /* Ajuste fino para alinhamento */
  position: relative;
  width: 48px;
  height: 48px;
  min-width: 48px;
  min-height: 48px;
  padding: 0;
  background: var(--quantum-bg-dark);
  border: 2px solid transparent;
  border-radius: 50%;
  cursor: pointer;
  overflow: hidden;
  transition: all 0.3s var(--quantum-cubic);
  -webkit-backdrop-filter: blur(20px) saturate(180%);
  backdrop-filter: blur(20px) saturate(180%);
  box-shadow: 
    0 0 30px rgba(0, 250, 255, 0.2),
    inset 0 0 20px rgba(0, 250, 255, 0.1),
    0 4px 20px rgba(0, 0, 0, 0.5);
  animation: neuralBreathing 6s ease-in-out infinite;
}

.orchos-quantum-btn:hover {
  animation: none;
  transform: scale(1.08) translateZ(var(--quantum-depth-2));
  box-shadow: 
    0 0 50px rgba(0, 250, 255, 0.4),
    inset 0 0 30px rgba(0, 250, 255, 0.2),
    0 8px 30px rgba(0, 0, 0, 0.6);
}

.orchos-quantum-btn:active {
  transform: scale(0.92);
  transition: all 0.1s var(--quantum-cubic);
}

.orchos-quantum-btn::before {
  content: '';
  position: absolute;
  inset: -2px;
  border-radius: 50%;
  padding: 2px;
  background: linear-gradient(135deg, 
    #ff4dd2 0%, 
    #00faff 33%, 
    #7c4dff 66%, 
    #ff4dd2 100%
  );
  

/* Cross-browser mask support */


  -webkit-mask: linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);
  -webkit-mask-composite: xor;
  mask: linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);
  mask-composite: exclude;
  opacity: 0.7;
  animation: quantumBorderRotate 4s linear infinite;
}

.orchos-quantum-btn:hover {
  transform: scale(1.1);
  box-shadow: 
    0 0 50px rgba(0, 250, 255, 0.4),
    inset 0 0 30px rgba(0, 250, 255, 0.2),
    0 8px 30px rgba(0, 0, 0, 0.6);
}

.orchos-quantum-btn:active {
  transform: scale(0.95);
}

.orchos-quantum-btn-inner {
  position: relative;
  width: 100%;
  height: 100%;
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 2;
}

.orchos-quantum-btn::after {
  content: '';
  position: absolute;
  top: 60%;
  left: 15%;
  width: 2px;
  height: 2px;
  background: var(--active-color, #00faff);
  border-radius: 50%;
  box-shadow: 
    0 0 4px var(--active-color, #00faff),
    0 0 8px var(--active-color, #00faff);
  animation: quantumFloat 4.5s ease-in-out infinite;
  animation-delay: 1s;
  z-index: 2;
  opacity: 0.7;
}

.orchos-quantum-btn:hover::after {
  width: 3px;
  height: 3px;
  opacity: 1;
}

.orchos-quantum-btn::before {
  content: '';
  position: absolute;
  top: 20%;
  right: 25%;
  width: 2px;
  height: 2px;
  background: var(--active-color, #00faff);
  border-radius: 50%;
  box-shadow: 
    0 0 4px var(--active-color, #00faff),
    0 0 8px var(--active-color, #00faff);
  animation: quantumFloat 5s ease-in-out infinite;
  animation-delay: 2.5s;
  z-index: 2;
  opacity: 0.7;
}

/* Record Button Specific */

.orchos-quantum-btn.orchos-btn-record {
  --active-color: var(--quantum-record-primary);
}

.orchos-quantum-btn.orchos-btn-send:hover {
  box-shadow: 
    0 0 40px rgba(0, 250, 255, 0.5),
    inset 0 0 25px rgba(0, 250, 255, 0.3),
    0 8px 25px rgba(0, 0, 0, 0.6);
}

.orchos-quantum-btn.orchos-btn-record:hover {
  box-shadow: 
    0 0 40px rgba(255, 77, 210, 0.5),
    inset 0 0 25px rgba(255, 77, 210, 0.3),
    0 8px 25px rgba(0, 0, 0, 0.6);
}

.orchos-quantum-btn:active::after,
.orchos-quantum-btn:active::before {
  animation: synapticBurst 0.5s ease-out forwards;
}

/* Send Button Specific */

.orchos-quantum-btn.orchos-btn-send {
  --active-color: var(--quantum-send-primary);
}

.orchos-quantum-btn.orchos-btn-send:hover .orchos-quantum-icon {
  filter: drop-shadow(0 0 8px var(--quantum-send-active));
  transform: translateX(2px);
  transition: transform 0.3s var(--quantum-cubic);
}

.orchos-btn-record:hover .neural-wave {
  animation-duration: 4s;
  opacity: 0.9;
}

.orchos-btn-send:hover .neural-send-wave {
  animation-duration: 3s;
  opacity: 0.9;
}

.orchos-btn-send:hover .neural-send-arrow {
  animation-duration: 1.5s;
  opacity: 1;
}

.settings-btn {
  width: 34px !important;
  height: 34px !important;
  padding: 0 !important;
  display: flex !important;
  align-items: center !important;
  justify-content: center !important;
  color: var(--theme-cyan) !important;
  cursor: pointer !important;
  border-radius: 50% !important;
  background-color: rgba(0, 15, 30, 0.7) !important;
  border: 2px solid rgba(0, 250, 255, 0.5) !important;
  box-shadow: 0 0 8px rgba(0, 250, 255, 0.4), inset 0 0 10px rgba(0, 250, 255, 0.1) !important;
  transition: all 0.3s ease !important;
  -webkit-backdrop-filter: blur(2px) !important;
  backdrop-filter: blur(2px) !important;
}

.settings-btn:hover {
  transform: scale(1.05);
  background-color: rgba(0, 40, 70, 0.9) !important;
  box-shadow: 0 0 15px rgba(0, 250, 255, 0.7), inset 0 0 12px rgba(0, 250, 255, 0.2) !important;
  border-color: rgba(0, 250, 255, 0.8) !important;
}

.settings-btn svg {
  width: 20px !important;
  height: 20px !important;
  filter: drop-shadow(0 0 3px rgba(0, 250, 255, 0.6)) !important;
}

.settings-btn {
  background-color: rgba(0, 15, 30, 0.7) !important;
  border: 2px solid rgba(0, 250, 255, 0.5) !important;
  box-shadow: 0 0 8px rgba(0, 250, 255, 0.4), inset 0 0 10px rgba(0, 250, 255, 0.1) !important;
}

.settings-btn:hover {
  background-color: rgba(0, 30, 60, 0.9) !important;
  border-color: rgba(0, 250, 255, 0.8) !important;
  box-shadow: 0 0 15px rgba(0, 250, 255, 0.7), inset 0 0 12px rgba(0, 250, 255, 0.2) !important;
}

.settings-btn svg {
  filter: drop-shadow(0 0 3px #00faff);
}

.settings-btn:hover svg circle:nth-of-type(1) {
  animation: qNodePulse 2s infinite alternate ease-in-out;
}

.settings-btn:hover svg circle:nth-of-type(2) {
  animation: orbitalSpin 8s infinite linear;
}

.settings-btn:hover svg circle:nth-of-type(3),
.settings-btn:hover svg circle:nth-of-type(4),
.settings-btn:hover svg circle:nth-of-type(5),
.settings-btn:hover svg circle:nth-of-type(6) {
  animation: connectionPulse 3s infinite alternate ease-in-out;
}

.orchos-quantum-btn {
  margin: 0 3px;
}

.orchos-btn-circle {
  box-sizing: border-box;
}

/* Record Button - Converging Neural Waves */

/* Send Button - Diverging Neural Waves */

/* Quantum Ripple Effect */

.orchos-quantum-ripple {
  position: absolute;
  border-radius: 50%;
  transform: translate(-50%, -50%);
  background: radial-gradient(circle, 
    rgba(0, 250, 255, 0.4) 0%, 
    rgba(124, 77, 255, 0.2) 50%, 
    transparent 70%
  );
  pointer-events: none;
  animation: quantumRippleExpand 1s ease-out forwards;
}

.orchos-quantum-btn:focus {
  outline: none;
  box-shadow: 
    0 0 50px rgba(0, 250, 255, 0.5),
    inset 0 0 30px rgba(0, 250, 255, 0.2),
    0 8px 30px rgba(0, 0, 0, 0.6),
    0 0 0 3px rgba(0, 250, 255, 0.3);
}

.orchos-quantum-btn:focus-visible {
  outline: 2px solid #00faff;
  outline-offset: 4px;
}

@media (prefers-reduced-motion: reduce) {
  .orchos-quantum-btn,
  .orchos-quantum-btn::before,
  .orchos-neural-ring,
  .orchos-quantum-particles::before,
  .orchos-quantum-particles::after {
    animation: none !important;
    transition: none !important;
  }
  
  .orchos-quantum-btn {
    transition: transform 0.2s ease;
  }
}
/* Chat History Sidebar Styles */
.chat-history-sidebar {
  height: 100%;
  background: rgba(9, 9, 11, 0.95);
  -webkit-backdrop-filter: blur(20px);
  backdrop-filter: blur(20px);
  border-right: 1px solid rgba(124, 77, 255, 0.2);
  display: flex;
  flex-direction: column;
  overflow: hidden;
}

/* Sidebar Header */
.sidebar-header {
  padding: 1.5rem 1rem;
  border-bottom: 1px solid rgba(124, 77, 255, 0.1);
  display: flex;
  align-items: center;
  justify-content: space-between;
  flex-shrink: 0;
}

.sidebar-title {
  margin: 0;
  font-size: 1.25rem;
  font-weight: 600;
  color: #ffffff;
  background: linear-gradient(135deg, #7c4dff 0%, #00faff 100%);
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
  background-clip: text;
}

.new-chat-button {
  width: 36px;
  height: 36px;
  border-radius: 50%;
  background: linear-gradient(135deg, #7c4dff 0%, #00faff 100%);
  border: none;
  color: #ffffff;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  transition: all 0.3s ease;
  position: relative;
  overflow: hidden;
}

.new-chat-button::before {
  content: '';
  position: absolute;
  top: 50%;
  left: 50%;
  width: 0;
  height: 0;
  border-radius: 50%;
  background: rgba(255, 255, 255, 0.2);
  transform: translate(-50%, -50%);
  transition: width 0.3s, height 0.3s;
}

.new-chat-button:hover::before {
  width: 100%;
  height: 100%;
}

.new-chat-button:hover {
  transform: scale(1.05);
  box-shadow: 0 4px 20px rgba(124, 77, 255, 0.4);
}

/* Disabled state for new chat button */
.new-chat-button:disabled,
.new-chat-button.disabled {
  opacity: 0.5;
  cursor: not-allowed;
  background: rgba(124, 77, 255, 0.3);
}

.new-chat-button:disabled:hover,
.new-chat-button.disabled:hover {
  transform: none;
  box-shadow: none;
}

.new-chat-button:disabled::before,
.new-chat-button.disabled::before {
  display: none;
}

/* Search Section */
.sidebar-search {
  padding: 1rem;
  position: relative;
  flex-shrink: 0;
}

.search-input {
  width: 100%;
  padding: 0.75rem 2.5rem 0.75rem 1rem;
  background: rgba(124, 77, 255, 0.05);
  border: 1px solid rgba(124, 77, 255, 0.2);
  border-radius: 12px;
  color: #ffffff;
  font-size: 0.875rem;
  transition: all 0.3s ease;
  outline: none;
}

.search-input::placeholder {
  color: rgba(255, 255, 255, 0.4);
}

.search-input:focus {
  background: rgba(124, 77, 255, 0.1);
  border-color: #7c4dff;
  box-shadow: 0 0 0 3px rgba(124, 77, 255, 0.1);
}

.search-icon {
  position: absolute;
  right: 1.75rem;
  top: 50%;
  transform: translateY(-50%);
  color: rgba(255, 255, 255, 0.4);
  pointer-events: none;
}

/* Conversations List */
.conversations-list {
  flex: 1;
  overflow-y: auto;
  padding: 0.5rem;
}

.conversations-list::-webkit-scrollbar {
  width: 6px;
}

.conversations-list::-webkit-scrollbar-track {
  background: transparent;
}

.conversations-list::-webkit-scrollbar-thumb {
  background: rgba(124, 77, 255, 0.3);
  border-radius: 3px;
}

.conversations-list::-webkit-scrollbar-thumb:hover {
  background: rgba(124, 77, 255, 0.5);
}

/* Conversation Item */
.conversation-item {
  padding: 1rem;
  margin-bottom: 0.5rem;
  background: rgba(124, 77, 255, 0.05);
  border: 1px solid transparent;
  border-radius: 12px;
  cursor: pointer;
  transition: all 0.3s ease;
  position: relative;
  overflow: hidden;
}

.conversation-item::before {
  content: '';
  position: absolute;
  top: 0;
  left: -100%;
  width: 100%;
  height: 100%;
  background: linear-gradient(90deg, 
    transparent,
    rgba(124, 77, 255, 0.1),
    transparent
  );
  transition: left 0.5s;
}

.conversation-item:hover::before {
  left: 100%;
}

.conversation-item:hover {
  background: rgba(124, 77, 255, 0.1);
  border-color: rgba(124, 77, 255, 0.2);
  transform: translateX(4px);
}

.conversation-item.active {
  background: linear-gradient(135deg, rgba(124, 77, 255, 0.15) 0%, rgba(0, 250, 255, 0.1) 100%);
  border-color: rgba(124, 77, 255, 0.3);
  box-shadow: 0 0 20px rgba(124, 77, 255, 0.2);
}

.conversation-content {
  position: relative;
  z-index: 1;
  padding-right: 2rem;
}

.conversation-title {
  margin: 0 0 0.25rem 0;
  font-size: 0.9rem;
  font-weight: 500;
  color: #ffffff;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}

.conversation-preview {
  margin: 0 0 0.5rem 0;
  font-size: 0.8rem;
  color: rgba(255, 255, 255, 0.6);
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}

.conversation-time {
  font-size: 0.75rem;
  color: rgba(255, 255, 255, 0.4);
}

/* Delete Button */
.delete-button {
  position: absolute;
  top: 1rem;
  right: 1rem;
  width: 28px;
  height: 28px;
  border-radius: 50%;
  background: rgba(239, 68, 68, 0.1);
  border: 1px solid rgba(239, 68, 68, 0.2);
  color: #ef4444;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  transition: all 0.3s ease;
  z-index: 2;
}

.delete-button:hover {
  background: rgba(239, 68, 68, 0.2);
  border-color: #ef4444;
  transform: scale(1.1);
}

/* No Conversations */
.no-conversations {
  text-align: center;
  padding: 3rem 1rem;
  color: rgba(255, 255, 255, 0.4);
  font-size: 0.875rem;
}

/* Main Dashboard Layout Update */
.orchos-quantum-dashboard.with-sidebar {
  display: grid;
  grid-template-columns: 280px 1.618fr 1fr;
  gap: 0;
  height: 100%;
}

.orchos-quantum-dashboard.with-sidebar.single-column {
  grid-template-columns: 280px 1fr;
}

/* Mobile Responsiveness */
@media (max-width: 768px) {
  .orchos-quantum-dashboard.with-sidebar {
    grid-template-columns: 1fr;
  }
  
  .chat-history-sidebar {
    position: fixed;
    left: -280px;
    top: 0;
    width: 280px;
    height: 100vh;
    z-index: 1000;
    transition: left 0.3s ease;
  }
  
  .chat-history-sidebar.mobile-open {
    left: 0;
    box-shadow: 2px 0 20px rgba(0, 0, 0, 0.5);
  }
  
  /* Mobile toggle button */
  .mobile-sidebar-toggle {
    position: fixed;
    left: 1rem;
    bottom: 1rem;
    width: 56px;
    height: 56px;
    border-radius: 50%;
    background: linear-gradient(135deg, #7c4dff 0%, #00faff 100%);
    border: none;
    color: #ffffff;
    cursor: pointer;
    display: none;
    align-items: center;
    justify-content: center;
    box-shadow: 0 4px 20px rgba(124, 77, 255, 0.4);
    z-index: 999;
  }
  
  @media (max-width: 768px) {
    .mobile-sidebar-toggle {
      display: flex;
    }
  }
} /* SPDX-License-Identifier: MIT OR Apache-2.0
 * Copyright (c) 2025 Guilherme Ferrari Brescia
 */

.orchos-header-glass {
  position: relative;
  z-index: 30;
  background: linear-gradient(90deg, #191a2b 80%, #232447 100%);
  box-shadow: 0 8px 48px 0 #00f0ff22;
  -webkit-backdrop-filter: blur(3.5px) saturate(1.15);
  backdrop-filter: blur(3.5px) saturate(1.15);
}

/* Modal de Logs de Cogni√ß√£o - layout robusto e responsivo */
.orchos-cognition-logs-modal {
  display: flex;
  flex-direction: column;
  width: 100%;
  min-width: 350px;
  max-width: 600px;
  max-height: 92vh;
  background: linear-gradient(135deg, rgba(24,24,40,0.97) 70%, rgba(124,77,255,0.08) 100%);
  border-radius: 1.3rem;
  box-shadow: 0 12px 48px 0 #7c4dff33, 0 0 0 2.5px #7c4dffcc, 0 0 48px 6px #7c4dff44;
  border: 2.5px solid #7c4dffcc;
  padding: 1.5rem 1.5rem 1.2rem 1.5rem;
  overflow: hidden;
  position: relative;
  animation: modalFadeIn 0.33s cubic-bezier(.33,1.4,.44,1) both;
}

@keyframes modalFadeIn {
  0% { opacity: 0; transform: scale(0.96); }
  100% { opacity: 1; transform: scale(1); }
}

.orchos-cognition-logs-header button {
  box-shadow: 0 0 8px #7c4dff88, 0 0 0 2px #7c4dff44;
  transition: box-shadow 0.18s, background 0.18s;
}
.orchos-cognition-logs-header button:hover {
  background: #7c4dff22;
  box-shadow: 0 0 16px #7c4dffcc, 0 0 0 3px #7c4dff88;
}

.orchos-cognition-logs-buttons button {
  position: relative;
  overflow: hidden;
}
.orchos-cognition-logs-buttons button::after {
  content: '';
  display: block;
  position: absolute;
  left: 50%;
  top: 50%;
  width: 0;
  height: 0;
  background: radial-gradient(circle, #00fff7bb 0%, #7c4dff44 80%, transparent 100%);
  opacity: 0.34;
  border-radius: 50%;
  transform: translate(-50%, -50%) scale(0.7);
  transition: width 0.28s cubic-bezier(.33,1.4,.44,1), height 0.28s cubic-bezier(.33,1.4,.44,1), opacity 0.22s;
  pointer-events: none;
}
.orchos-cognition-logs-buttons button:active::after {
  width: 180%;
  height: 180%;
  opacity: 0.17;
  transition: width 0.12s, height 0.12s, opacity 0.12s;
}

@media (max-width: 800px) {
  .orchos-cognition-logs-modal {
    max-width: 96vw;
    padding: 1.1rem 0.7rem 1rem 0.7rem;
  }
}


.orchos-cognition-logs-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 1.5rem;
  gap: 1rem;
}

.orchos-cognition-logs-buttons {
  display: flex;
  gap: 1rem;
  flex-wrap: wrap;
  margin-bottom: 1.3rem;
}

.orchos-cognition-logs-list {
  flex: 1 1 auto;
  min-height: 120px;
  max-height: 60vh;
  overflow-y: auto;
  padding: 1.2rem 0.7rem 0.2rem 0.7rem;
  background: transparent;
  border-radius: 0.9rem;
  box-shadow: none;
  border: none;
  -webkit-backdrop-filter: none;
  backdrop-filter: none;
}

@media (max-width: 600px) {
  .orchos-cognition-logs-modal {
    padding: 1.1rem 0.7rem 1rem 0.7rem;
    min-width: 0;
    max-width: 99vw;
  }
  .orchos-cognition-logs-list {
    padding: 0.5rem 0.1rem 0.1rem 0.1rem;
    max-height: 46vh;
  }
}

/* Neural text inputs with rounded borders */

textarea.orchos-textarea-neural,
.orchos-textarea-neural {
  min-height: 60px;
  max-height: 60px;
  border-radius: 1.1rem !important;
  background: rgba(10, 20, 40, 0.88);
  border: 2px solid #00faff33;
  color: #e3f6ff;
  font-size: 1.08rem;
  padding: 0.7rem 1rem;
  margin-bottom: 0;
  transition: border-color 0.18s, box-shadow 0.18s;
  box-shadow: 0 2px 12px 0 #00faff22;
  outline: none;
  resize: none;
}


.orchos-textarea-neural:focus {
  border-color: #00faff;
  box-shadow: 0 0 0 2px #00faff44;
}

.orchos-btn-circular {
  background: rgba(24, 24, 40, 0.60);
  border: 2px solid #00faff;
  box-shadow: 0 2px 16px 0 rgba(0,245,255,0.12);
  color: #00faff;
  min-width: 48px;
  min-height: 48px;
  display: flex;
  align-items: center;
  justify-content: center;
  transition: box-shadow 0.18s, background 0.18s, border-color 0.18s;
}

/* Quantum Dashboard Layout - Enhanced */

.orchos-quantum-dashboard {
  display: grid;
  grid-template-columns: 1.618fr 1fr; /* Golden ratio split */
  gap: 1.2rem; /* Gap uniforme entre visualiza√ß√£o e cards */
  width: 100%;
  height: 100%;
  flex: 1 1 auto;
  max-width: 100%;
  max-height: 100%;
  margin: 0;
  padding: 0.5rem;
  background: 
    radial-gradient(ellipse at 20% 30%, rgba(0, 250, 255, 0.03) 0%, transparent 50%),
    radial-gradient(ellipse at 80% 70%, rgba(255, 0, 128, 0.02) 0%, transparent 50%),
    radial-gradient(ellipse at center, #0a0f1a 0%, #000511 100%);
  overflow: hidden;
  position: relative;
  box-sizing: border-box;
}

/* Override background when showing only chat (single column) */
.orchos-quantum-dashboard.single-column {
  background: #0a0f1a !important;
}

/* Hide pseudo-element when showing only chat */
.orchos-quantum-dashboard.single-column::before {
  display: none !important;
}

/* Ensure all child elements have solid background in single-column mode */
.orchos-quantum-dashboard.single-column * {
  background-color: transparent !important;
}

.orchos-quantum-dashboard.single-column .neural-chat-zone {
  background: #0a0f1a !important;
}

.orchos-quantum-dashboard::before {
  content: '';
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background-image: 
    radial-gradient(circle at 20% 50%, rgba(0, 250, 255, 0.1) 0%, transparent 2%),
    radial-gradient(circle at 80% 80%, rgba(255, 0, 128, 0.08) 0%, transparent 2%),
    radial-gradient(circle at 40% 80%, rgba(120, 119, 198, 0.1) 0%, transparent 2%);
  background-size: 400px 400px;
  animation: quantumDrift 20s ease-in-out infinite;
  pointer-events: none;
  opacity: 0.4;
}

/* Quantum Visualization Zone - Holographic Container */

.quantum-visualization-zone {
  position: relative;
  background: 
    linear-gradient(135deg, rgba(0,20,40,0.2) 0%, transparent 40%),
    radial-gradient(circle at center, rgba(0,20,40,0.4) 0%, transparent 70%);
  border-radius: 1rem;
  padding: 0;
  display: flex;
  align-items: center;
  justify-content: center;
  overflow: hidden;
  border: 1px solid rgba(0,250,255,0.2);
  box-shadow: 
    inset 0 0 40px rgba(0,250,255,0.08),
    0 0 60px rgba(0,250,255,0.05),
    0 8px 32px rgba(0,0,0,0.4);
  height: 100%;
  -webkit-backdrop-filter: blur(10px);
  backdrop-filter: blur(10px);
}

/* Card horizontal para resposta AI (ocupa duas colunas do grid) */
.neural-control-grid [data-type="ai"] {
  grid-column: 1 / span 2;
  width: 100%;
}

/* Neural Control Grid - Advanced Glassmorphism */

.neural-control-grid {
  display: grid;
  grid-template-columns: 1fr 1fr;
  grid-template-rows: min-content min-content;
  gap: 0.5rem;
  height: auto;
  padding: 0;
}

/* Enhanced Glassmorphic Cards */

/* Card hover state - elevated glassmorphism */

/* Card headers - futuristic design */

/* Add scanning line effect to headers */

/* Card body - improved spacing */

/* Custom scrollbar - quantum style */

/* Ensure main body doesn't scroll */

body.orchos-active {
  overflow: hidden;
}

/* Header positioning - ultra compact */

/* Header title with glow */

/* Header button styling */

.neural-control-grid button {
  padding: 0.32rem 0.9rem !important;
  font-size: 0.74rem !important;
  min-height: 1.7rem !important;
  height: auto !important;
  background: 
    linear-gradient(
      135deg, 
      rgba(255, 255, 255, 0.03) 0%, 
      rgba(255, 255, 255, 0.01) 100%
    );
  border: 1px solid rgba(255, 255, 255, 0.07);
  color: rgba(255, 255, 255, 0.88);
  font-weight: 500;
  letter-spacing: 0.02em;
  transition: all 0.3s cubic-bezier(0.23, 1, 0.32, 1);
  position: relative;
  overflow: hidden;
  border-radius: 0.6rem;
  -webkit-backdrop-filter: blur(16px);
  backdrop-filter: blur(16px);
  transform-style: preserve-3d;
}

.neural-control-grid button::before {
  content: '';
  position: absolute;
  top: 0;
  left: -100%;
  width: 100%;
  height: 100%;
  background: linear-gradient(90deg, transparent, rgba(0, 250, 255, 0.2), transparent);
  transition: left 0.5s ease;
}

.neural-control-grid button:hover {
  background: linear-gradient(135deg, rgba(0, 250, 255, 0.2) 0%, rgba(0, 250, 255, 0.1) 100%);
  border-color: rgba(0, 250, 255, 0.5);
  box-shadow: 0 0 20px rgba(0, 250, 255, 0.3);
  transform: translateY(-1px);
}

.neural-control-grid button:hover::before {
  left: 100%;
}

/* Typography Enhancements */

.neural-control-grid .text-sm {
  font-size: 0.8rem !important;
  line-height: 1.4 !important;
  color: rgba(255, 255, 255, 0.8);
}

.neural-control-grid .text-xs {
  font-size: 0.7rem !important;
  line-height: 1.3 !important;
  color: rgba(255, 255, 255, 0.6);
  font-family: 'Monaco', 'Consolas', monospace;
}

/* Input and Textarea Styling */

.neural-control-grid textarea,
.neural-control-grid input {
  font-size: 0.8rem !important;
  line-height: 1.4 !important;
  background: rgba(0, 0, 0, 0.3);
  border: 1px solid rgba(0, 250, 255, 0.2);
  color: rgba(255, 255, 255, 0.9);
  padding: 0.5rem;
  border-radius: 0.5rem;
  transition: all 0.3s ease;
  font-family: 'Monaco', 'Consolas', monospace;
}

.neural-control-grid textarea:focus,
.neural-control-grid input:focus {
  outline: none;
  border-color: rgba(0, 250, 255, 0.5);
  box-shadow: 0 0 0 2px rgba(0, 250, 255, 0.1);
  background: rgba(0, 0, 0, 0.5);
}

/* Legacy grid - keeping for backwards compatibility */

/* Ensure quantum visualization takes full space */

.quantum-visualization-zone > div {
  width: 100% !important;
  height: 100% !important;
}

/* Neural Chat Zone - Isolated background */
.neural-chat-zone {
  position: relative;
  background: #0a0f1a; /* Solid background matching the dashboard center color */
  isolation: isolate; /* Create new stacking context */
}

/* Add a pseudo-element to ensure complete coverage */
.neural-chat-zone::before {
  content: '';
  position: absolute;
  top: -10px;
  left: -10px;
  right: -10px;
  bottom: -10px;
  background: #0a0f1a;
  z-index: -1;
  pointer-events: none;
}

/* Recording control inside card */

/* Transcription card button layout */

/* Data Visualization Elements */

.neural-control-grid button {
  position: relative;
  overflow: hidden;
}

/* Enhanced Focus States */

.neural-control-grid button:focus,
.neural-control-grid input:focus,
.neural-control-grid textarea:focus {
  outline: none;
  box-shadow: 
    0 0 0 2px rgba(0, 250, 255, 0.3),
    0 0 20px rgba(0, 250, 255, 0.2);
}

/* Loading States */

/* Ensure cards use all available space */

.neural-control-grid > * {
  min-height: 0;
  min-width: 0;
  overflow: hidden;
  min-height: 0;
  overflow: hidden;
}

/* Responsive adjustments */

@media (max-height: 800px) {
  .orchos-quantum-dashboard {
    padding: 0.2rem;
    gap: 0.2rem;
    height: calc(100vh - 2.5rem);
    padding-top: 2.5rem;
  }
  
  .neural-control-grid {
    gap: 0.2rem;
  }
  
  .neural-control-grid button {
    padding: 0.15rem 0.4rem !important;
    font-size: 0.65rem !important;
    min-height: 1.4rem !important;
  }
}

/* ============================= */

/* ============================= */

/* Sistema Neural-Qu√¢ntico de Profundidade */

.orchos-tooltip {
  position: absolute;
  left: 50%;
  bottom: 110%;
  transform: translateX(-50%) scale(0.95);
  min-width: 80px;
  max-width: 140px;
  background: rgba(18, 24, 38, 0.85);
  -webkit-backdrop-filter: blur(8px) saturate(120%);
  backdrop-filter: blur(8px) saturate(120%);
  color: #fff;
  font-size: 1rem;
  font-family: inherit;
  text-align: center;
  padding: 0.4em 1em;
  border-radius: 1.2em;
  box-shadow: 0 4px 24px 0 rgba(0,250,255,0.10), 0 1.5px 4px 0 rgba(124,77,255,0.09);
  opacity: 0;
  pointer-events: none;
  z-index: 10;
  transition: opacity 0.3s var(--quantum-cubic), transform 0.3s var(--quantum-cubic);
  white-space: pre-line;
  border: 1px solid rgba(124, 77, 255, 0.2);
  letter-spacing: 0.03em;
}

/* Sistema Neural Biomim√©tico - Respira√ß√£o */

/* Intera√ß√£o Neural-Magn√©tica */

.orchos-quantum-btn-inner {
  position: relative;
  width: 100%;
  height: 100%;
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 2;
}

/* Sistema Neural de Part√≠culas Qu√¢nticas */

/* Adiciona 6 part√≠culas qu√¢nticas com posi√ß√µes e anima√ß√µes variadas */

/* Gera√ß√£o de part√≠culas neurais adicionais */

/* Duplica as part√≠culas em hover */

/* Anima√ß√£o para part√≠culas neurais ativas */

/* Aplicar anima√ß√£o mais intensa quando gravando */

/* Efeito neural para bot√£o de envio (hover/focus) */

/* Efeito neural para bot√£o de grava√ß√£o (hover/focus) */

/* Efeito sin√°ptico ao clicar */

/* Hover Animations for Neural Wave Patterns */

/* Container do bot√£o de configura√ß√µes */

.settings-container {
  display: flex;
  align-items: center;
  height: 100%;
  margin-right: -4px;
}

/* Estilos para o bot√£o de configura√ß√µes neural-qu√¢ntico */

.settings-btn {
  width: 34px !important;
  height: 34px !important;
  padding: 0 !important;
  display: flex !important;
  align-items: center !important;
  justify-content: center !important;
  color: var(--theme-cyan) !important;
  cursor: pointer !important;
  border-radius: 50% !important;
  background-color: rgba(0, 15, 30, 0.7) !important;
  border: 2px solid rgba(0, 250, 255, 0.5) !important;
  box-shadow: 0 0 8px rgba(0, 250, 255, 0.4), inset 0 0 10px rgba(0, 250, 255, 0.1) !important;
  transition: all 0.3s ease !important;
  -webkit-backdrop-filter: blur(2px) !important;
  backdrop-filter: blur(2px) !important;
}

/* Estiliza√ß√£o para o popup de configura√ß√µes neural-qu√¢ntico */

.neural-settings-popup {
  background-color: rgba(0, 15, 30, 0.95);
  border: 2px solid rgba(0, 250, 255, 0.5);
  box-shadow: 0 5px 25px rgba(0, 0, 0, 0.7), 0 0 20px rgba(0, 250, 255, 0.3);
  -webkit-backdrop-filter: blur(15px);
  backdrop-filter: blur(15px);
  min-width: 250px;
  z-index: 100;
  position: absolute;
  top: calc(100% + 10px);
  right: 0;
  padding: 14px 16px;
  max-height: 60vh;
  overflow-y: auto;

  /* Usando display: flex em vez de block para permitir alinhamento vertical */
  display: flex;
  flex-direction: column;
  border-radius: 12px;
  margin-top: 0;
}


/* Anima√ß√µes do bot√£o de configura√ß√µes */

/* Anima√ß√£o do c√≠rculo central */

/* Anima√ß√£o do orbital */

/* Anima√ß√£o dos pontos de conex√£o */

/* Efeito de abertura do popup */

/* Estilos de controle para o posicionamento do popover de configura√ß√µes */

/* Refinamentos para posicionamento global dos bot√µes quantum */

/* Garantir que o bot√£o de configura√ß√µes n√£o desloque o layout */

/* Icon Animations */

/* Neural Wave Pattern Animations */

/* Neural Core Animations */

/* Active State Enhanced Animations */

/* Focus States */

/* Reduced Motion */
/* ================================================================
 * OVERRIDE STYLES - Single Column Mode
 * ================================================================
 * These styles override the quantum dashboard background when
 * showing only the chat (without quantum visualization)
 */

/* Force solid background in single-column mode */
.orchos-quantum-dashboard.single-column {
  background: #0a0f1a !important;
  background-image: none !important;
}

/* Remove all pseudo-elements and animations in single-column mode */
.orchos-quantum-dashboard.single-column::before,
.orchos-quantum-dashboard.single-column::after {
  display: none !important;
  content: none !important;
  background: none !important;
  background-image: none !important;
}

/* Ensure neural-chat-zone has solid background */
.orchos-quantum-dashboard.single-column .neural-chat-zone {
  background: #0a0f1a !important;
  background-image: none !important;
}

/* Remove any background from child elements that might leak */
.orchos-quantum-dashboard.single-column .conversational-chat,
.orchos-quantum-dashboard.single-column .chat-messages-container,
.orchos-quantum-dashboard.single-column .chat-messages,
.orchos-quantum-dashboard.single-column .messages-wrapper {
  background: #0a0f1a !important;
  background-image: none !important;
} /* SPDX-License-Identifier: MIT OR Apache-2.0
 * Copyright (c) 2025 Guilherme Ferrari Brescia
 */

.settings-container {
  display: flex;
  align-items: center;
  height: 100%;
  margin-right: -4px;
}

.settings-btn {
  width: 34px !important;
  height: 34px !important;
  padding: 0 !important;
  display: flex !important;
  align-items: center !important;
  justify-content: center !important;
  color: var(--theme-cyan) !important;
  cursor: pointer !important;
  border-radius: 50% !important;
  background-color: rgba(0, 15, 30, 0.7) !important;
  border: 2px solid rgba(0, 250, 255, 0.5) !important;
  box-shadow: 0 0 8px rgba(0, 250, 255, 0.4), inset 0 0 10px rgba(0, 250, 255, 0.1) !important;
  transition: all 0.3s ease !important;
  -webkit-backdrop-filter: blur(2px) !important;
  backdrop-filter: blur(2px) !important;
}

.settings-btn:hover {
  transform: scale(1.05);
  background-color: rgba(0, 40, 70, 0.9) !important;
  box-shadow: 0 0 15px rgba(0, 250, 255, 0.7), inset 0 0 12px rgba(0, 250, 255, 0.2) !important;
  border-color: rgba(0, 250, 255, 0.8) !important;
}

.settings-btn svg {
  width: 20px !important;
  height: 20px !important;
  filter: drop-shadow(0 0 3px rgba(0, 250, 255, 0.6)) !important;
}

.neural-settings-popup {
  background-color: rgba(0, 15, 30, 0.95);
  border: 2px solid rgba(0, 250, 255, 0.5);
  box-shadow: 0 5px 25px rgba(0, 0, 0, 0.7), 0 0 20px rgba(0, 250, 255, 0.3);
  -webkit-backdrop-filter: blur(15px);
  backdrop-filter: blur(15px);
  min-width: 250px;
  z-index: 100;
  position: absolute;
  top: calc(100% + 10px);
  right: 0;
  padding: 14px 16px;
  

/* Usando display: flex em vez de block para permitir alinhamento vertical */


  display: flex;
  flex-direction: column;
  overflow: hidden;
  border-radius: 12px;
  margin-top: 0;
}

.settings-btn {
  background-color: rgba(0, 15, 30, 0.7) !important;
  border: 2px solid rgba(0, 250, 255, 0.5) !important;
  box-shadow: 0 0 8px rgba(0, 250, 255, 0.4), inset 0 0 10px rgba(0, 250, 255, 0.1) !important;
}

.settings-btn:hover {
  background-color: rgba(0, 30, 60, 0.9) !important;
  border-color: rgba(0, 250, 255, 0.8) !important;
  box-shadow: 0 0 15px rgba(0, 250, 255, 0.7), inset 0 0 12px rgba(0, 250, 255, 0.2) !important;
}

.settings-btn svg {
  filter: drop-shadow(0 0 3px #00faff);
}

.settings-btn:hover svg circle:nth-of-type(1) {
  animation: qNodePulse 2s infinite alternate ease-in-out;
}

.settings-btn:hover svg circle:nth-of-type(2) {
  animation: orbitalSpin 8s infinite linear;
}

.settings-btn:hover svg circle:nth-of-type(3),
.settings-btn:hover svg circle:nth-of-type(4),
.settings-btn:hover svg circle:nth-of-type(5),
.settings-btn:hover svg circle:nth-of-type(6) {
  animation: connectionPulse 3s infinite alternate ease-in-out;
}

.neural-settings-popup {
  animation: settingsPopupReveal 0.3s ease-out forwards;
  transform-origin: top right;
}
/* SPDX-License-Identifier: MIT OR Apache-2.0
 * Copyright (c) 2025 Guilherme Ferrari Brescia
 */

.orchos-tooltip {
  position: absolute;
  left: 50%;
  bottom: 110%;
  transform: translateX(-50%) scale(0.95);
  min-width: 80px;
  max-width: 140px;
  background: rgba(18, 24, 38, 0.85);
  -webkit-backdrop-filter: blur(8px) saturate(120%);
  backdrop-filter: blur(8px) saturate(120%);
  color: #fff;
  font-size: 1rem;
  font-family: inherit;
  text-align: center;
  padding: 0.4em 1em;
  border-radius: 1.2em;
  box-shadow: 0 4px 24px 0 rgba(0,250,255,0.10), 0 1.5px 4px 0 rgba(124,77,255,0.09);
  opacity: 0;
  pointer-events: none;
  z-index: 10;
  transition: opacity 0.3s var(--quantum-cubic), transform 0.3s var(--quantum-cubic);
  white-space: pre-line;
  border: 1px solid rgba(124, 77, 255, 0.2);
  letter-spacing: 0.03em;
}

/* Anima√ß√£o Neural da Tooltip */

.orchos-tooltip::after {
  content: '';
  position: absolute;
  width: 100%;
  height: 100%;
  left: 0;
  top: 0;
  border-radius: inherit;
  background: linear-gradient(135deg, 
    rgba(255, 77, 210, 0.1) 0%, 
    rgba(0, 250, 255, 0.1) 50%,
    rgba(124, 77, 255, 0.1) 100%);
  opacity: 0;
  z-index: -1;
  animation: neuralGradient 8s ease-in-out infinite;
}

.orchos-quantum-btn:hover .orchos-tooltip,
.orchos-quantum-btn:focus .orchos-tooltip,
.orchos-quantum-btn:focus-visible .orchos-tooltip {
  opacity: 1;
  transform: translateX(-50%) scale(1);
  pointer-events: auto;
  box-shadow: 
    0 8px 32px 0 rgba(0,250,255,0.15), 
    0 2px 8px 0 rgba(124,77,255,0.15),
    inset 0 0 8px 0 rgba(0,250,255,0.1);
}

/* Tooltip Arrow */

.orchos-tooltip::before {
  content: '';
  position: absolute;
  left: 50%;
  bottom: -5px;
  transform: translateX(-50%) rotate(45deg);
  width: 10px;
  height: 10px;
  background: inherit;
  -webkit-backdrop-filter: inherit;
  backdrop-filter: inherit;
  border-right: 1px solid rgba(124, 77, 255, 0.2);
  border-bottom: 1px solid rgba(124, 77, 255, 0.2);
  z-index: -1;
}
/* SPDX-License-Identifier: MIT OR Apache-2.0
 * Copyright (c) 2025 Guilherme Ferrari Brescia
 */

:root {
  --quantum-depth-2: 5px;
  --quantum-cubic: cubic-bezier(0.34, 1.56, 0.64, 1);
  
  

/* Paleta Neural-Qu√¢ntica */


  --quantum-record-primary: rgba(255, 77, 210, 0.8);
  --quantum-record-active: rgba(255, 77, 210, 1);
  
  --quantum-send-primary: rgba(0, 250, 255, 0.8);
  --quantum-send-active: rgba(0, 250, 255, 1);
}
/* SPDX-License-Identifier: MIT OR Apache-2.0
 * Copyright (c) 2025 Guilherme Ferrari Brescia
 */

textarea.orchos-textarea-neural,
.orchos-textarea-neural {
  border-radius: 1.1rem !important;
  background: rgba(10, 20, 40, 0.88);
  border: 2px solid #00faff33;
  color: #e3f6ff;
  font-size: 1.08rem;
  padding: 1.1rem 1.2rem;
  transition: border-color 0.18s, box-shadow 0.18s;
  box-shadow: 0 2px 12px 0 #00faff22;
  outline: none;
  resize: none;
}

.orchos-textarea-neural:focus {
  border-color: #00faff;
  box-shadow: 0 0 0 2px #00faff44;
}

.orchos-btn-circular, .orchos-btn-fab, .orchos-btn-glass {
  border-radius: 999px !important;
}

.orchos-btn-fab {
  background: rgba(24,24,40,0.82);
  border: 3px solid #00faff;
  box-shadow: 0 0 24px 8px #00faff33, 0 0 0 0 #fff0;
  color: #00faff;
  font-weight: 600;
  font-size: 1.1rem;
  transition: box-shadow 0.22s, background 0.22s, border-color 0.22s;
}

.orchos-btn-fab:focus, .orchos-btn-fab:hover {
  background: rgba(0, 245, 255, 0.12);
  box-shadow: 0 0 36px 12px #00faff77, 0 0 0 3px #00faff55;
  border-color: #00faff;
}

.orchos-btn-circular {
  background: rgba(24, 24, 40, 0.60);
  border: 2px solid #00faff;
  box-shadow: 0 2px 16px 0 rgba(0,245,255,0.12);
  color: #00faff;
  min-width: 48px;
  min-height: 48px;
  display: flex;
  align-items: center;
  justify-content: center;
  transition: box-shadow 0.18s, background 0.18s, border-color 0.18s;
}

.orchos-btn-circular:focus, .orchos-btn-circular:hover {
  background: rgba(0, 245, 255, 0.12);
  box-shadow: 0 0 16px 4px #00faff77;
  border-color: #00faff;
}

.orchos-quantum-dashboard {
  display: grid;
  grid-template-columns: 1.618fr 1fr; 

/* Golden ratio split */


  gap: 0.75rem;
  height: 100vh;
  padding: 0.5rem;
  padding-top: 0.5rem;
  background: 
    radial-gradient(ellipse at 20% 30%, rgba(0, 250, 255, 0.03) 0%, transparent 50%),
    radial-gradient(ellipse at 80% 70%, rgba(255, 0, 128, 0.02) 0%, transparent 50%),
    radial-gradient(ellipse at center, #0a0f1a 0%, #000511 100%);
  overflow: hidden;
  position: relative;
  box-sizing: border-box;
}

/* Override background when showing only chat (single column) */
.orchos-quantum-dashboard.single-column {
  background: #0a0f1a !important;
}

/* Add subtle animated particles background */

.orchos-quantum-dashboard::before {
  content: '';
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background-image: 
    radial-gradient(circle at 20% 50%, rgba(0, 250, 255, 0.1) 0%, transparent 2%),
    radial-gradient(circle at 80% 80%, rgba(255, 0, 128, 0.08) 0%, transparent 2%),
    radial-gradient(circle at 40% 80%, rgba(120, 119, 198, 0.1) 0%, transparent 2%);
  background-size: 400px 400px;
  animation: quantumDrift 20s ease-in-out infinite;
  pointer-events: none;
  opacity: 0.4;
}

/* Hide pseudo-element when showing only chat */
.orchos-quantum-dashboard.single-column::before {
  display: none !important;
}

/* Quantum Visualization Zone - Holographic Container */

.quantum-visualization-zone {
  position: relative;
  background: 
    linear-gradient(135deg, rgba(0,20,40,0.2) 0%, transparent 40%),
    radial-gradient(circle at center, rgba(0,20,40,0.4) 0%, transparent 70%);
  border-radius: 1rem;
  padding: 0;
  display: flex;
  align-items: center;
  justify-content: center;
  overflow: hidden;
  border: 1px solid rgba(0,250,255,0.2);
  box-shadow: 
    inset 0 0 40px rgba(0,250,255,0.08),
    0 0 60px rgba(0,250,255,0.05),
    0 8px 32px rgba(0,0,0,0.4);
  height: 100%;
  -webkit-backdrop-filter: blur(10px);
  backdrop-filter: blur(10px);
}

/* Add holographic shimmer effect */

.quantum-visualization-zone::after {
  content: '';
  position: absolute;
  top: -50%;
  left: -50%;
  width: 200%;
  height: 200%;
  background: linear-gradient(
    45deg,
    transparent 30%,
    rgba(0, 250, 255, 0.03) 50%,
    transparent 70%
  );
  animation: holographicShimmer 8s linear infinite;
  pointer-events: none;
}

/* Quantum glow effects */

.quantum-visualization-zone::before {
  content: '';
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  width: 300px;
  height: 300px;
  background: radial-gradient(circle, rgba(0,250,255,0.15) 0%, transparent 70%);
  filter: blur(60px);
  animation: quantumPulse 4s ease-in-out infinite;
  pointer-events: none;
}

/* Neural Control Grid - Advanced Glassmorphism */

/* Enhanced Glassmorphic Cards */

/* Remover qualquer glow roxo externo (outline/shadow) */

/* Card hover state - elevated glassmorphism */

/* Add subtle glow on hover */

/* Icons with glow effect */

/* Header title with glow */

.neural-control-grid button {
  padding: 0.32rem 0.9rem !important;
  font-size: 0.74rem !important;
  min-height: 1.7rem !important;
  height: auto !important;
  background: 
    linear-gradient(
      135deg, 
      rgba(255, 255, 255, 0.03) 0%, 
      rgba(255, 255, 255, 0.01) 100%
    );
  border: 1px solid rgba(255, 255, 255, 0.07);
  color: rgba(255, 255, 255, 0.88);
  font-weight: 500;
  letter-spacing: 0.02em;
  transition: all 0.3s cubic-bezier(0.23, 1, 0.32, 1);
  position: relative;
  overflow: hidden;
  border-radius: 0.6rem;
  -webkit-backdrop-filter: blur(16px);
  backdrop-filter: blur(16px);
  transform-style: preserve-3d;
}

.neural-control-grid button::before {
  content: '';
  position: absolute;
  top: 0;
  left: -100%;
  width: 100%;
  height: 100%;
  background: linear-gradient(90deg, transparent, rgba(0, 250, 255, 0.2), transparent);
  transition: left 0.5s ease;
}

.neural-control-grid button:hover {
  background: linear-gradient(135deg, rgba(0, 250, 255, 0.2) 0%, rgba(0, 250, 255, 0.1) 100%);
  border-color: rgba(0, 250, 255, 0.5);
  box-shadow: 0 0 20px rgba(0, 250, 255, 0.3);
  transform: translateY(-1px);
}

.neural-control-grid button:hover::before {
  left: 100%;
}

.neural-control-grid textarea,
.neural-control-grid input {
  font-size: 0.8rem !important;
  line-height: 1.4 !important;
  background: rgba(0, 0, 0, 0.3);
  border: 1px solid rgba(0, 250, 255, 0.2);
  color: rgba(255, 255, 255, 0.9);
  padding: 0.5rem;
  border-radius: 0.5rem;
  transition: all 0.3s ease;
  font-family: 'Monaco', 'Consolas', monospace;
}

.neural-control-grid textarea:focus,
.neural-control-grid input:focus {
  outline: none;
  border-color: rgba(0, 250, 255, 0.5);
  box-shadow: 0 0 0 2px rgba(0, 250, 255, 0.1);
  background: rgba(0, 0, 0, 0.5);
}

.ripple {
  position: absolute;
  border-radius: 50%;
  background: radial-gradient(circle, rgba(0, 250, 255, 0.3) 0%, transparent 70%);
  transform: scale(0);
  animation: rippleEffect 0.6s ease-out;
  pointer-events: none;
}

.neural-control-grid button:focus,
.neural-control-grid input:focus,
.neural-control-grid textarea:focus {
  outline: none;
  box-shadow: 
    0 0 0 2px rgba(0, 250, 255, 0.3),
    0 0 20px rgba(0, 250, 255, 0.2);
}

:root {
  --quantum-depth-2: 5px;
  --quantum-cubic: cubic-bezier(0.34, 1.56, 0.64, 1);
  
  

/* Paleta Neural-Qu√¢ntica */


  --quantum-record-primary: rgba(255, 77, 210, 0.8);
  --quantum-record-active: rgba(255, 77, 210, 1);
  
  --quantum-send-primary: rgba(0, 250, 255, 0.8);
  --quantum-send-active: rgba(0, 250, 255, 1);
}

.orchos-tooltip {
  position: absolute;
  left: 50%;
  bottom: 110%;
  transform: translateX(-50%) scale(0.95);
  min-width: 80px;
  max-width: 140px;
  background: rgba(18, 24, 38, 0.85);
  -webkit-backdrop-filter: blur(8px) saturate(120%);
  backdrop-filter: blur(8px) saturate(120%);
  color: #fff;
  font-size: 1rem;
  font-family: inherit;
  text-align: center;
  padding: 0.4em 1em;
  border-radius: 1.2em;
  box-shadow: 0 4px 24px 0 rgba(0,250,255,0.10), 0 1.5px 4px 0 rgba(124,77,255,0.09);
  opacity: 0;
  pointer-events: none;
  z-index: 10;
  transition: opacity 0.3s var(--quantum-cubic), transform 0.3s var(--quantum-cubic);
  white-space: pre-line;
  border: 1px solid rgba(124, 77, 255, 0.2);
  letter-spacing: 0.03em;
}

.orchos-tooltip::after {
  content: '';
  position: absolute;
  width: 100%;
  height: 100%;
  left: 0;
  top: 0;
  border-radius: inherit;
  background: linear-gradient(135deg, 
    rgba(255, 77, 210, 0.1) 0%, 
    rgba(0, 250, 255, 0.1) 50%,
    rgba(124, 77, 255, 0.1) 100%);
  opacity: 0;
  z-index: -1;
  animation: neuralGradient 8s ease-in-out infinite;
}

.orchos-quantum-btn:hover .orchos-tooltip,
.orchos-quantum-btn:focus .orchos-tooltip,
.orchos-quantum-btn:focus-visible .orchos-tooltip {
  opacity: 1;
  transform: translateX(-50%) scale(1);
  pointer-events: auto;
  box-shadow: 
    0 8px 32px 0 rgba(0,250,255,0.15), 
    0 2px 8px 0 rgba(124,77,255,0.15),
    inset 0 0 8px 0 rgba(0,250,255,0.1);
}

.orchos-tooltip::before {
  content: '';
  position: absolute;
  left: 50%;
  bottom: -5px;
  transform: translateX(-50%) rotate(45deg);
  width: 10px;
  height: 10px;
  background: inherit;
  -webkit-backdrop-filter: inherit;
  backdrop-filter: inherit;
  border-right: 1px solid rgba(124, 77, 255, 0.2);
  border-bottom: 1px solid rgba(124, 77, 255, 0.2);
  z-index: -1;
}

.orchos-quantum-btn {
  position: relative;
  width: 48px;
  height: 48px;
  min-width: 48px;
  min-height: 48px;
  padding: 0;
  background: var(--quantum-bg-dark);
  border: 2px solid transparent;
  border-radius: 50%;
  cursor: pointer;
  overflow: hidden;
  transition: all 0.3s var(--quantum-cubic);
  -webkit-backdrop-filter: blur(20px) saturate(180%);
  backdrop-filter: blur(20px) saturate(180%);
  box-shadow: 
    0 0 30px rgba(0, 250, 255, 0.2),
    inset 0 0 20px rgba(0, 250, 255, 0.1),
    0 4px 20px rgba(0, 0, 0, 0.5);
  animation: neuralBreathing 6s ease-in-out infinite;
}

.orchos-quantum-btn:hover {
  animation: none;
  transform: scale(1.08) translateZ(var(--quantum-depth-2));
  box-shadow: 
    0 0 50px rgba(0, 250, 255, 0.4),
    inset 0 0 30px rgba(0, 250, 255, 0.2),
    0 8px 30px rgba(0, 0, 0, 0.6);
}

.orchos-quantum-btn::before {
  content: '';
  position: absolute;
  inset: -2px;
  border-radius: 50%;
  padding: 2px;
  background: linear-gradient(135deg, 
    #ff4dd2 0%, 
    #00faff 33%, 
    #7c4dff 66%, 
    #ff4dd2 100%
  );
  

/* Cross-browser mask support */


  -webkit-mask: linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);
  -webkit-mask-composite: xor;
  mask: linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);
  mask-composite: exclude;
  opacity: 0.7;
  animation: quantumBorderRotate 4s linear infinite;
}

.orchos-quantum-btn:hover {
  transform: scale(1.1);
  box-shadow: 
    0 0 50px rgba(0, 250, 255, 0.4),
    inset 0 0 30px rgba(0, 250, 255, 0.2),
    0 8px 30px rgba(0, 0, 0, 0.6);
}

.orchos-quantum-particles {
  position: absolute;
  inset: 0;
  border-radius: 50%;
  overflow: hidden;
}

.orchos-quantum-particles::before,
.orchos-quantum-particles::after {
  content: '';
  position: absolute;
  width: 2px;
  height: 2px;
  background: var(--active-color, #00faff);
  border-radius: 50%;
  box-shadow: 
    0 0 4px var(--active-color, #00faff),
    0 0 8px var(--active-color, #00faff);
  animation: quantumFloat 4s ease-in-out infinite;
  opacity: 0.7;
}

.orchos-quantum-particles::before {
  top: 25%;
  left: 30%;
  animation-delay: 0s;
}

.orchos-quantum-particles::after {
  bottom: 30%;
  right: 25%;
  animation-delay: 2s;
}

.orchos-quantum-btn::after {
  content: '';
  position: absolute;
  top: 60%;
  left: 15%;
  width: 2px;
  height: 2px;
  background: var(--active-color, #00faff);
  border-radius: 50%;
  box-shadow: 
    0 0 4px var(--active-color, #00faff),
    0 0 8px var(--active-color, #00faff);
  animation: quantumFloat 4.5s ease-in-out infinite;
  animation-delay: 1s;
  z-index: 2;
  opacity: 0.7;
}

.orchos-quantum-btn:hover::after {
  width: 3px;
  height: 3px;
  opacity: 1;
}

.orchos-quantum-btn::before {
  content: '';
  position: absolute;
  top: 20%;
  right: 25%;
  width: 2px;
  height: 2px;
  background: var(--active-color, #00faff);
  border-radius: 50%;
  box-shadow: 
    0 0 4px var(--active-color, #00faff),
    0 0 8px var(--active-color, #00faff);
  animation: quantumFloat 5s ease-in-out infinite;
  animation-delay: 2.5s;
  z-index: 2;
  opacity: 0.7;
}

.orchos-quantum-btn[data-active="true"]::after,
.orchos-quantum-btn[data-active="true"]::before,
.orchos-quantum-btn[data-active="true"] .orchos-quantum-particles::before,
.orchos-quantum-btn[data-active="true"] .orchos-quantum-particles::after {
  animation: neuralParticleActive 3s ease-in-out infinite;
  opacity: 1;
  width: 3px;
  height: 3px;
  background: var(--quantum-record-active);
  box-shadow: 
    0 0 8px var(--quantum-record-active),
    0 0 16px var(--quantum-record-active);
}

/* Neural Glow Ring */

.orchos-neural-ring {
  position: absolute;
  inset: 3px;
  border-radius: 50%;
  background: radial-gradient(circle at center,
    transparent 0%,
    transparent 40%,
    rgba(0, 250, 255, 0.1) 50%,
    transparent 60%
  );
  animation: neuralPulse 2s ease-in-out infinite;
}

.orchos-quantum-btn.orchos-btn-record[data-active="true"] {
  border-color: var(--quantum-record-active);
  animation: recordingPulse 1.5s ease-in-out infinite;
  background: rgba(30, 14, 34, 0.9);
}

.orchos-quantum-btn.orchos-btn-record[data-active="true"] .orchos-quantum-icon {
  filter: drop-shadow(0 0 8px var(--quantum-record-active));
}

.orchos-quantum-btn.orchos-btn-record[data-active="true"] .orchos-neural-ring {
  background: radial-gradient(circle at center,
    transparent 0%,
    transparent 40%,
    rgba(255, 77, 210, 0.3) 50%,
    transparent 60%
  );
}

.orchos-quantum-btn.orchos-btn-record[data-active="true"]::before {
  background: linear-gradient(135deg, 
    #ff4dd2 0%, 
    #ff80ab 50%, 
    #ff4dd2 100%
  );
  opacity: 1;
}

.orchos-quantum-btn.orchos-btn-send:hover {
  box-shadow: 
    0 0 40px rgba(0, 250, 255, 0.5),
    inset 0 0 25px rgba(0, 250, 255, 0.3),
    0 8px 25px rgba(0, 0, 0, 0.6);
}

.orchos-quantum-btn.orchos-btn-record:hover {
  box-shadow: 
    0 0 40px rgba(255, 77, 210, 0.5),
    inset 0 0 25px rgba(255, 77, 210, 0.3),
    0 8px 25px rgba(0, 0, 0, 0.6);
}

.orchos-quantum-btn:active::after,
.orchos-quantum-btn:active::before {
  animation: synapticBurst 0.5s ease-out forwards;
}

.orchos-quantum-btn.orchos-btn-send:hover .orchos-quantum-icon {
  filter: drop-shadow(0 0 8px var(--quantum-send-active));
  transform: translateX(2px);
  transition: transform 0.3s var(--quantum-cubic);
}

.settings-btn {
  width: 34px !important;
  height: 34px !important;
  padding: 0 !important;
  display: flex !important;
  align-items: center !important;
  justify-content: center !important;
  color: var(--theme-cyan) !important;
  cursor: pointer !important;
  border-radius: 50% !important;
  background-color: rgba(0, 15, 30, 0.7) !important;
  border: 2px solid rgba(0, 250, 255, 0.5) !important;
  box-shadow: 0 0 8px rgba(0, 250, 255, 0.4), inset 0 0 10px rgba(0, 250, 255, 0.1) !important;
  transition: all 0.3s ease !important;
  -webkit-backdrop-filter: blur(2px) !important;
  backdrop-filter: blur(2px) !important;
}

.settings-btn:hover {
  transform: scale(1.05);
  background-color: rgba(0, 40, 70, 0.9) !important;
  box-shadow: 0 0 15px rgba(0, 250, 255, 0.7), inset 0 0 12px rgba(0, 250, 255, 0.2) !important;
  border-color: rgba(0, 250, 255, 0.8) !important;
}

.settings-btn svg {
  width: 20px !important;
  height: 20px !important;
  filter: drop-shadow(0 0 3px rgba(0, 250, 255, 0.6)) !important;
}

.neural-settings-popup {
  background-color: rgba(0, 15, 30, 0.95);
  border: 2px solid rgba(0, 250, 255, 0.5);
  box-shadow: 0 5px 25px rgba(0, 0, 0, 0.7), 0 0 20px rgba(0, 250, 255, 0.3);
  -webkit-backdrop-filter: blur(15px);
  backdrop-filter: blur(15px);
  min-width: 250px;
  z-index: 100;
  position: absolute;
  top: calc(100% + 10px);
  right: 0;
  padding: 14px 16px;
  

/* Usando display: flex em vez de block para permitir alinhamento vertical */


  display: flex;
  flex-direction: column;
  overflow: hidden;
  border-radius: 12px;
  margin-top: 0;
}

.settings-btn {
  background-color: rgba(0, 15, 30, 0.7) !important;
  border: 2px solid rgba(0, 250, 255, 0.5) !important;
  box-shadow: 0 0 8px rgba(0, 250, 255, 0.4), inset 0 0 10px rgba(0, 250, 255, 0.1) !important;
}

.settings-btn:hover {
  background-color: rgba(0, 30, 60, 0.9) !important;
  border-color: rgba(0, 250, 255, 0.8) !important;
  box-shadow: 0 0 15px rgba(0, 250, 255, 0.7), inset 0 0 12px rgba(0, 250, 255, 0.2) !important;
}

.settings-btn svg {
  filter: drop-shadow(0 0 3px #00faff);
}

.orchos-quantum-icon {
  z-index: 3;
  filter: drop-shadow(0 0 4px currentColor);
}

.orchos-quantum-ripple {
  position: absolute;
  border-radius: 50%;
  transform: translate(-50%, -50%);
  background: radial-gradient(circle, 
    rgba(0, 250, 255, 0.4) 0%, 
    rgba(124, 77, 255, 0.2) 50%, 
    transparent 70%
  );
  pointer-events: none;
  animation: quantumRippleExpand 1s ease-out forwards;
}

.orchos-quantum-btn:focus {
  outline: none;
  box-shadow: 
    0 0 50px rgba(0, 250, 255, 0.5),
    inset 0 0 30px rgba(0, 250, 255, 0.2),
    0 8px 30px rgba(0, 0, 0, 0.6),
    0 0 0 3px rgba(0, 250, 255, 0.3);
}

@media (prefers-reduced-motion: reduce) {
  .orchos-quantum-btn,
  .orchos-quantum-btn::before,
  .orchos-neural-ring,
  .orchos-quantum-particles::before,
  .orchos-quantum-particles::after {
    animation: none !important;
    transition: none !important;
  }
  
  .orchos-quantum-btn {
    transition: transform 0.2s ease;
  }
}

/* Transcription status styles */
.transcription-item {
  padding: 8px 12px;
  margin: 4px 0;
  transition: all 0.3s ease;
  border-radius: 8px;
  background: rgba(0, 0, 0, 0.2);
  border: 1px solid rgba(0, 250, 255, 0.1);
  line-height: 1.5;
}

.transcription-pending {
  color: var(--text-primary, rgba(255, 255, 255, 0.9));
  opacity: 1;
  background: rgba(0, 250, 255, 0.05);
  border-color: rgba(0, 250, 255, 0.2);
}

.transcription-sent {
  color: var(--text-secondary, rgba(255, 255, 255, 0.5));
  opacity: 0.6;
  font-style: italic;
  position: relative;
  padding-left: 30px;
  background: rgba(76, 175, 80, 0.05);
  border-color: rgba(76, 175, 80, 0.2);
}

.transcription-sent::before {
  content: "‚úì";
  position: absolute;
  left: 10px;
  color: var(--success-color, #4caf50);
  font-size: 14px;
  opacity: 0.8;
}

/* Add visual separator between sent and pending */
.transcription-text {
  position: relative;
  max-height: 300px;
  overflow-y: auto;
  padding: 8px;
}

/* Scrollable transcription text with fixed height */
.transcription-scrollable {
  max-height: 80px !important;
  overflow-y: auto !important;
  overflow-x: hidden !important;
  padding: 8px 12px;
  background: transparent;
  border-radius: 4px;
  line-height: 1.5;
  word-wrap: break-word;
  white-space: pre-wrap;
  display: block;
  
  /* Custom scrollbar styling */
  scrollbar-width: thin;
  scrollbar-color: rgba(0, 250, 255, 0.3) transparent;
}

.transcription-scrollable::-webkit-scrollbar {
  width: 6px;
}

.transcription-scrollable::-webkit-scrollbar-track {
  background: rgba(0, 0, 0, 0.2);
  border-radius: 3px;
}

.transcription-scrollable::-webkit-scrollbar-thumb {
  background: rgba(0, 250, 255, 0.4);
  border-radius: 3px;
  transition: background 0.3s ease;
}

.transcription-scrollable::-webkit-scrollbar-thumb:hover {
  background: rgba(0, 250, 255, 0.6);
}

/* Smooth scroll behavior */
.transcription-scrollable {
  scroll-behavior: smooth;
}

.transcription-pending:first-child {
  border-top: 2px solid rgba(0, 250, 255, 0.3);
  padding-top: 12px;
  margin-top: 12px;
}

/* Highlight new transcriptions */
.transcription-pending {
  animation: fadeInHighlight 0.5s ease-out;
}

/* Style for multi-line transcriptions */
.transcription-item br {
  display: block;
  margin: 4px 0;
}

@keyframes fadeInHighlight {
  from {
    opacity: 0;
    background-color: rgba(0, 250, 255, 0.2);
    transform: translateY(10px);
  }
  to {
    opacity: 1;
    background-color: rgba(0, 250, 255, 0.05);
    transform: translateY(0);
  }
}
// SPDX-License-Identifier: MIT OR Apache-2.0
// Copyright (c) 2025 Guilherme Ferrari Brescia

import { ConnectionState, MicrophoneState } from "../../../context";

export interface TranscriptionPanelProps {
  onClose: () => void;
  width?: string;
}

export interface ConnectionDetailsType {
  [key: string]: unknown;
  active?: boolean;
  socketStatus?: string;
  socketReadyState?: number;
  sessionId?: string;
  error?: string;
}

export interface DiagnosticsPanelProps {
  connectionState: ConnectionState;
  microphoneState: MicrophoneState;
}

export interface ConnectionDiagnosticsProps {
  connectionDetails: ConnectionDetailsType | null;
  setConnectionDetails: React.Dispatch<React.SetStateAction<ConnectionDetailsType | null>>;
  getConnectionStatus: () => ConnectionDetailsType;
  showToast: (title: string, description: string, variant: "neutral" | "success" | "error") => void;
  disconnectFromDeepgram: () => Promise<void>;
  connectToDeepgram: () => Promise<boolean>;
  waitForConnectionState: (targetState: ConnectionState, timeoutMs: number) => Promise<boolean>;
  hasActiveConnection: () => boolean;
  ConnectionState: typeof ConnectionState;
}

export interface TextControlsProps {
  label: string;
  onClear: () => void;

  onExpand?: () => void;
}

export interface DeviceSelectorProps {
  devices: MediaDeviceInfo[];
  selectedId: string;
  onChange: (deviceId: string) => void;
  title: string;
  isSystemAudio: boolean;
}

export interface ToggleSwitchProps {
  label: string;
  isOn: boolean;
  onChange: () => void;
  title: string;
}

export interface AudioControlsProps {
  isMicrophoneOn: boolean;
  setIsMicrophoneOn: (isOn: boolean) => void;
  isSystemAudioOn: boolean;
  setIsSystemAudioOn: (isOn: boolean) => void;
  audioDevices: MediaDeviceInfo[];
  selectedDevices: {
    microphone: string | null;
    systemAudio: string | null;
  };
  handleDeviceChange: (deviceId: string, isSystemAudio: boolean) => void;
}

export interface TranscriptionTextsState {
  transcription: string;
  aiResponse: string;
}

export interface ImportModalProps {
  show: boolean;
  onClose: () => void;
  importFile: File | null;
  setImportFile: React.Dispatch<React.SetStateAction<File | null>>;
  importUserName: string;
  setImportUserName: React.Dispatch<React.SetStateAction<string>>;
  importMode: ImportMode;
  setImportMode: React.Dispatch<React.SetStateAction<ImportMode>>;
  importProgress: number;
  importStage: string;
  importSummary: string;
  isImporting: boolean;
  handleFileChange: (e: React.ChangeEvent<HTMLInputElement>) => void;
  handleStartImport: (userName: string) => Promise<void>;
  handleCloseImportModal: () => void;
}

// Define interfaces for import functionality using Interface Segregation Principle
export type ImportMode = 'overwrite' | 'increment';

export interface ImportProgressData {
  processed: number;
  total: number;
  percentage?: number;
  stage?: string;
}

// This interface is used internally in the ImportModal component
export interface ImportOptions {
  fileBuffer: ArrayBuffer | Buffer;
  mode: ImportMode;
  user: string;
  onProgress: (data: ImportProgressData) => void;
}

// Interface for the import service (Dependency Inversion Principle)
export interface IChatGptImportService {
  importChatHistory(options: {
    fileBuffer: ArrayBuffer | Buffer;
    mode: ImportMode;
    user: string;
    onProgress?: (data: ImportProgressData) => void;
  }): Promise<{ success: boolean; error?: string; imported?: number; skipped?: number }>;
}
// SPDX-License-Identifier: MIT OR Apache-2.0
// Copyright (c) 2025 Guilherme Ferrari Brescia

// Re-export components for easier importing
export { default as TranscriptionPanel } from './TranscriptionPanel';
export { default as AudioControls } from './components/AudioControls';
export { default as CognitionLogSection } from './components/CognitionLogSection';
export { default as ConnectionDiagnostics } from './components/ConnectionDiagnostics';
export { default as DeviceSelector } from './components/DeviceSelector';
export { default as DiagnosticsPanel } from './components/DiagnosticsPanel';
export { default as ImportModal } from './components/ImportModal';
export { default as LanguageSelector } from './components/LanguageSelector';
export { default as PanelHeader } from './components/PanelHeader';
export { default as RecordingControl } from './components/RecordingControl';
export { default as TextControls } from './components/TextControls';
export { default as TextEditor } from './components/TextEditor';
export { default as ToggleSwitch } from './components/ToggleSwitch';

// Re-export hooks
export { useTranscriptionManager } from './hooks/useTranscriptionManager';
export { useChatGptImport } from './hooks/useChatGptImport';

// Re-export types
export * from './types/interfaces';
// SPDX-License-Identifier: MIT OR Apache-2.0
// Copyright (c) 2025 Guilherme Ferrari Brescia

import React, { useCallback, useEffect, useRef, useState } from "react";
import { useToast } from "../../../App";
import { useCognitionLog } from "../../context/CognitionLogContext";
import AudioControls from "./components/AudioControls";
import CognitionLogSection from "./components/CognitionLogSection";
import ImportModal from "./components/ImportModal";
import PanelHeader from "./components/PanelHeader";
import SettingsModal from "./components/SettingsModal";
import { useChatGptImport } from "./hooks/useChatGptImport";
import { useTranscriptionManager } from "./hooks/useTranscriptionManager";
import { TranscriptionPanelProps } from "./types/interfaces";
// Import para controlar a visibilidade da visualiza√ß√£o qu√¢ntica
import { useGeneralSettings } from "./components/settings/hooks/useGeneralSettings";
// M√≥dulo cortical para cards simples
// Importa√ß√£o dos arquivos CSS modulares - estrutura neural-simb√≥lica
import "./styles/TranscriptionPanel.animations.css"; // Anima√ß√µes e keyframes
import "./styles/TranscriptionPanel.buttons.css"; // Bot√µes e controles interativos
import "./styles/TranscriptionPanel.chathistory.css"; // Hist√≥rico de chats
import "./styles/TranscriptionPanel.layout.css"; // Layout, grid e estrutura espacial
import "./styles/TranscriptionPanel.overrides.css"; // Overrides para single-column mode
import "./styles/TranscriptionPanel.settings.css"; // Componentes de configura√ß√£o
import "./styles/TranscriptionPanel.tooltip.css"; // Tooltips e ajudas contextuais
import "./styles/TranscriptionPanel.variables.css"; // Vari√°veis globais e propriedades customizadas
import "./styles/TranscriptionPanel.visual.css"; // Efeitos visuais e glassmorfismo
// Quantum consciousness visualization import
import { QuantumVisualizationContainer } from "../QuantumVisualization/QuantumVisualizationContainer";
// Conversational Chat import
import { ConversationalChat } from "./components/ConversationalChat";
// Chat History imports
import { ChatHistorySidebar } from "./components/ConversationalChat/components/ChatHistorySidebar";
import { useChatHistory } from "./components/ConversationalChat/hooks/useChatHistory";
// Brain visualization is now handled in a separate module

const TranscriptionPanel: React.FC<TranscriptionPanelProps> = ({
  onClose,
  width,
}) => {
  const transcriptionManager = useTranscriptionManager();
  const { showToast } = useToast();

  // Hook para acessar as configura√ß√µes gerais, incluindo enableMatrix
  const { enableMatrix } = useGeneralSettings();

  // Chat History Hook
  const chatHistory = useChatHistory();

  // Track processing state
  const [isProcessing, setIsProcessing] = useState(false);

  if (!transcriptionManager) return null;

  // Move stable callbacks here when setTexts is already defined

  const {
    language,
    setLanguage,
    microphoneState,
    connectionState,
    toggleRecording,
    handleSendPrompt,
    clearTranscription,
    clearAiResponse,
    toggleExpand,
    isExpanded,
    temporaryContext,
    setTemporaryContext,
    texts,
    setTexts,
    audioDevices,
    selectedDevices,
    handleDeviceChange,
    isMicrophoneOn,
    isSystemAudioOn,
    setIsMicrophoneOn,
    setIsSystemAudioOn,
    showDetailedDiagnostics,
    setShowDetailedDiagnostics,
    connectionDetails,
    setConnectionDetails,
    transcriptionRef,
    getConnectionStatus,
    disconnectFromDeepgram,
    connectToDeepgram,
    waitForConnectionState,
    hasActiveConnection,
    ConnectionState,
  } = transcriptionManager;

  const {
    events: cognitionEvents,
    exporters,
    clearEvents,
    exportEvents,
  } = useCognitionLog();

  const {
    importFile,
    setImportFile,
    importUserName,
    setImportUserName,
    importMode,
    setImportMode,
    importProgress,
    importStage,
    importSummary,
    isImporting,
    showImportModal,
    setShowImportModal,
    handleFileChange,
    handleStartImport,
    handleCloseImportModal,
  } = useChatGptImport(showToast);

  // Stable callbacks defined AFTER setTexts is available to avoid TS errors
  const handleTranscriptionChange = useCallback(
    (value: string) => {
      console.log("üîÑ [PANEL] Transcription change:", value.substring(0, 50));
      setTexts((prev) => ({ ...prev, transcription: value }));
    },
    [setTexts]
  );

  const handleAiResponseChange = useCallback(
    (value: string) => {
      console.log("üîÑ [PANEL] AI response change:", value.substring(0, 50));
      setTexts((prev) => ({ ...prev, aiResponse: value }));
    },
    [setTexts]
  );

  const handleTemporaryContextChange = useCallback(
    (value: string) => {
      console.log(
        "üîÑ [PANEL] Temporary context change:",
        value.substring(0, 50)
      );
      setTemporaryContext(value);
    },
    [setTemporaryContext]
  );

  // Brain state and logic has been moved to BrainVisualization module

  // Brain visualization components have been moved to BrainVisualization module

  // --- Configura√ß√µes simples para Audio/Language Controls ---
  const [showSettings, setShowSettings] = useState(false);
  const settingsContainerRef = useRef<HTMLDivElement>(null);
  const settingsBtnRef = useRef<HTMLButtonElement>(null);
  const popupRef = useRef<HTMLDivElement>(null);
  const [settingsPopupPosition, setSettingsPopupPosition] = useState({
    top: 0,
    left: 0,
  });

  // Fun√ß√£o para alternar a visibilidade das configura√ß√µes
  const toggleSettings = () => {
    setShowSettings(!showSettings);
  };

  // Fechar configura√ß√µes ao clicar fora
  useEffect(() => {
    function handleClickOutside(event: MouseEvent) {
      if (
        settingsBtnRef.current &&
        !settingsBtnRef.current.contains(event.target as Node) &&
        popupRef.current &&
        !popupRef.current.contains(event.target as Node)
      ) {
        setShowSettings(false);
      }
    }
    if (showSettings) {
      document.addEventListener("mousedown", handleClickOutside);
    }
    return () => {
      document.removeEventListener("mousedown", handleClickOutside);
    };
  }, [showSettings]);

  useEffect(() => {
    if (showSettings && settingsBtnRef.current) {
      const rect = settingsBtnRef.current.getBoundingClientRect();
      const POPUP_WIDTH = 350;
      let left = rect.right + window.scrollX - POPUP_WIDTH;
      // Garante que n√£o vaze para fora da viewport
      left = Math.max(8, Math.min(left, window.innerWidth - POPUP_WIDTH - 8));
      setSettingsPopupPosition({
        top: rect.bottom + window.scrollY + 8,
        left,
      });
    }
  }, [showSettings]);

  // Prevent body scroll when dashboard is active
  useEffect(() => {
    document.body.classList.add("orchos-active");
    return () => {
      document.body.classList.remove("orchos-active");
    };
  }, []);

  // Estados para modais
  const [showLogsModal, setShowLogsModal] = useState(false);
  const [showSettingsModal, setShowSettingsModal] = useState(false);
  const [mobileSidebarOpen, setMobileSidebarOpen] = useState(false);

  // Settings content for the chat component
  const settingsContent = (
    <div className="neural-settings-popup">
      <div className="mb-2 pb-2">
        <h3 className="orchos-title flex items-center gap-2">
          <svg
            width="16"
            height="16"
            viewBox="0 0 24 24"
            fill="none"
            stroke="#00faff"
            strokeWidth="2"
          >
            <circle cx="12" cy="12" r="3"></circle>
            <path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z"></path>
          </svg>
          Neural Settings
        </h3>
      </div>
      <div className="flex flex-col gap-4 px-1">
        <AudioControls
          isMicrophoneOn={isMicrophoneOn}
          setIsMicrophoneOn={setIsMicrophoneOn}
          isSystemAudioOn={isSystemAudioOn}
          setIsSystemAudioOn={setIsSystemAudioOn}
          audioDevices={audioDevices}
          selectedDevices={selectedDevices}
          handleDeviceChange={handleDeviceChange}
        />
      </div>
    </div>
  );

  // Generate a key based on current conversation ID to force remount when conversation changes
  const chatKey = React.useMemo(
    () => chatHistory.currentConversationId || "default-chat",
    [chatHistory.currentConversationId]
  );

  // --- Render ---
  return (
    <div
      style={{
        height: "100vh",
        width: "100vw",
        display: "flex",
        flexDirection: "column",
        overflow: "hidden",
        maxHeight: "100vh",
        maxWidth: "100vw",
      }}
    >
      {/* Panel Header - Now positioned absolutely */}
      <PanelHeader
        onClose={() => {
          if (window?.electronAPI?.closeWindow) {
            window.electronAPI.closeWindow();
          } else if (onClose) {
            onClose();
          }
        }}
        onMinimize={() => {
          if (window?.electronAPI?.minimizeWindow) {
            window.electronAPI.minimizeWindow();
          }
        }}
        onShowSettings={() => setShowSettingsModal(true)}
        onShowLogsModal={() => setShowLogsModal(true)}
        onShowImportModal={() => setShowImportModal(true)}
        onToggleDiagnostics={() =>
          setShowDetailedDiagnostics(!showDetailedDiagnostics)
        }
        connectionState={connectionState}
        microphoneState={microphoneState}
        hasActiveConnection={hasActiveConnection}
        onDisconnect={disconnectFromDeepgram}
        onReconnect={connectToDeepgram}
      />

      {/* Main Chat Dashboard Layout */}
      <div
        className={`orchos-quantum-dashboard with-sidebar ${
          !enableMatrix ? "single-column" : ""
        }`}
        style={{
          flex: "1 1 auto",
        }}
      >
        {/* Chat History Sidebar */}
        <div
          className={`chat-history-sidebar ${
            mobileSidebarOpen ? "mobile-open" : ""
          }`}
        >
          <ChatHistorySidebar
            conversations={chatHistory.conversations}
            currentConversationId={chatHistory.currentConversationId}
            onSelectConversation={(id: string) => {
              // Clear any pending AI responses when switching conversations
              clearAiResponse();
              clearTranscription();
              chatHistory.selectConversation(id);
            }}
            onCreateNewConversation={() => {
              // Clear any pending AI responses when creating new conversation
              clearAiResponse();
              clearTranscription();
              return chatHistory.createNewConversation();
            }}
            onDeleteConversation={chatHistory.deleteConversation}
            onSearchConversations={chatHistory.searchConversations}
            isProcessing={isProcessing}
          />
        </div>

        {/* Quantum Visualization Zone - Left Panel with Golden Ratio */}
        {/* L√≥gica corrigida: enableMatrix = true mostra, false esconde */}
        {enableMatrix && (
          <div
            key="quantum-visualization-zone"
            className="quantum-visualization-zone"
          >
            <QuantumVisualizationContainer
              cognitionEvents={cognitionEvents}
              height="100%"
              width="100%"
              lowPerformanceMode={false}
              showLegend={true}
            />
          </div>
        )}

        {/* Conversational Chat Zone - Main Panel */}
        <div
          key="neural-chat-zone"
          className="neural-chat-zone"
          style={{
            height: "100%",
            width: "100%",
            padding: "1.2rem",
            overflow: "hidden" /* For√ßa o chat a usar scroll interno */,
            display: "flex",
            flexDirection: "column",
          }}
        >
          <ConversationalChat
            key={chatKey}
            transcriptionText={texts.transcription}
            onTranscriptionChange={handleTranscriptionChange}
            onClearTranscription={clearTranscription}
            aiResponseText={texts.aiResponse}
            onAiResponseChange={handleAiResponseChange}
            onClearAiResponse={clearAiResponse}
            temporaryContext={temporaryContext}
            onTemporaryContextChange={handleTemporaryContextChange}
            microphoneState={microphoneState}
            onToggleRecording={toggleRecording}
            onSendPrompt={handleSendPrompt}
            // Audio settings props
            language={language}
            setLanguage={setLanguage}
            isMicrophoneOn={isMicrophoneOn}
            setIsMicrophoneOn={setIsMicrophoneOn}
            isSystemAudioOn={isSystemAudioOn}
            setIsSystemAudioOn={setIsSystemAudioOn}
            audioDevices={audioDevices}
            selectedDevices={selectedDevices}
            handleDeviceChange={handleDeviceChange}
            // Chat History props
            currentConversation={chatHistory.currentConversation}
            onAddMessageToConversation={chatHistory.addMessageToConversation}
            onProcessingChange={setIsProcessing}
          />
        </div>
      </div>

      {/* Import Modal - Always on top */}
      {showImportModal && (
        <ImportModal
          show={showImportModal}
          onClose={handleCloseImportModal}
          importFile={importFile}
          setImportFile={setImportFile}
          importUserName={importUserName}
          setImportUserName={setImportUserName}
          importMode={importMode}
          setImportMode={setImportMode}
          importProgress={importProgress}
          importStage={importStage}
          importSummary={importSummary}
          isImporting={isImporting}
          handleFileChange={handleFileChange}
          handleStartImport={handleStartImport}
          handleCloseImportModal={handleCloseImportModal}
        />
      )}

      {/* Modal de Logs de Cogni√ß√£o */}
      {showLogsModal && (
        <div className="fixed inset-0 z-50 flex items-center justify-center bg-black/60">
          <div className="orchos-cognition-logs-modal">
            <div className="orchos-cognition-logs-header">
              <h2 className="text-xl font-bold text-[#7c4dff] flex items-center gap-2">
                <svg width="22" height="22" viewBox="0 0 20 20" fill="none">
                  <ellipse
                    cx="10"
                    cy="10"
                    rx="8"
                    ry="6"
                    stroke="#7c4dff"
                    strokeWidth="2"
                  />
                  <circle cx="10" cy="10" r="3" fill="#7c4dff" />
                </svg>
                Cognition Logs
              </h2>
              <button
                className="ml-2 px-2 py-1 rounded-full hover:bg-[#7c4dff22] transition"
                onClick={() => setShowLogsModal(false)}
                aria-label="Close logs modal"
              >
                <svg width="20" height="20" viewBox="0 0 20 20" fill="none">
                  <path
                    d="M6 6l8 8M14 6l-8 8"
                    stroke="#7c4dff"
                    strokeWidth="2"
                    strokeLinecap="round"
                  />
                </svg>
              </button>
            </div>
            <CognitionLogSection
              cognitionEvents={cognitionEvents}
              exporters={exporters}
              exportEvents={exportEvents}
              clearEvents={clearEvents}
            />
          </div>
        </div>
      )}

      {/* Settings Modal */}
      {showSettingsModal && (
        <SettingsModal
          show={showSettingsModal}
          onClose={() => setShowSettingsModal(false)}
        />
      )}

      {/* Mobile Sidebar Toggle Button */}
      <button
        className="mobile-sidebar-toggle"
        onClick={() => setMobileSidebarOpen(!mobileSidebarOpen)}
        title="Hist√≥rico de conversas"
      >
        <svg width="24" height="24" viewBox="0 0 24 24" fill="none">
          <path
            d="M3 12h18m-18-6h18m-18 12h18"
            stroke="currentColor"
            strokeWidth="2"
            strokeLinecap="round"
          />
        </svg>
      </button>
    </div>
  );
};

export default TranscriptionPanel;
// SPDX-License-Identifier: MIT OR Apache-2.0
// Copyright (c) 2025 Guilherme Ferrari Brescia

import * as React from "react"
import * as ToastPrimitive from "@radix-ui/react-toast"
import { cn } from "../../lib/utils"
import { AlertCircle, CheckCircle2, Info, X } from "lucide-react"

const ToastProvider = ToastPrimitive.Provider

export type ToastMessage = {
  title: string
  description: string
  variant: ToastVariant
}

const ToastViewport = React.forwardRef<
  React.ElementRef<typeof ToastPrimitive.Viewport>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitive.Viewport>
>(({ className, ...props }, ref) => (
  <ToastPrimitive.Viewport
    ref={ref}
    className={cn(
      "fixed top-0 right-0 z-[100] flex max-h-screen w-full flex-col-reverse gap-1 p-2 sm:top-0 sm:right-0 sm:flex-col md:max-w-[320px]",
      className
    )}
    {...props}
  />
))
ToastViewport.displayName = ToastPrimitive.Viewport.displayName

type ToastVariant = "neutral" | "success" | "error"

interface ToastProps
  extends React.ComponentPropsWithoutRef<typeof ToastPrimitive.Root> {
  variant?: ToastVariant
  swipeDirection?: "right" | "left" | "up" | "down"
}

const toastVariants: Record<
  ToastVariant,
  { icon: React.ReactNode; bgColor: string }
> = {
  neutral: {
    icon: <Info className="h-3 w-3 text-amber-700" />,
    bgColor: "bg-amber-100"
  },
  success: {
    icon: <CheckCircle2 className="h-3 w-3 text-emerald-700" />,
    bgColor: "bg-emerald-100"
  },
  error: {
    icon: <AlertCircle className="h-3 w-3 text-red-700" />,
    bgColor: "bg-red-100"
  }
}

const Toast = React.forwardRef<
  React.ElementRef<typeof ToastPrimitive.Root>,
  ToastProps
>(({ className, variant = "neutral", ...props }, ref) => (
  <ToastPrimitive.Root
    ref={ref}
    duration={4000}
    className={cn(
      "group pointer-events-auto relative flex w-full items-center space-x-2 overflow-hidden rounded-md p-2",
      toastVariants[variant].bgColor,
      className
    )}
    {...props}
  >
    {toastVariants[variant].icon}
    <div className="flex-1">{props.children}</div>
    <ToastPrimitive.Close className="absolute right-1 top-1 rounded-md p-0.5 text-zinc-500 opacity-0 transition-opacity hover:text-zinc-700 group-hover:opacity-100">
      <X className="h-2 w-2" />
    </ToastPrimitive.Close>
  </ToastPrimitive.Root>
))
Toast.displayName = ToastPrimitive.Root.displayName

const ToastAction = React.forwardRef<
  React.ElementRef<typeof ToastPrimitive.Action>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitive.Action>
>(({ className, ...props }, ref) => (
  <ToastPrimitive.Action
    ref={ref}
    className={cn(
      "text-[0.65rem] font-medium text-zinc-600 hover:text-zinc-900",
      className
    )}
    {...props}
  />
))
ToastAction.displayName = ToastPrimitive.Action.displayName

const ToastTitle = React.forwardRef<
  React.ElementRef<typeof ToastPrimitive.Title>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitive.Title>
>(({ className, ...props }, ref) => (
  <ToastPrimitive.Title
    ref={ref}
    className={cn("text-[0.7rem] font-medium text-zinc-900", className)}
    {...props}
  />
))
ToastTitle.displayName = ToastPrimitive.Title.displayName

const ToastDescription = React.forwardRef<
  React.ElementRef<typeof ToastPrimitive.Description>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitive.Description>
>(({ className, ...props }, ref) => (
  <ToastPrimitive.Description
    ref={ref}
    className={cn("text-[0.65rem] text-zinc-600", className)}
    {...props}
  />
))
ToastDescription.displayName = ToastPrimitive.Description.displayName

export type { ToastProps, ToastVariant }
export {
  ToastProvider,
  ToastViewport,
  Toast,
  ToastAction,
  ToastTitle,
  ToastDescription
}// SPDX-License-Identifier: MIT OR Apache-2.0
// Copyright (c) 2025 Guilherme Ferrari Brescia



// Get the platform safely
const getPlatform = () => {
    try {
      return window.electronAPI?.getPlatform() || 'win32' // Default to win32 if API is not available
    } catch {
      return 'win32' // Default to win32 if there's an error
    }
  }
  
  // Platform-specific command key symbol
  export const COMMAND_KEY = getPlatform() === 'darwin' ? '‚åò' : 'Ctrl'
  
  // Helper to check if we're on Windows
  export const isWindows = getPlatform() === 'win32'
  
  // Helper to check if we're on macOS
  export const isMacOS = getPlatform() === 'darwin' // SPDX-License-Identifier: MIT OR Apache-2.0
// Copyright (c) 2025 Guilherme Ferrari Brescia

import * as ort from 'onnxruntime-web';

/**
 * onnxruntimeConfig.ts
 * Global ONNX Runtime Web configuration for Orch-OS
 * Applies optimal settings for performance and suppresses benign warnings.
 */
export class OnnxRuntimeConfig {
  /**
   * Apply global ONNX Runtime settings. Call once at startup before any session creation.
   */
  static initialize(): void {
    // WASM flags
    ort.env.wasm.simd = true;
    ort.env.wasm.numThreads = Math.min(4, navigator.hardwareConcurrency || 4);
    ort.env.wasm.proxy = false;

    // WebGPU flags
    if (ort.env.webgpu) {
      ort.env.webgpu.validateInputContent = false;
    }

    // Logging: show warnings and errors only
    ort.env.logSeverityLevel = 2; // 0=VERBOSE,1=INFO,2=WARNING,3=ERROR,4=FATAL
    ort.env.logVerbosityLevel = 0;

    // Suppress known harmless warnings
    this.suppressHarmlessWarnings();
  }

  /**
   * Build optimized SessionOptions for a given provider.
   */
  static getSessionOptions(
    provider: 'webgpu' | 'wasm'
  ): ort.InferenceSession.SessionOptions {
    const executionProviders = provider === 'webgpu' ? ['webgpu', 'wasm'] : ['wasm'];

    return {
      executionProviders,
      graphOptimizationLevel: 'all',
      enableMemPattern: true,
      enableCpuMemArena: true,
      interOpNumThreads: provider === 'wasm' ? 1 : undefined,
      intraOpNumThreads: provider === 'wasm' ? 1 : undefined,
      logSeverityLevel: 2,
      logVerbosityLevel: 0,
    };
  }

  /**
   * Silence known-onboarding warnings from ONNX Runtime Web.
   */
  private static suppressHarmlessWarnings() {
    const origWarn = console.warn;
    const origErr  = console.error;

    const harmlessPatterns = [
      /VerifyEachNodeIsAssignedToAnEp/, // expected fallback info
    ];

    console.warn = (...args: any[]) => {
      const msg = args.join(' ');
      if (harmlessPatterns.some(p => p.test(msg))) return;
      origWarn.apply(console, args);
    };

    console.error = (...args: any[]) => {
      const msg = args.join(' ');
      if (harmlessPatterns.some(p => p.test(msg))) return;
      origErr.apply(console, args);
    };
  }
}

// Auto-initialize if imported in browser
if (typeof window !== 'undefined') {
  OnnxRuntimeConfig.initialize();
}// SPDX-License-Identifier: MIT OR Apache-2.0
// Copyright (c) 2025 Guilherme Ferrari Brescia

// Central user config for the application
import { getUserName } from '../services/StorageService';

// Central user config for the application
export function getPrimaryUser(): string {
  // Symbolic: retrieves the primary user's name from storage cortex
  return getUserName();
}
// SPDX-License-Identifier: MIT OR Apache-2.0
// Copyright (c) 2025 Guilherme Ferrari Brescia

/**
 * Orch-OS Neural-Symbolic Interface Specification
 * 
 * SimpleModule - Interface para m√≥dulos de UI colaps√°veis/expans√≠veis.
 * Inten√ß√£o simb√≥lica: Representa um c√≥rtex neuralmente adapt√°vel que pode
 * expandir ou colapsar para otimizar a densidade cognitiva da interface.
 */

import { ReactNode } from 'react';

export interface SimpleModuleProps {
  /** T√≠tulo do m√≥dulo cortical */
  title: string;
  
  /** Define se o m√≥dulo inicia em estado expandido */
  defaultOpen?: boolean;
  
  /** Conte√∫do neural do m√≥dulo */
  children: ReactNode;
  
  /** Usado apenas para debugging visual - n√£o para produ√ß√£o */
  debugBorder?: boolean;
}

export interface SimpleModuleState {
  /** Estado atual (expandido/colapsado) */
  isExpanded: boolean;
  
  /** Fun√ß√£o para alternar entre estados */
  toggle: () => void;
}
// SPDX-License-Identifier: MIT OR Apache-2.0
// Copyright (c) 2025 Guilherme Ferrari Brescia

// INeuralSignalService.ts
// Symbolic: Contract for neural signal extraction cortex
import { NeuralSignalResponse } from '../../../components/context/deepgram/interfaces/neural/NeuralSignalTypes';

export interface INeuralSignalService {
  generateNeuralSignal(
    prompt: string,
    temporaryContext?: string,
    language?: string
  ): Promise<NeuralSignalResponse>;
}
// SPDX-License-Identifier: MIT OR Apache-2.0
// Copyright (c) 2025 Guilherme Ferrari Brescia

// ISemanticEnricher.ts
// Symbolic: Contract for semantic enrichment cortex

export interface ISemanticEnricher {
  enrichSemanticQueryForSignal(
    core: string,
    query: string,
    intensity: number,
    context?: string,
    language?: string
  ): Promise<{ enrichedQuery: string; keywords: string[] }>;
}
// SPDX-License-Identifier: MIT OR Apache-2.0
// Copyright (c) 2025 Guilherme Ferrari Brescia

import { ModeService, OrchOSModeEnum } from "../../../services/ModeService";
import {
  ChatGPTSession,
  ImportChatGPTParams,
  ImportResult,
} from "../interfaces/types";
import { DeduplicationService } from "../services/deduplication/DeduplicationService";
import { EmbeddingService } from "../services/embedding/EmbeddingService";
import { ChatGPTParser } from "../services/parser/ChatGPTParser";
import { VectorStorageService } from "../services/storage/VectorStorageService";
import { TextChunker } from "../services/text-processor/TextChunker";
import { Logger } from "../utils/logging";
import { ProgressReporter } from "../utils/progressReporter";

/**
 * Handler for importing ChatGPT history
 * Orchestrates different services following SOLID principles
 */
export async function importChatGPTHistoryHandler(
  params: ImportChatGPTParams
): Promise<ImportResult> {
  const {
    fileBuffer,
    mode,
    applicationMode,
    openAIService,
    pineconeHelper,
    onProgress,
  } = params;

  // Initialize services
  const logger = new Logger("[ImportChatGPT]");
  const progressReporter = new ProgressReporter(onProgress, logger);

  // Determine mode for service configuration
  let currentMode: OrchOSModeEnum;
  if (applicationMode) {
    // Convert string to enum
    if (applicationMode.toLowerCase() === "basic") {
      currentMode = OrchOSModeEnum.BASIC;
    } else if (applicationMode.toLowerCase() === "advanced") {
      currentMode = OrchOSModeEnum.ADVANCED;
    } else {
      logger.warn(
        `üü° Unknown applicationMode: "${applicationMode}", falling back to ModeService`
      );
      currentMode = ModeService.getMode();
    }
    logger.info(
      `üîß Using applicationMode from IPC: "${applicationMode}" -> ${currentMode}`
    );
  } else {
    currentMode = ModeService.getMode();
    logger.info(
      `üîß No applicationMode provided, using ModeService: ${currentMode}`
    );
  }

  const isBasicMode = currentMode === OrchOSModeEnum.BASIC;
  const storageType = "DuckDB"; // Always use DuckDB for both Basic and Advanced modes
  logger.info(
    `üóÑÔ∏è Storage mode: ${storageType} (${
      isBasicMode ? "Basic" : "Advanced"
    } mode)`
  );

  // Use the helper passed from IPC (already correct for the mode)
  const vectorHelper = pineconeHelper;

  const parser = new ChatGPTParser(progressReporter, logger);
  const deduplicationService = new DeduplicationService(
    vectorHelper,
    progressReporter,
    logger
  );
  const textChunker = new TextChunker();
  const embeddingService = new EmbeddingService(
    openAIService,
    logger,
    progressReporter,
    applicationMode
  );
  const storageService = new VectorStorageService(
    vectorHelper,
    progressReporter,
    logger,
    true // Always use DuckDB mode (true = isBasicMode)
  );

  try {
    // Log of start
    logger.info(
      `Starting ChatGPT import in ${mode} mode with applicationMode: ${
        applicationMode || "auto-detect"
      } using ${storageType}`
    );

    // 1. Parse the file
    const rawSessions = parser.parseBuffer(fileBuffer);

    // 2. Extract messages
    let allMessages = parser.extractMessages(rawSessions);
    logger.info(`Extracted ${allMessages.length} messages from file`);

    // 3. Ensure all messages have valid IDs
    logger.info("PASSO 3: Ensuring all messages have valid IDs...");
    allMessages = parser.ensureMessageIds(allMessages);
    logger.info("PASSO 3: IDs ensured successfully");

    // 4. Deduplication
    logger.info("PASSO 4: Starting deduplication...");
    let uniqueMessages;
    try {
      uniqueMessages = await deduplicationService.filterDuplicates(
        allMessages,
        mode
      );
      logger.info(
        `PASSO 4: After deduplication: ${uniqueMessages.length} unique messages`
      );
      logger.info("PASSO 4 COMPLETED: Moving to step 5...");

      // Additional verification right after deduplication
      if (!uniqueMessages || !Array.isArray(uniqueMessages)) {
        throw new Error(`Invalid deduplication result: ${uniqueMessages}`);
      }

      logger.info("CRITICAL CHECKPOINT: Deduplication completed successfully");
    } catch (error) {
      logger.error("FATAL ERROR during deduplication:", error);
      if (error instanceof Error) {
        logger.error(`Error details: ${error.message}`);
        logger.error(`Stack trace: ${error.stack || "Not available"}`);
      }
      throw new Error(
        `Deduplication failed: ${
          error instanceof Error ? error.message : String(error)
        }`
      );
    }

    try {
      // 5. Data cleanup (overwrite mode)
      logger.info(`PASSO 5: Starting with mode=${mode}`);
      if (mode === "overwrite") {
        logger.info(
          `PASSO 5: Deleting existing data (overwrite mode) from ${storageType}...`
        );
        await storageService.deleteExistingData();
        logger.info(
          `PASSO 5: Existing data deleted successfully from ${storageType}`
        );
      } else {
        logger.info("PASSO 5: Increment mode - skipping data cleanup");
      }
      logger.info("PASSO 5 COMPLETED: Moving to step 6...");
    } catch (error) {
      logger.error("FATAL ERROR in step 5:", error);
      throw new Error(
        `Step 5 failed: ${
          error instanceof Error ? error.message : String(error)
        }`
      );
    }

    // Initialize embedding service based on mode (both use DuckDB storage)
    if (isBasicMode) {
      logger.info(
        "Initializing HuggingFace service for embeddings (Basic mode with DuckDB)..."
      );
    } else if (openAIService) {
      logger.info(
        "Initializing Ollama service for embeddings (Advanced mode with DuckDB)..."
      );
      const initialized = await embeddingService.ensureOpenAIInitialized();
      logger.info(
        `Ollama service initialization status: ${initialized ? "OK" : "FAILED"}`
      );
      if (!initialized) {
        logger.error(
          "Ollama service could not be initialized. Check Ollama configuration."
        );
        logger.info("Ensure Ollama is running and properly configured");
      }
    }

    // Verification of TextChunker before processing
    logger.info("VERIFICATION: Verifying TextChunker before processing...");
    try {
      logger.info(`TextChunker available: ${textChunker ? "YES" : "NO"}`);
      logger.info(
        `Number of messages to be processed: ${uniqueMessages.length}`
      );
      if (uniqueMessages.length > 0) {
        logger.info(
          `Example message for processing: ${JSON.stringify(
            uniqueMessages[0]
          ).substring(0, 150)}...`
        );
      }
    } catch (err) {
      logger.error("Verification failed: Error verifying TextChunker:", err);
    }

    // 6. Process messages into chunks
    logger.info("PASSO 6: Starting message chunk processing...");
    let messageChunks;
    try {
      // Verify input for chunk processor
      logger.info(
        `PASSO 6: Input for processor: ${
          uniqueMessages.length
        } messages, first item: ${JSON.stringify(uniqueMessages[0]).substring(
          0,
          100
        )}...`
      );

      messageChunks = textChunker.processMessagesIntoChunks(uniqueMessages);
      if (!messageChunks) {
        throw new Error("TextChunker returned undefined or null");
      }
      logger.info(
        `PASSO 6: Created ${messageChunks.length} text chunks from ${uniqueMessages.length} messages`
      );
      if (messageChunks.length > 0) {
        logger.info(
          `PASSO 6: Example chunk: ${JSON.stringify(messageChunks[0]).substring(
            0,
            100
          )}...`
        );
      }

      logger.info("PASSO 6 COMPLETED: Moving to step 7...");
    } catch (error) {
      logger.error("FATAL ERROR in chunk processing:", error);
      throw new Error(
        `Chunk processing failed: ${
          error instanceof Error ? error.message : String(error)
        }`
      );
    }

    // 7. Create batches for efficient processing
    logger.info("PASSO 7: Creating batches for efficient processing...");
    let batches;
    try {
      if (!messageChunks || messageChunks.length === 0) {
        throw new Error("No chunks available for batch processing");
      }
      batches = textChunker.createProcessingBatches(messageChunks);
      if (!batches) {
        throw new Error(
          "TextChunker returned undefined or null when creating batches"
        );
      }
      logger.info(
        `PASSO 7: Processing ${messageChunks.length} chunks in ${batches.length} batches`
      );
      logger.info(`PASSO 7: First batch has ${batches[0]?.length || 0} chunks`);
      logger.info("PASSO 7 COMPLETED: Moving to step 8...");
    } catch (error) {
      logger.error("FATAL ERROR in batch creation:", error);
      throw new Error(
        `Batch creation failed: ${
          error instanceof Error ? error.message : String(error)
        }`
      );
    }

    // Verification of transition between steps
    logger.info("TRANSITION: Moving from step 7 to step 8...");
    logger.info("=========== FIM DO DIAGN√ìSTICO ===========");
    logger.info("===============================================");

    // 8. Generate embeddings and create vectors
    logger.info(
      `STARTING EMBEDDINGS GENERATION using ${
        isBasicMode ? "HuggingFace" : "Ollama"
      } with DuckDB storage...`
    );
    let vectors;
    try {
      vectors = await embeddingService.generateEmbeddingsForChunks(
        batches,
        messageChunks
      );
      logger.info(`Generated ${vectors.length} vectors with embeddings`);
    } catch (error) {
      logger.error("FATAL ERROR in embedding generation:", error);
      throw new Error(
        `Embedding generation failed: ${
          error instanceof Error ? error.message : String(error)
        }`
      );
    }

    // 9. Save vectors to appropriate storage
    logger.info(
      `[DIAGNOSTIC] Vectors to be saved to ${storageType}: ${vectors.length}`
    );
    if (vectors.length > 0) {
      logger.info(
        `[DIAGNOSTIC] Example vector: ${JSON.stringify(vectors[0]).substring(
          0,
          200
        )}`
      );
    } else {
      logger.warn("[DIAGNOSTIC] No vectors generated for saving!");
    }
    const saveResult = await storageService.saveVectors(vectors);
    logger.info(
      `[DIAGNOSTIC] Save result to ${storageType}: success=${
        saveResult.success
      }, error=${saveResult.error || "none"}`
    );
    if (!saveResult.success) {
      logger.error(
        `[DIAGNOSTIC] Error saving vectors to ${storageType}: ${saveResult.error}`
      );
    }

    // 10. Calculate final statistics
    const totalMessagesInFile = rawSessions.reduce(
      (acc: number, session: ChatGPTSession) => {
        return acc + Object.values(session.mapping || {}).length;
      },
      0
    );

    const skipped = totalMessagesInFile - vectors.length;

    // 11. Log of completion
    logger.info(`=============================================`);
    logger.info(`üéâ IMPORTATION COMPLETED SUCCESSFULLY`);
    logger.info(`üìä Statistics:`);
    logger.info(
      `- Mode: ${mode === "overwrite" ? "OVERWRITE" : "INCREMENTAL"}`
    );
    logger.info(
      `- Storage: ${storageType} (${isBasicMode ? "Basic" : "Advanced"} mode)`
    );
    logger.info(`- Embeddings: ${isBasicMode ? "HuggingFace" : "Ollama"}`);
    logger.info(`- Total messages in file: ${totalMessagesInFile}`);
    logger.info(
      `- Duplicated messages ignored: ${skipped} (${Math.round(
        (skipped / totalMessagesInFile) * 100
      )}%)`
    );
    logger.info(
      `- Vectors saved to ${storageType}: ${vectors.length} (${Math.round(
        (vectors.length / totalMessagesInFile) * 100
      )}%)`
    );
    logger.info(`=============================================`);

    return {
      success: true,
      imported: vectors.length,
      skipped,
      totalMessagesInFile,
      mode,
    };
  } catch (error) {
    logger.error(`Importation failed:`, error);
    return {
      success: false,
      imported: 0,
      skipped: 0,
      totalMessagesInFile: 0,
      mode,
      error: error instanceof Error ? error.message : "Unknown error",
    };
  }
}
// SPDX-License-Identifier: MIT OR Apache-2.0
// Copyright (c) 2025 Guilherme Ferrari Brescia

import { IOpenAIService } from "../../../components/context/deepgram/interfaces/openai/IOpenAIService";

// ChatGPT data interfaces for artificial brain memory import
export interface ChatGPTMessageContent {
  content_type: string;
  parts: string[];
}

export interface ChatGPTMessageAuthor {
  role: "user" | "assistant" | "developer" | string;
  name?: string;
}

export interface ChatGPTMessage {
  id: string;
  author: ChatGPTMessageAuthor;
  create_time: number;
  content: ChatGPTMessageContent;
  parent?: string;
  children?: string[];
}

export interface ChatGPTMessageItem {
  message: ChatGPTMessage;
  parent?: string;
}

export interface ChatGPTSession {
  title: string;
  create_time: number;
  update_time: number;
  mapping: Record<string, ChatGPTMessageItem>;
}

// Interface for processed messages used in cognitive memory orchestration
export interface ProcessedMessage {
  role: string;
  content: string;
  timestamp: number | null;
  id: string | null;
  parent: string | null;
  session_title: string | null;
  session_create_time: number | null;
  session_update_time: number | null;
}

// Type for message chunks used in memory segmentation
export interface MessageChunk {
  original: ProcessedMessage;
  content: string;
  part?: number;
  totalParts?: number;
}

// Interface para vetores Pinecone
export interface PineconeVector {
  id: string;
  values: number[];
  metadata: Record<string, string | number | boolean | string[]>;
}

// Interface for progress information
export interface ProgressInfo {
  processed: number;
  total: number;
  percentage: number;
  stage: "parsing" | "deduplicating" | "generating_embeddings" | "saving";
}

// Interface for import parameters (using DuckDB helper with legacy name for compatibility)
export interface ImportChatGPTParams {
  fileBuffer: Buffer;
  mode: "increment" | "overwrite";
  applicationMode?: "basic" | "advanced"; // Mode passed from renderer process
  openAIService?: IOpenAIService | null;
  pineconeHelper: any; // DuckDB helper with legacy interface name for compatibility
  onProgress?: (info: ProgressInfo) => void;
}

// Interface for import result
export interface ImportResult {
  success: boolean;
  imported: number;
  skipped: number;
  totalMessagesInFile: number;
  mode: "increment" | "overwrite";
  error?: string;
}
// SPDX-License-Identifier: MIT OR Apache-2.0
// Copyright (c) 2025 Guilherme Ferrari Brescia

import { ProcessedMessage } from '../../interfaces/types';
import { Logger } from '../../utils/logging';
import { ProgressReporter } from '../../utils/progressReporter';

/**
 * Interface for checking existing vectors (abstraction for Pinecone/DuckDB)
 */
interface IVectorChecker {
  checkExistingIds(ids: string[], progressCallback?: (processed: number, total: number) => void): Promise<string[]>;
}

/**
 * Service to check and eliminate duplicate messages
 */
export class DeduplicationService {
  private vectorChecker: IVectorChecker;
  private progressReporter: ProgressReporter;
  private logger: Logger;

  constructor(vectorChecker: IVectorChecker, progressReporter: ProgressReporter, logger?: Logger) {
    this.vectorChecker = vectorChecker;
    this.progressReporter = progressReporter;
    this.logger = logger || new Logger('[DeduplicationService]');
    this.logger.info('DeduplicationService successfully instantiated');
  }

  /**
   * Filters duplicate messages based on existing IDs
   */
  public async filterDuplicates(
    messages: ProcessedMessage[], 
    mode: 'increment' | 'overwrite'
  ): Promise<ProcessedMessage[]> {
    // Log detalhado das primeiras mensagens recebidas
    this.logger.debug('First 3 messages received for deduplication:', JSON.stringify(messages.slice(0, 3), null, 2));

    // Ensure all messages have a valid id
    const messagesWithIds = messages.map((msg, idx) => ({
      ...msg,
      id: msg.id && msg.id !== '' ? msg.id : `fallback_id_${idx}_${Date.now()}`
    }));
    
    // If mode is overwrite, deduplication is not needed
    if (mode === 'overwrite') {
      this.logger.info('OVERWRITE mode selected, skipping duplicate check');
      return messagesWithIds;
    }
 